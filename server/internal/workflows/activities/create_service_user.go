package activities

import (
	"context"
	"fmt"
	"time"

	"github.com/cschleiden/go-workflows/activity"
	"github.com/cschleiden/go-workflows/workflow"
	"github.com/samber/do"

	"github.com/pgEdge/control-plane/server/internal/certificates"
	"github.com/pgEdge/control-plane/server/internal/database"
	"github.com/pgEdge/control-plane/server/internal/patroni"
	"github.com/pgEdge/control-plane/server/internal/postgres"
	"github.com/pgEdge/control-plane/server/internal/utils"
)

type CreateServiceUserInput struct {
	ServiceInstanceID string `json:"service_instance_id"`
	DatabaseID        string `json:"database_id"`
	DatabaseName      string `json:"database_name"`
	ServiceID         string `json:"service_id"`
	HostID            string `json:"host_id"`
}

type CreateServiceUserOutput struct {
	Credentials *database.ServiceUser `json:"credentials"`
}

func (a *Activities) ExecuteCreateServiceUser(
	ctx workflow.Context,
	hostID string,
	input *CreateServiceUserInput,
) workflow.Future[*CreateServiceUserOutput] {
	options := workflow.ActivityOptions{
		Queue: utils.HostQueue(hostID),
		RetryOptions: workflow.RetryOptions{
			MaxAttempts: 1,
		},
	}
	return workflow.ExecuteActivity[*CreateServiceUserOutput](ctx, options, a.CreateServiceUser, input)
}

// CreateServiceUser creates dedicated database credentials for a service instance.
//
// # Credential Generation Pattern
//
// Each service instance receives isolated database credentials with read-only access.
// This provides security isolation between service instances and prevents services from
// modifying data.
//
// # Username Generation
//
// Usernames follow the format: "svc_{service_id}_{host_id}"
// Example: For service_id "mcp-server" and host_id "host1", the username is
// "svc_mcp-server_host1".
//
// The username is deterministic: the same service_id + host_id always produces
// the same username. It is truncated to 63 characters for PostgreSQL
// compatibility.
//
// # Password Generation
//
// Passwords are generated by utils.RandomString(32), which reads 32 bytes from
// crypto/rand and base64url-encodes them. The result is a 44-character string
// (256 bits of entropy), making brute-force attacks infeasible.
//
// # Database Permissions
//
// Service users are granted the "pgedge_application_read_only" role, which provides:
// - SELECT privileges on all tables
// - EXECUTE privileges on functions (read-only operations)
// - No INSERT, UPDATE, DELETE, or DDL privileges
//
// This follows the principle of least privilege - services can query data but cannot
// modify it. Any data modification must go through the application layer.
//
// # Credential Lifecycle
//
//  1. Provisioning: Credentials are created during service instance provisioning
//  2. Storage: Passwords are stored in etcd alongside service instance metadata
//  3. Injection: Credentials are injected as environment variables (PGUSER/PGPASSWORD)
//     into the service container at startup
//  4. Rotation: Not currently supported (future enhancement)
//  5. Deletion: Credentials are revoked when the service instance is deleted
//
// # Security Considerations
//
// - Credentials are unique per service instance (not shared)
// - Passwords never appear in logs (marked as sensitive)
// - Read-only access prevents data corruption from compromised services
// - Credentials are injected as environment variables into service containers
//
// # Implementation Details
//
// The activity connects to the database's primary instance using admin credentials,
// generates the username and password, then executes CREATE USER and GRANT statements
// via postgres.CreateUserRole(). The generated credentials are returned for storage
// in etcd and injection into the service container.
func (a *Activities) CreateServiceUser(ctx context.Context, input *CreateServiceUserInput) (*CreateServiceUserOutput, error) {
	logger := activity.Logger(ctx).With(
		"service_instance_id", input.ServiceInstanceID,
		"database_id", input.DatabaseID,
	)
	logger.Info("creating service user")

	orch, err := do.Invoke[database.Orchestrator](a.Injector)
	if err != nil {
		return nil, err
	}

	// Get database service to find an instance to connect to
	dbSvc, err := do.Invoke[*database.Service](a.Injector)
	if err != nil {
		return nil, err
	}

	db, err := dbSvc.GetDatabase(ctx, input.DatabaseID)
	if err != nil {
		return nil, fmt.Errorf("failed to get database: %w", err)
	}

	if len(db.Instances) == 0 {
		return nil, fmt.Errorf("database has no instances")
	}

	// Connect to any instance (preferably primary, but any will work for user creation)
	var primaryInstanceID string
	for _, inst := range db.Instances {
		connInfo, err := orch.GetInstanceConnectionInfo(ctx, input.DatabaseID, inst.InstanceID)
		if err != nil {
			continue
		}

		patroniClient := patroni.NewClient(connInfo.PatroniURL(), nil)
		primaryID, err := database.GetPrimaryInstanceID(ctx, patroniClient, 10*time.Second)
		if err == nil && primaryID != "" {
			primaryInstanceID = primaryID
			break
		}
	}

	if primaryInstanceID == "" {
		// Fallback: use first available instance
		primaryInstanceID = db.Instances[0].InstanceID
		logger.Warn("could not determine primary instance, using first available instance")
	}

	// Get connection info for the primary instance
	connInfo, err := orch.GetInstanceConnectionInfo(ctx, input.DatabaseID, primaryInstanceID)
	if err != nil {
		return nil, fmt.Errorf("failed to get instance connection info: %w", err)
	}

	// Get certificate service to create TLS config for pgedge user
	// The pg_hba.conf requires SSL certificate-based authentication for admin connections
	certSvc, err := do.Invoke[*certificates.Service](a.Injector)
	if err != nil {
		return nil, fmt.Errorf("failed to get certificate service: %w", err)
	}

	// Create TLS config with pgedge user certificates
	tlsConfig, err := certSvc.PostgresUserTLS(ctx, primaryInstanceID, connInfo.InstanceHostname, "pgedge")
	if err != nil {
		return nil, fmt.Errorf("failed to create TLS config: %w", err)
	}

	// Connect to the postgres system database
	// Note: We connect to "postgres" instead of the user database because:
	// 1. CREATE ROLE/ALTER ROLE/GRANT are cluster-level operations that work from any database
	// 2. The pg_hba.conf may not allow connections from Control Plane to user databases
	// 3. This matches the pattern used by other user management activities
	conn, err := database.ConnectToInstance(ctx, &database.ConnectionOptions{
		DSN: connInfo.AdminDSN("postgres"),
		TLS: tlsConfig,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}
	defer conn.Close(ctx)

	// Generate credentials
	username := database.GenerateServiceUsername(input.ServiceID, input.HostID)
	password, err := utils.RandomString(32)
	if err != nil {
		return nil, fmt.Errorf("failed to generate password: %w", err)
	}

	// Create user role with read-only permissions
	statements, err := postgres.CreateUserRole(postgres.UserRoleOptions{
		Name:     username,
		Password: password,
		DBName:   input.DatabaseName,
		DBOwner:  false,
		Roles:    []string{"pgedge_application_read_only"},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to generate create user role statements: %w", err)
	}

	// Execute statements
	if err := statements.Exec(ctx, conn); err != nil {
		return nil, fmt.Errorf("failed to create service user: %w", err)
	}

	logger.Info("service user created successfully", "username", username)

	return &CreateServiceUserOutput{
		Credentials: &database.ServiceUser{
			Username: username,
			Password: password,
			Role:     "pgedge_application_read_only",
		},
	}, nil
}
