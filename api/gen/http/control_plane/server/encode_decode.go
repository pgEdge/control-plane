// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/design

package server

import (
	"context"
	"errors"
	"io"
	"net/http"

	controlplane "github.com/pgEdge/control-plane/api/gen/control_plane"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeInspectClusterResponse returns an encoder for responses returned by
// the control-plane inspect-cluster endpoint.
func EncodeInspectClusterResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Cluster)
		enc := encoder(ctx, w)
		body := NewInspectClusterResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeListHostsResponse returns an encoder for responses returned by the
// control-plane list-hosts endpoint.
func EncodeListHostsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]*controlplane.Host)
		enc := encoder(ctx, w)
		body := NewListHostsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeInspectHostResponse returns an encoder for responses returned by the
// control-plane inspect-host endpoint.
func EncodeInspectHostResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Host)
		enc := encoder(ctx, w)
		body := NewInspectHostResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeInspectHostRequest returns a decoder for requests sent to the
// control-plane inspect-host endpoint.
func DecodeInspectHostRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			hostID string

			params = mux.Vars(r)
		)
		hostID = params["host_id"]
		payload := NewInspectHostPayload(hostID)

		return payload, nil
	}
}

// EncodeRemoveHostResponse returns an encoder for responses returned by the
// control-plane remove-host endpoint.
func EncodeRemoveHostResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeRemoveHostRequest returns a decoder for requests sent to the
// control-plane remove-host endpoint.
func DecodeRemoveHostRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			hostID string

			params = mux.Vars(r)
		)
		hostID = params["host_id"]
		payload := NewRemoveHostPayload(hostID)

		return payload, nil
	}
}

// EncodeListDatabasesResponse returns an encoder for responses returned by the
// control-plane list-databases endpoint.
func EncodeListDatabasesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]*controlplane.Database)
		enc := encoder(ctx, w)
		body := NewListDatabasesResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeCreateDatabaseResponse returns an encoder for responses returned by
// the control-plane create-database endpoint.
func EncodeCreateDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Database)
		enc := encoder(ctx, w)
		body := NewCreateDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreateDatabaseRequest returns a decoder for requests sent to the
// control-plane create-database endpoint.
func DecodeCreateDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateDatabaseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateDatabaseRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewCreateDatabaseRequest(&body)

		return payload, nil
	}
}

// EncodeInspectDatabaseResponse returns an encoder for responses returned by
// the control-plane inspect-database endpoint.
func EncodeInspectDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Database)
		enc := encoder(ctx, w)
		body := NewInspectDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeInspectDatabaseRequest returns a decoder for requests sent to the
// control-plane inspect-database endpoint.
func DecodeInspectDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			databaseID string

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		payload := NewInspectDatabasePayload(databaseID)

		return payload, nil
	}
}

// EncodeUpdateDatabaseResponse returns an encoder for responses returned by
// the control-plane update-database endpoint.
func EncodeUpdateDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Database)
		enc := encoder(ctx, w)
		body := NewUpdateDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateDatabaseRequest returns a decoder for requests sent to the
// control-plane update-database endpoint.
func DecodeUpdateDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateDatabaseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				err = nil
			} else {
				var gerr *goa.ServiceError
				if errors.As(err, &gerr) {
					return nil, gerr
				}
				return nil, goa.DecodePayloadError(err.Error())
			}
		}
		err = ValidateUpdateDatabaseRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			databaseID string

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		payload := NewUpdateDatabasePayload(&body, databaseID)

		return payload, nil
	}
}

// EncodeDeleteDatabaseResponse returns an encoder for responses returned by
// the control-plane delete-database endpoint.
func EncodeDeleteDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteDatabaseRequest returns a decoder for requests sent to the
// control-plane delete-database endpoint.
func DecodeDeleteDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			databaseID string

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		payload := NewDeleteDatabasePayload(databaseID)

		return payload, nil
	}
}

// marshalControlplaneClusterStatusToClusterStatusResponseBody builds a value
// of type *ClusterStatusResponseBody from a value of type
// *controlplane.ClusterStatus.
func marshalControlplaneClusterStatusToClusterStatusResponseBody(v *controlplane.ClusterStatus) *ClusterStatusResponseBody {
	res := &ClusterStatusResponseBody{
		State: v.State,
	}

	return res
}

// marshalControlplaneHostToHostResponseBody builds a value of type
// *HostResponseBody from a value of type *controlplane.Host.
func marshalControlplaneHostToHostResponseBody(v *controlplane.Host) *HostResponseBody {
	res := &HostResponseBody{
		ID:          v.ID,
		Type:        v.Type,
		Cohort:      v.Cohort,
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
	}
	if v.Config != nil {
		res.Config = marshalControlplaneHostConfigurationToHostConfigurationResponseBody(v.Config)
	}
	if v.Status != nil {
		res.Status = marshalControlplaneHostStatusToHostStatusResponseBody(v.Status)
	}

	return res
}

// marshalControlplaneHostConfigurationToHostConfigurationResponseBody builds a
// value of type *HostConfigurationResponseBody from a value of type
// *controlplane.HostConfiguration.
func marshalControlplaneHostConfigurationToHostConfigurationResponseBody(v *controlplane.HostConfiguration) *HostConfigurationResponseBody {
	if v == nil {
		return nil
	}
	res := &HostConfigurationResponseBody{
		VectorEnabled:  v.VectorEnabled,
		TraefikEnabled: v.TraefikEnabled,
	}

	return res
}

// marshalControlplaneHostStatusToHostStatusResponseBody builds a value of type
// *HostStatusResponseBody from a value of type *controlplane.HostStatus.
func marshalControlplaneHostStatusToHostStatusResponseBody(v *controlplane.HostStatus) *HostStatusResponseBody {
	res := &HostStatusResponseBody{
		State: v.State,
	}

	return res
}

// marshalControlplaneHostToHostResponse builds a value of type *HostResponse
// from a value of type *controlplane.Host.
func marshalControlplaneHostToHostResponse(v *controlplane.Host) *HostResponse {
	res := &HostResponse{
		ID:          v.ID,
		Type:        v.Type,
		Cohort:      v.Cohort,
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
	}
	if v.Config != nil {
		res.Config = marshalControlplaneHostConfigurationToHostConfigurationResponse(v.Config)
	}
	if v.Status != nil {
		res.Status = marshalControlplaneHostStatusToHostStatusResponse(v.Status)
	}

	return res
}

// marshalControlplaneHostConfigurationToHostConfigurationResponse builds a
// value of type *HostConfigurationResponse from a value of type
// *controlplane.HostConfiguration.
func marshalControlplaneHostConfigurationToHostConfigurationResponse(v *controlplane.HostConfiguration) *HostConfigurationResponse {
	if v == nil {
		return nil
	}
	res := &HostConfigurationResponse{
		VectorEnabled:  v.VectorEnabled,
		TraefikEnabled: v.TraefikEnabled,
	}

	return res
}

// marshalControlplaneHostStatusToHostStatusResponse builds a value of type
// *HostStatusResponse from a value of type *controlplane.HostStatus.
func marshalControlplaneHostStatusToHostStatusResponse(v *controlplane.HostStatus) *HostStatusResponse {
	res := &HostStatusResponse{
		State: v.State,
	}

	return res
}

// marshalControlplaneDatabaseToDatabaseResponse builds a value of type
// *DatabaseResponse from a value of type *controlplane.Database.
func marshalControlplaneDatabaseToDatabaseResponse(v *controlplane.Database) *DatabaseResponse {
	res := &DatabaseResponse{
		ID:        v.ID,
		TenantID:  v.TenantID,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
	}
	if v.Status != nil {
		res.Status = marshalControlplaneDatabaseStatusToDatabaseStatusResponse(v.Status)
	}
	if v.Instances != nil {
		res.Instances = marshalControlplaneInstanceToInstanceResponse(v.Instances)
	}
	if v.Spec != nil {
		res.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecResponse(v.Spec)
	}

	return res
}

// marshalControlplaneDatabaseStatusToDatabaseStatusResponse builds a value of
// type *DatabaseStatusResponse from a value of type
// *controlplane.DatabaseStatus.
func marshalControlplaneDatabaseStatusToDatabaseStatusResponse(v *controlplane.DatabaseStatus) *DatabaseStatusResponse {
	res := &DatabaseStatusResponse{
		State:     v.State,
		UpdatedAt: v.UpdatedAt,
	}

	return res
}

// marshalControlplaneInstanceToInstanceResponse builds a value of type
// *InstanceResponse from a value of type *controlplane.Instance.
func marshalControlplaneInstanceToInstanceResponse(v *controlplane.Instance) *InstanceResponse {
	res := &InstanceResponse{
		ID:        v.ID,
		HostID:    v.HostID,
		NodeName:  v.NodeName,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
	}
	if v.Status != nil {
		res.Status = marshalControlplaneInstanceStatusToInstanceStatusResponse(v.Status)
	}
	if v.Interfaces != nil {
		res.Interfaces = make([]*InstanceInterfaceResponse, len(v.Interfaces))
		for i, val := range v.Interfaces {
			res.Interfaces[i] = marshalControlplaneInstanceInterfaceToInstanceInterfaceResponse(val)
		}
	}

	return res
}

// marshalControlplaneInstanceStatusToInstanceStatusResponse builds a value of
// type *InstanceStatusResponse from a value of type
// *controlplane.InstanceStatus.
func marshalControlplaneInstanceStatusToInstanceStatusResponse(v *controlplane.InstanceStatus) *InstanceStatusResponse {
	res := &InstanceStatusResponse{
		State:           v.State,
		PatroniState:    v.PatroniState,
		Role:            v.Role,
		ReadOnly:        v.ReadOnly,
		PendingRestart:  v.PendingRestart,
		PatroniPaused:   v.PatroniPaused,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		UpdatedAt:       v.UpdatedAt,
	}

	return res
}

// marshalControlplaneInstanceInterfaceToInstanceInterfaceResponse builds a
// value of type *InstanceInterfaceResponse from a value of type
// *controlplane.InstanceInterface.
func marshalControlplaneInstanceInterfaceToInstanceInterfaceResponse(v *controlplane.InstanceInterface) *InstanceInterfaceResponse {
	if v == nil {
		return nil
	}
	res := &InstanceInterfaceResponse{
		NetworkType: v.NetworkType,
		NetworkID:   v.NetworkID,
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// marshalControlplaneDatabaseSpecToDatabaseSpecResponse builds a value of type
// *DatabaseSpecResponse from a value of type *controlplane.DatabaseSpec.
func marshalControlplaneDatabaseSpecToDatabaseSpecResponse(v *controlplane.DatabaseSpec) *DatabaseSpecResponse {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecResponse{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecResponse, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponse(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecResponse{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecResponse, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponse(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*DatabaseExtensionSpecResponse, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecResponse(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*BackupConfigSpecResponse, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = marshalControlplaneBackupConfigSpecToBackupConfigSpecResponse(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponse builds a value
// of type *DatabaseNodeSpecResponse from a value of type
// *controlplane.DatabaseNodeSpec.
func marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponse(v *controlplane.DatabaseNodeSpec) *DatabaseNodeSpecResponse {
	res := &DatabaseNodeSpecResponse{
		Name:            v.Name,
		InstanceID:      v.InstanceID,
		HostID:          v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecResponse(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecResponse builds a
// value of type *DatabaseReplicaSpecResponse from a value of type
// *controlplane.DatabaseReplicaSpec.
func marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecResponse(v *controlplane.DatabaseReplicaSpec) *DatabaseReplicaSpecResponse {
	if v == nil {
		return nil
	}
	res := &DatabaseReplicaSpecResponse{
		InstanceID: v.InstanceID,
		HostID:     v.HostID,
	}

	return res
}

// marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponse builds a value
// of type *DatabaseUserSpecResponse from a value of type
// *controlplane.DatabaseUserSpec.
func marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponse(v *controlplane.DatabaseUserSpec) *DatabaseUserSpecResponse {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecResponse{
		Username:  v.Username,
		Password:  v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecResponse
// builds a value of type *DatabaseExtensionSpecResponse from a value of type
// *controlplane.DatabaseExtensionSpec.
func marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecResponse(v *controlplane.DatabaseExtensionSpec) *DatabaseExtensionSpecResponse {
	if v == nil {
		return nil
	}
	res := &DatabaseExtensionSpecResponse{
		Name:    v.Name,
		Version: v.Version,
	}

	return res
}

// marshalControlplaneBackupConfigSpecToBackupConfigSpecResponse builds a value
// of type *BackupConfigSpecResponse from a value of type
// *controlplane.BackupConfigSpec.
func marshalControlplaneBackupConfigSpecToBackupConfigSpecResponse(v *controlplane.BackupConfigSpec) *BackupConfigSpecResponse {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecResponse{
		ID:       v.ID,
		Provider: v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecResponse, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponse(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecResponse, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponse(val)
		}
	}

	return res
}

// marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponse builds
// a value of type *BackupRepositorySpecResponse from a value of type
// *controlplane.BackupRepositorySpec.
func marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponse(v *controlplane.BackupRepositorySpec) *BackupRepositorySpecResponse {
	if v == nil {
		return nil
	}
	res := &BackupRepositorySpecResponse{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponse builds a
// value of type *BackupScheduleSpecResponse from a value of type
// *controlplane.BackupScheduleSpec.
func marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponse(v *controlplane.BackupScheduleSpec) *BackupScheduleSpecResponse {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecResponse{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// unmarshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec builds a value of
// type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBody.
func unmarshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBody) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       *v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
	for i, val := range v.Nodes {
		res.Nodes[i] = unmarshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*controlplane.DatabaseExtensionSpec, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = unmarshalDatabaseExtensionSpecRequestBodyToControlplaneDatabaseExtensionSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*controlplane.BackupConfigSpec, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec builds a
// value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBody.
func unmarshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            *v.Name,
		InstanceID:      *v.InstanceID,
		HostID:          *v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = unmarshalDatabaseReplicaSpecRequestBodyToControlplaneDatabaseReplicaSpec(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseReplicaSpecRequestBodyToControlplaneDatabaseReplicaSpec
// builds a value of type *controlplane.DatabaseReplicaSpec from a value of
// type *DatabaseReplicaSpecRequestBody.
func unmarshalDatabaseReplicaSpecRequestBodyToControlplaneDatabaseReplicaSpec(v *DatabaseReplicaSpecRequestBody) *controlplane.DatabaseReplicaSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseReplicaSpec{
		InstanceID: *v.InstanceID,
		HostID:     *v.HostID,
	}

	return res
}

// unmarshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec builds a
// value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBody.
func unmarshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username:  *v.Username,
		Password:  *v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// unmarshalDatabaseExtensionSpecRequestBodyToControlplaneDatabaseExtensionSpec
// builds a value of type *controlplane.DatabaseExtensionSpec from a value of
// type *DatabaseExtensionSpecRequestBody.
func unmarshalDatabaseExtensionSpecRequestBodyToControlplaneDatabaseExtensionSpec(v *DatabaseExtensionSpecRequestBody) *controlplane.DatabaseExtensionSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseExtensionSpec{
		Name:    *v.Name,
		Version: v.Version,
	}

	return res
}

// unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec builds a
// value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBody.
func unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{
		ID:       *v.ID,
		Provider: *v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = unmarshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = unmarshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBody.
func unmarshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBody) *controlplane.BackupRepositorySpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// unmarshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec
// builds a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBody.
func unmarshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// marshalControlplaneDatabaseStatusToDatabaseStatusResponseBody builds a value
// of type *DatabaseStatusResponseBody from a value of type
// *controlplane.DatabaseStatus.
func marshalControlplaneDatabaseStatusToDatabaseStatusResponseBody(v *controlplane.DatabaseStatus) *DatabaseStatusResponseBody {
	res := &DatabaseStatusResponseBody{
		State:     v.State,
		UpdatedAt: v.UpdatedAt,
	}

	return res
}

// marshalControlplaneInstanceToInstanceResponseBody builds a value of type
// *InstanceResponseBody from a value of type *controlplane.Instance.
func marshalControlplaneInstanceToInstanceResponseBody(v *controlplane.Instance) *InstanceResponseBody {
	res := &InstanceResponseBody{
		ID:        v.ID,
		HostID:    v.HostID,
		NodeName:  v.NodeName,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
	}
	if v.Status != nil {
		res.Status = marshalControlplaneInstanceStatusToInstanceStatusResponseBody(v.Status)
	}
	if v.Interfaces != nil {
		res.Interfaces = make([]*InstanceInterfaceResponseBody, len(v.Interfaces))
		for i, val := range v.Interfaces {
			res.Interfaces[i] = marshalControlplaneInstanceInterfaceToInstanceInterfaceResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneInstanceStatusToInstanceStatusResponseBody builds a value
// of type *InstanceStatusResponseBody from a value of type
// *controlplane.InstanceStatus.
func marshalControlplaneInstanceStatusToInstanceStatusResponseBody(v *controlplane.InstanceStatus) *InstanceStatusResponseBody {
	res := &InstanceStatusResponseBody{
		State:           v.State,
		PatroniState:    v.PatroniState,
		Role:            v.Role,
		ReadOnly:        v.ReadOnly,
		PendingRestart:  v.PendingRestart,
		PatroniPaused:   v.PatroniPaused,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		UpdatedAt:       v.UpdatedAt,
	}

	return res
}

// marshalControlplaneInstanceInterfaceToInstanceInterfaceResponseBody builds a
// value of type *InstanceInterfaceResponseBody from a value of type
// *controlplane.InstanceInterface.
func marshalControlplaneInstanceInterfaceToInstanceInterfaceResponseBody(v *controlplane.InstanceInterface) *InstanceInterfaceResponseBody {
	if v == nil {
		return nil
	}
	res := &InstanceInterfaceResponseBody{
		NetworkType: v.NetworkType,
		NetworkID:   v.NetworkID,
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody builds a value of
// type *DatabaseSpecResponseBody from a value of type
// *controlplane.DatabaseSpec.
func marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody(v *controlplane.DatabaseSpec) *DatabaseSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecResponseBody{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecResponseBody, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponseBody(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecResponseBody{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecResponseBody, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponseBody(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*DatabaseExtensionSpecResponseBody, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecResponseBody(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*BackupConfigSpecResponseBody, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponseBody builds a
// value of type *DatabaseNodeSpecResponseBody from a value of type
// *controlplane.DatabaseNodeSpec.
func marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponseBody(v *controlplane.DatabaseNodeSpec) *DatabaseNodeSpecResponseBody {
	res := &DatabaseNodeSpecResponseBody{
		Name:            v.Name,
		InstanceID:      v.InstanceID,
		HostID:          v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecResponseBody(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecResponseBody
// builds a value of type *DatabaseReplicaSpecResponseBody from a value of type
// *controlplane.DatabaseReplicaSpec.
func marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecResponseBody(v *controlplane.DatabaseReplicaSpec) *DatabaseReplicaSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseReplicaSpecResponseBody{
		InstanceID: v.InstanceID,
		HostID:     v.HostID,
	}

	return res
}

// marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponseBody builds a
// value of type *DatabaseUserSpecResponseBody from a value of type
// *controlplane.DatabaseUserSpec.
func marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponseBody(v *controlplane.DatabaseUserSpec) *DatabaseUserSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecResponseBody{
		Username:  v.Username,
		Password:  v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecResponseBody
// builds a value of type *DatabaseExtensionSpecResponseBody from a value of
// type *controlplane.DatabaseExtensionSpec.
func marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecResponseBody(v *controlplane.DatabaseExtensionSpec) *DatabaseExtensionSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseExtensionSpecResponseBody{
		Name:    v.Name,
		Version: v.Version,
	}

	return res
}

// marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody builds a
// value of type *BackupConfigSpecResponseBody from a value of type
// *controlplane.BackupConfigSpec.
func marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody(v *controlplane.BackupConfigSpec) *BackupConfigSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecResponseBody{
		ID:       v.ID,
		Provider: v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecResponseBody, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponseBody(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecResponseBody, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponseBody
// builds a value of type *BackupRepositorySpecResponseBody from a value of
// type *controlplane.BackupRepositorySpec.
func marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponseBody(v *controlplane.BackupRepositorySpec) *BackupRepositorySpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupRepositorySpecResponseBody{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponseBody builds
// a value of type *BackupScheduleSpecResponseBody from a value of type
// *controlplane.BackupScheduleSpec.
func marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponseBody(v *controlplane.BackupScheduleSpec) *BackupScheduleSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecResponseBody{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// unmarshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec builds
// a value of type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBodyRequestBody.
func unmarshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBodyRequestBody) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       *v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
	for i, val := range v.Nodes {
		res.Nodes[i] = unmarshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*controlplane.DatabaseExtensionSpec, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = unmarshalDatabaseExtensionSpecRequestBodyRequestBodyToControlplaneDatabaseExtensionSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*controlplane.BackupConfigSpec, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec
// builds a value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBodyRequestBody.
func unmarshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBodyRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            *v.Name,
		InstanceID:      *v.InstanceID,
		HostID:          *v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = unmarshalDatabaseReplicaSpecRequestBodyRequestBodyToControlplaneDatabaseReplicaSpec(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseReplicaSpecRequestBodyRequestBodyToControlplaneDatabaseReplicaSpec
// builds a value of type *controlplane.DatabaseReplicaSpec from a value of
// type *DatabaseReplicaSpecRequestBodyRequestBody.
func unmarshalDatabaseReplicaSpecRequestBodyRequestBodyToControlplaneDatabaseReplicaSpec(v *DatabaseReplicaSpecRequestBodyRequestBody) *controlplane.DatabaseReplicaSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseReplicaSpec{
		InstanceID: *v.InstanceID,
		HostID:     *v.HostID,
	}

	return res
}

// unmarshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec
// builds a value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBodyRequestBody.
func unmarshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBodyRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username:  *v.Username,
		Password:  *v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// unmarshalDatabaseExtensionSpecRequestBodyRequestBodyToControlplaneDatabaseExtensionSpec
// builds a value of type *controlplane.DatabaseExtensionSpec from a value of
// type *DatabaseExtensionSpecRequestBodyRequestBody.
func unmarshalDatabaseExtensionSpecRequestBodyRequestBodyToControlplaneDatabaseExtensionSpec(v *DatabaseExtensionSpecRequestBodyRequestBody) *controlplane.DatabaseExtensionSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseExtensionSpec{
		Name:    *v.Name,
		Version: v.Version,
	}

	return res
}

// unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec
// builds a value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBodyRequestBody.
func unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBodyRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{
		ID:       *v.ID,
		Provider: *v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = unmarshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = unmarshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBodyRequestBody.
func unmarshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBodyRequestBody) *controlplane.BackupRepositorySpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// unmarshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec
// builds a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBodyRequestBody.
func unmarshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBodyRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}
