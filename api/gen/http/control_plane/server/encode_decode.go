// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/design

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"

	controlplane "github.com/pgEdge/control-plane/api/gen/control_plane"
	controlplaneviews "github.com/pgEdge/control-plane/api/gen/control_plane/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeInitClusterResponse returns an encoder for responses returned by the
// control-plane init-cluster endpoint.
func EncodeInitClusterResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ClusterJoinToken)
		enc := encoder(ctx, w)
		body := NewInitClusterResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeInitClusterError returns an encoder for errors returned by the
// init-cluster control-plane endpoint.
func EncodeInitClusterError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_already_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInitClusterClusterAlreadyInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeJoinClusterResponse returns an encoder for responses returned by the
// control-plane join-cluster endpoint.
func EncodeJoinClusterResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeJoinClusterRequest returns a decoder for requests sent to the
// control-plane join-cluster endpoint.
func DecodeJoinClusterRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body JoinClusterRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateJoinClusterRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewJoinClusterClusterJoinToken(&body)

		return payload, nil
	}
}

// EncodeJoinClusterError returns an encoder for errors returned by the
// join-cluster control-plane endpoint.
func EncodeJoinClusterError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_already_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewJoinClusterClusterAlreadyInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetJoinTokenResponse returns an encoder for responses returned by the
// control-plane get-join-token endpoint.
func EncodeGetJoinTokenResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ClusterJoinToken)
		enc := encoder(ctx, w)
		body := NewGetJoinTokenResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeGetJoinTokenError returns an encoder for errors returned by the
// get-join-token control-plane endpoint.
func EncodeGetJoinTokenError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetJoinTokenClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetJoinOptionsResponse returns an encoder for responses returned by
// the control-plane get-join-options endpoint.
func EncodeGetJoinOptionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ClusterJoinOptions)
		enc := encoder(ctx, w)
		body := NewGetJoinOptionsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetJoinOptionsRequest returns a decoder for requests sent to the
// control-plane get-join-options endpoint.
func DecodeGetJoinOptionsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body GetJoinOptionsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateGetJoinOptionsRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewGetJoinOptionsClusterJoinRequest(&body)

		return payload, nil
	}
}

// EncodeGetJoinOptionsError returns an encoder for errors returned by the
// get-join-options control-plane endpoint.
func EncodeGetJoinOptionsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetJoinOptionsClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_join_token":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetJoinOptionsInvalidJoinTokenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeInspectClusterResponse returns an encoder for responses returned by
// the control-plane inspect-cluster endpoint.
func EncodeInspectClusterResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Cluster)
		enc := encoder(ctx, w)
		body := NewInspectClusterResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeInspectClusterError returns an encoder for errors returned by the
// inspect-cluster control-plane endpoint.
func EncodeInspectClusterError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInspectClusterClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInspectClusterNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListHostsResponse returns an encoder for responses returned by the
// control-plane list-hosts endpoint.
func EncodeListHostsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]*controlplane.Host)
		enc := encoder(ctx, w)
		body := NewListHostsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeListHostsError returns an encoder for errors returned by the
// list-hosts control-plane endpoint.
func EncodeListHostsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListHostsClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeInspectHostResponse returns an encoder for responses returned by the
// control-plane inspect-host endpoint.
func EncodeInspectHostResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Host)
		enc := encoder(ctx, w)
		body := NewInspectHostResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeInspectHostRequest returns a decoder for requests sent to the
// control-plane inspect-host endpoint.
func DecodeInspectHostRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			hostID string

			params = mux.Vars(r)
		)
		hostID = params["host_id"]
		payload := NewInspectHostPayload(hostID)

		return payload, nil
	}
}

// EncodeInspectHostError returns an encoder for errors returned by the
// inspect-host control-plane endpoint.
func EncodeInspectHostError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInspectHostClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInspectHostNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRemoveHostResponse returns an encoder for responses returned by the
// control-plane remove-host endpoint.
func EncodeRemoveHostResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeRemoveHostRequest returns a decoder for requests sent to the
// control-plane remove-host endpoint.
func DecodeRemoveHostRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			hostID string

			params = mux.Vars(r)
		)
		hostID = params["host_id"]
		payload := NewRemoveHostPayload(hostID)

		return payload, nil
	}
}

// EncodeRemoveHostError returns an encoder for errors returned by the
// remove-host control-plane endpoint.
func EncodeRemoveHostError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveHostClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveHostNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListDatabasesResponse returns an encoder for responses returned by the
// control-plane list-databases endpoint.
func EncodeListDatabasesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(controlplaneviews.DatabaseCollection)
		enc := encoder(ctx, w)
		body := NewDatabaseResponseAbbreviatedCollection(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeListDatabasesError returns an encoder for errors returned by the
// list-databases control-plane endpoint.
func EncodeListDatabasesError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListDatabasesClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateDatabaseResponse returns an encoder for responses returned by
// the control-plane create-database endpoint.
func EncodeCreateDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.CreateDatabaseResponse)
		enc := encoder(ctx, w)
		body := NewCreateDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreateDatabaseRequest returns a decoder for requests sent to the
// control-plane create-database endpoint.
func DecodeCreateDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateDatabaseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateDatabaseRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewCreateDatabaseRequest(&body)

		return payload, nil
	}
}

// EncodeCreateDatabaseError returns an encoder for errors returned by the
// create-database control-plane endpoint.
func EncodeCreateDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "database_already_exists":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateDatabaseDatabaseAlreadyExistsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateDatabaseInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeInspectDatabaseResponse returns an encoder for responses returned by
// the control-plane inspect-database endpoint.
func EncodeInspectDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*controlplaneviews.Database)
		enc := encoder(ctx, w)
		body := NewInspectDatabaseResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeInspectDatabaseRequest returns a decoder for requests sent to the
// control-plane inspect-database endpoint.
func DecodeInspectDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			databaseID string

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		payload := NewInspectDatabasePayload(databaseID)

		return payload, nil
	}
}

// EncodeInspectDatabaseError returns an encoder for errors returned by the
// inspect-database control-plane endpoint.
func EncodeInspectDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInspectDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInspectDatabaseNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateDatabaseResponse returns an encoder for responses returned by
// the control-plane update-database endpoint.
func EncodeUpdateDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.UpdateDatabaseResponse)
		enc := encoder(ctx, w)
		body := NewUpdateDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateDatabaseRequest returns a decoder for requests sent to the
// control-plane update-database endpoint.
func DecodeUpdateDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateDatabaseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				err = nil
			} else {
				var gerr *goa.ServiceError
				if errors.As(err, &gerr) {
					return nil, gerr
				}
				return nil, goa.DecodePayloadError(err.Error())
			}
		}
		err = ValidateUpdateDatabaseRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			databaseID  string
			forceUpdate *bool

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		{
			forceUpdateRaw := r.URL.Query().Get("force_update")
			if forceUpdateRaw != "" {
				v, err2 := strconv.ParseBool(forceUpdateRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("force_update", forceUpdateRaw, "boolean"))
				}
				forceUpdate = &v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateDatabasePayload(&body, databaseID, forceUpdate)

		return payload, nil
	}
}

// EncodeUpdateDatabaseError returns an encoder for errors returned by the
// update-database control-plane endpoint.
func EncodeUpdateDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateDatabaseDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateDatabaseNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteDatabaseResponse returns an encoder for responses returned by
// the control-plane delete-database endpoint.
func EncodeDeleteDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.DeleteDatabaseResponse)
		enc := encoder(ctx, w)
		body := NewDeleteDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDeleteDatabaseRequest returns a decoder for requests sent to the
// control-plane delete-database endpoint.
func DecodeDeleteDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			databaseID string
			err        error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("database_id", databaseID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
		payload := NewDeleteDatabasePayload(databaseID)

		return payload, nil
	}
}

// EncodeDeleteDatabaseError returns an encoder for errors returned by the
// delete-database control-plane endpoint.
func EncodeDeleteDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteDatabaseDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteDatabaseNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeBackupDatabaseNodeResponse returns an encoder for responses returned
// by the control-plane backup-database-node endpoint.
func EncodeBackupDatabaseNodeResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.BackupDatabaseNodeResponse)
		enc := encoder(ctx, w)
		body := NewBackupDatabaseNodeResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeBackupDatabaseNodeRequest returns a decoder for requests sent to the
// control-plane backup-database-node endpoint.
func DecodeBackupDatabaseNodeRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body BackupDatabaseNodeRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateBackupDatabaseNodeRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			databaseID string
			nodeName   string

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("database_id", databaseID, goa.FormatUUID))
		nodeName = params["node_name"]
		if err != nil {
			return nil, err
		}
		payload := NewBackupDatabaseNodePayload(&body, databaseID, nodeName)

		return payload, nil
	}
}

// EncodeBackupDatabaseNodeError returns an encoder for errors returned by the
// backup-database-node control-plane endpoint.
func EncodeBackupDatabaseNodeError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "backup_already_in_progress":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeBackupAlreadyInProgressResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListDatabaseTasksResponse returns an encoder for responses returned by
// the control-plane list-database-tasks endpoint.
func EncodeListDatabaseTasksResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]*controlplane.Task)
		enc := encoder(ctx, w)
		body := NewListDatabaseTasksResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListDatabaseTasksRequest returns a decoder for requests sent to the
// control-plane list-database-tasks endpoint.
func DecodeListDatabaseTasksRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			databaseID  string
			afterTaskID *string
			limit       *int
			sortOrder   *string
			err         error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("database_id", databaseID, goa.FormatUUID))
		qp := r.URL.Query()
		afterTaskIDRaw := qp.Get("after_task_id")
		if afterTaskIDRaw != "" {
			afterTaskID = &afterTaskIDRaw
		}
		if afterTaskID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("after_task_id", *afterTaskID, goa.FormatUUID))
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw != "" {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				pv := int(v)
				limit = &pv
			}
		}
		sortOrderRaw := qp.Get("sort_order")
		if sortOrderRaw != "" {
			sortOrder = &sortOrderRaw
		}
		if sortOrder != nil {
			if !(*sortOrder == "asc" || *sortOrder == "ascend" || *sortOrder == "ascending" || *sortOrder == "desc" || *sortOrder == "descend" || *sortOrder == "descending") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort_order", *sortOrder, []any{"asc", "ascend", "ascending", "desc", "descend", "descending"}))
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewListDatabaseTasksPayload(databaseID, afterTaskID, limit, sortOrder)

		return payload, nil
	}
}

// EncodeListDatabaseTasksError returns an encoder for errors returned by the
// list-database-tasks control-plane endpoint.
func EncodeListDatabaseTasksError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListDatabaseTasksClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListDatabaseTasksNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeInspectDatabaseTaskResponse returns an encoder for responses returned
// by the control-plane inspect-database-task endpoint.
func EncodeInspectDatabaseTaskResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Task)
		enc := encoder(ctx, w)
		body := NewInspectDatabaseTaskResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeInspectDatabaseTaskRequest returns a decoder for requests sent to the
// control-plane inspect-database-task endpoint.
func DecodeInspectDatabaseTaskRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			databaseID string
			taskID     string
			err        error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("database_id", databaseID, goa.FormatUUID))
		taskID = params["task_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("task_id", taskID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
		payload := NewInspectDatabaseTaskPayload(databaseID, taskID)

		return payload, nil
	}
}

// EncodeInspectDatabaseTaskError returns an encoder for errors returned by the
// inspect-database-task control-plane endpoint.
func EncodeInspectDatabaseTaskError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInspectDatabaseTaskClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInspectDatabaseTaskNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetDatabaseTaskLogResponse returns an encoder for responses returned
// by the control-plane get-database-task-log endpoint.
func EncodeGetDatabaseTaskLogResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.TaskLog)
		enc := encoder(ctx, w)
		body := NewGetDatabaseTaskLogResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetDatabaseTaskLogRequest returns a decoder for requests sent to the
// control-plane get-database-task-log endpoint.
func DecodeGetDatabaseTaskLogRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			databaseID       string
			taskID           string
			afterLineID      *string
			limit            *int
			includeTimestamp *bool
			err              error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("database_id", databaseID, goa.FormatUUID))
		taskID = params["task_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("task_id", taskID, goa.FormatUUID))
		qp := r.URL.Query()
		afterLineIDRaw := qp.Get("after_line_id")
		if afterLineIDRaw != "" {
			afterLineID = &afterLineIDRaw
		}
		if afterLineID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("after_line_id", *afterLineID, goa.FormatUUID))
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw != "" {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				pv := int(v)
				limit = &pv
			}
		}
		{
			includeTimestampRaw := qp.Get("include_timestamp")
			if includeTimestampRaw != "" {
				v, err2 := strconv.ParseBool(includeTimestampRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("include_timestamp", includeTimestampRaw, "boolean"))
				}
				includeTimestamp = &v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetDatabaseTaskLogPayload(databaseID, taskID, afterLineID, limit, includeTimestamp)

		return payload, nil
	}
}

// EncodeGetDatabaseTaskLogError returns an encoder for errors returned by the
// get-database-task-log control-plane endpoint.
func EncodeGetDatabaseTaskLogError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskLogClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskLogNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRestoreDatabaseResponse returns an encoder for responses returned by
// the control-plane restore-database endpoint.
func EncodeRestoreDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.RestoreDatabaseResponse)
		enc := encoder(ctx, w)
		body := NewRestoreDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeRestoreDatabaseRequest returns a decoder for requests sent to the
// control-plane restore-database endpoint.
func DecodeRestoreDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body RestoreDatabaseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateRestoreDatabaseRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			databaseID string

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("database_id", databaseID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
		payload := NewRestoreDatabasePayload(&body, databaseID)

		return payload, nil
	}
}

// EncodeRestoreDatabaseError returns an encoder for errors returned by the
// restore-database control-plane endpoint.
func EncodeRestoreDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "invalid_input":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetVersionResponse returns an encoder for responses returned by the
// control-plane get-version endpoint.
func EncodeGetVersionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.VersionInfo)
		enc := encoder(ctx, w)
		body := NewGetVersionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// marshalControlplaneClusterPeerToClusterPeerResponseBody builds a value of
// type *ClusterPeerResponseBody from a value of type *controlplane.ClusterPeer.
func marshalControlplaneClusterPeerToClusterPeerResponseBody(v *controlplane.ClusterPeer) *ClusterPeerResponseBody {
	res := &ClusterPeerResponseBody{
		Name:      v.Name,
		PeerURL:   v.PeerURL,
		ClientURL: v.ClientURL,
	}

	return res
}

// marshalControlplaneClusterCredentialsToClusterCredentialsResponseBody builds
// a value of type *ClusterCredentialsResponseBody from a value of type
// *controlplane.ClusterCredentials.
func marshalControlplaneClusterCredentialsToClusterCredentialsResponseBody(v *controlplane.ClusterCredentials) *ClusterCredentialsResponseBody {
	if v == nil {
		return nil
	}
	res := &ClusterCredentialsResponseBody{
		CaCert:     v.CaCert,
		ClientCert: v.ClientCert,
		ClientKey:  v.ClientKey,
		ServerCert: v.ServerCert,
		ServerKey:  v.ServerKey,
	}

	return res
}

// marshalControlplaneClusterStatusToClusterStatusResponseBody builds a value
// of type *ClusterStatusResponseBody from a value of type
// *controlplane.ClusterStatus.
func marshalControlplaneClusterStatusToClusterStatusResponseBody(v *controlplane.ClusterStatus) *ClusterStatusResponseBody {
	res := &ClusterStatusResponseBody{
		State: v.State,
	}

	return res
}

// marshalControlplaneHostToHostResponseBody builds a value of type
// *HostResponseBody from a value of type *controlplane.Host.
func marshalControlplaneHostToHostResponseBody(v *controlplane.Host) *HostResponseBody {
	res := &HostResponseBody{
		ID:           v.ID,
		Orchestrator: v.Orchestrator,
		Hostname:     v.Hostname,
		Ipv4Address:  v.Ipv4Address,
		Cpus:         v.Cpus,
		Memory:       v.Memory,
	}
	if v.Cohort != nil {
		res.Cohort = marshalControlplaneHostCohortToHostCohortResponseBody(v.Cohort)
	}
	if v.Status != nil {
		res.Status = marshalControlplaneHostStatusToHostStatusResponseBody(v.Status)
	}
	if v.DefaultPgedgeVersion != nil {
		res.DefaultPgedgeVersion = marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(v.DefaultPgedgeVersion)
	}
	if v.SupportedPgedgeVersions != nil {
		res.SupportedPgedgeVersions = make([]*PgEdgeVersionResponseBody, len(v.SupportedPgedgeVersions))
		for i, val := range v.SupportedPgedgeVersions {
			res.SupportedPgedgeVersions[i] = marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(val)
		}
	} else {
		res.SupportedPgedgeVersions = []*PgEdgeVersionResponseBody{}
	}

	return res
}

// marshalControlplaneHostCohortToHostCohortResponseBody builds a value of type
// *HostCohortResponseBody from a value of type *controlplane.HostCohort.
func marshalControlplaneHostCohortToHostCohortResponseBody(v *controlplane.HostCohort) *HostCohortResponseBody {
	if v == nil {
		return nil
	}
	res := &HostCohortResponseBody{
		Type:             v.Type,
		CohortID:         v.CohortID,
		MemberID:         v.MemberID,
		ControlAvailable: v.ControlAvailable,
	}

	return res
}

// marshalControlplaneHostStatusToHostStatusResponseBody builds a value of type
// *HostStatusResponseBody from a value of type *controlplane.HostStatus.
func marshalControlplaneHostStatusToHostStatusResponseBody(v *controlplane.HostStatus) *HostStatusResponseBody {
	res := &HostStatusResponseBody{
		State:     v.State,
		UpdatedAt: v.UpdatedAt,
	}
	if v.Components != nil {
		res.Components = make(map[string]*ComponentStatusResponseBody, len(v.Components))
		for key, val := range v.Components {
			tk := key
			if val == nil {
				res.Components[tk] = nil
				continue
			}
			res.Components[tk] = marshalControlplaneComponentStatusToComponentStatusResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneComponentStatusToComponentStatusResponseBody builds a
// value of type *ComponentStatusResponseBody from a value of type
// *controlplane.ComponentStatus.
func marshalControlplaneComponentStatusToComponentStatusResponseBody(v *controlplane.ComponentStatus) *ComponentStatusResponseBody {
	res := &ComponentStatusResponseBody{
		Healthy: v.Healthy,
		Error:   v.Error,
	}
	if v.Details != nil {
		res.Details = make(map[string]any, len(v.Details))
		for key, val := range v.Details {
			tk := key
			tv := val
			res.Details[tk] = tv
		}
	}

	return res
}

// marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody builds a value
// of type *PgEdgeVersionResponseBody from a value of type
// *controlplane.PgEdgeVersion.
func marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(v *controlplane.PgEdgeVersion) *PgEdgeVersionResponseBody {
	res := &PgEdgeVersionResponseBody{
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
	}

	return res
}

// marshalControlplaneHostToHostResponse builds a value of type *HostResponse
// from a value of type *controlplane.Host.
func marshalControlplaneHostToHostResponse(v *controlplane.Host) *HostResponse {
	res := &HostResponse{
		ID:           v.ID,
		Orchestrator: v.Orchestrator,
		Hostname:     v.Hostname,
		Ipv4Address:  v.Ipv4Address,
		Cpus:         v.Cpus,
		Memory:       v.Memory,
	}
	if v.Cohort != nil {
		res.Cohort = marshalControlplaneHostCohortToHostCohortResponse(v.Cohort)
	}
	if v.Status != nil {
		res.Status = marshalControlplaneHostStatusToHostStatusResponse(v.Status)
	}
	if v.DefaultPgedgeVersion != nil {
		res.DefaultPgedgeVersion = marshalControlplanePgEdgeVersionToPgEdgeVersionResponse(v.DefaultPgedgeVersion)
	}
	if v.SupportedPgedgeVersions != nil {
		res.SupportedPgedgeVersions = make([]*PgEdgeVersionResponse, len(v.SupportedPgedgeVersions))
		for i, val := range v.SupportedPgedgeVersions {
			res.SupportedPgedgeVersions[i] = marshalControlplanePgEdgeVersionToPgEdgeVersionResponse(val)
		}
	} else {
		res.SupportedPgedgeVersions = []*PgEdgeVersionResponse{}
	}

	return res
}

// marshalControlplaneHostCohortToHostCohortResponse builds a value of type
// *HostCohortResponse from a value of type *controlplane.HostCohort.
func marshalControlplaneHostCohortToHostCohortResponse(v *controlplane.HostCohort) *HostCohortResponse {
	if v == nil {
		return nil
	}
	res := &HostCohortResponse{
		Type:             v.Type,
		CohortID:         v.CohortID,
		MemberID:         v.MemberID,
		ControlAvailable: v.ControlAvailable,
	}

	return res
}

// marshalControlplaneHostStatusToHostStatusResponse builds a value of type
// *HostStatusResponse from a value of type *controlplane.HostStatus.
func marshalControlplaneHostStatusToHostStatusResponse(v *controlplane.HostStatus) *HostStatusResponse {
	res := &HostStatusResponse{
		State:     v.State,
		UpdatedAt: v.UpdatedAt,
	}
	if v.Components != nil {
		res.Components = make(map[string]*ComponentStatusResponse, len(v.Components))
		for key, val := range v.Components {
			tk := key
			if val == nil {
				res.Components[tk] = nil
				continue
			}
			res.Components[tk] = marshalControlplaneComponentStatusToComponentStatusResponse(val)
		}
	}

	return res
}

// marshalControlplaneComponentStatusToComponentStatusResponse builds a value
// of type *ComponentStatusResponse from a value of type
// *controlplane.ComponentStatus.
func marshalControlplaneComponentStatusToComponentStatusResponse(v *controlplane.ComponentStatus) *ComponentStatusResponse {
	res := &ComponentStatusResponse{
		Healthy: v.Healthy,
		Error:   v.Error,
	}
	if v.Details != nil {
		res.Details = make(map[string]any, len(v.Details))
		for key, val := range v.Details {
			tk := key
			tv := val
			res.Details[tk] = tv
		}
	}

	return res
}

// marshalControlplanePgEdgeVersionToPgEdgeVersionResponse builds a value of
// type *PgEdgeVersionResponse from a value of type *controlplane.PgEdgeVersion.
func marshalControlplanePgEdgeVersionToPgEdgeVersionResponse(v *controlplane.PgEdgeVersion) *PgEdgeVersionResponse {
	res := &PgEdgeVersionResponse{
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
	}

	return res
}

// marshalControlplaneviewsDatabaseViewToDatabaseResponseAbbreviated builds a
// value of type *DatabaseResponseAbbreviated from a value of type
// *controlplaneviews.DatabaseView.
func marshalControlplaneviewsDatabaseViewToDatabaseResponseAbbreviated(v *controlplaneviews.DatabaseView) *DatabaseResponseAbbreviated {
	res := &DatabaseResponseAbbreviated{
		ID:        *v.ID,
		TenantID:  v.TenantID,
		CreatedAt: *v.CreatedAt,
		UpdatedAt: *v.UpdatedAt,
		State:     *v.State,
	}
	if v.Instances != nil {
		res.Instances = make([]*InstanceResponseAbbreviated, len(v.Instances))
		for i, val := range v.Instances {
			res.Instances[i] = marshalControlplaneviewsInstanceViewToInstanceResponseAbbreviated(val)
		}
	}

	return res
}

// marshalControlplaneviewsInstanceViewToInstanceResponseAbbreviated builds a
// value of type *InstanceResponseAbbreviated from a value of type
// *controlplaneviews.InstanceView.
func marshalControlplaneviewsInstanceViewToInstanceResponseAbbreviated(v *controlplaneviews.InstanceView) *InstanceResponseAbbreviated {
	if v == nil {
		return nil
	}
	res := &InstanceResponseAbbreviated{
		ID:       *v.ID,
		HostID:   *v.HostID,
		NodeName: *v.NodeName,
		State:    *v.State,
	}

	return res
}

// unmarshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec builds a value of
// type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBody.
func unmarshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBody) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       *v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
	for i, val := range v.Nodes {
		res.Nodes[i] = unmarshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*controlplane.ExtraVolumesSpec, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = unmarshalExtraVolumesSpecRequestBodyToControlplaneExtraVolumesSpec(val)
		}
	}

	return res
}

// unmarshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec builds a
// value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBody.
func unmarshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            *v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	res.HostIds = make([]string, len(v.HostIds))
	for i, val := range v.HostIds {
		res.HostIds[i] = val
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*controlplane.ExtraVolumesSpec, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = unmarshalExtraVolumesSpecRequestBodyToControlplaneExtraVolumesSpec(val)
		}
	}

	return res
}

// unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec builds a
// value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBody.
func unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{}
	if v.Provider != nil {
		res.Provider = *v.Provider
	}
	if v.Provider == nil {
		res.Provider = "pgbackrest"
	}
	res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
	for i, val := range v.Repositories {
		res.Repositories[i] = unmarshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(val)
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = unmarshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBody.
func unmarshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBody) *controlplane.BackupRepositorySpec {
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec
// builds a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBody.
func unmarshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// unmarshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec builds
// a value of type *controlplane.RestoreConfigSpec from a value of type
// *RestoreConfigSpecRequestBody.
func unmarshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec(v *RestoreConfigSpecRequestBody) *controlplane.RestoreConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.RestoreConfigSpec{
		SourceDatabaseID:   *v.SourceDatabaseID,
		SourceNodeName:     *v.SourceNodeName,
		SourceDatabaseName: *v.SourceDatabaseName,
	}
	if v.Provider != nil {
		res.Provider = *v.Provider
	}
	if v.Provider == nil {
		res.Provider = "pgbackrest"
	}
	res.Repository = unmarshalRestoreRepositorySpecRequestBodyToControlplaneRestoreRepositorySpec(v.Repository)
	if v.RestoreOptions != nil {
		res.RestoreOptions = make([]string, len(v.RestoreOptions))
		for i, val := range v.RestoreOptions {
			res.RestoreOptions[i] = val
		}
	}

	return res
}

// unmarshalRestoreRepositorySpecRequestBodyToControlplaneRestoreRepositorySpec
// builds a value of type *controlplane.RestoreRepositorySpec from a value of
// type *RestoreRepositorySpecRequestBody.
func unmarshalRestoreRepositorySpecRequestBodyToControlplaneRestoreRepositorySpec(v *RestoreRepositorySpecRequestBody) *controlplane.RestoreRepositorySpec {
	res := &controlplane.RestoreRepositorySpec{
		ID:             v.ID,
		Type:           *v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalExtraVolumesSpecRequestBodyToControlplaneExtraVolumesSpec builds a
// value of type *controlplane.ExtraVolumesSpec from a value of type
// *ExtraVolumesSpecRequestBody.
func unmarshalExtraVolumesSpecRequestBodyToControlplaneExtraVolumesSpec(v *ExtraVolumesSpecRequestBody) *controlplane.ExtraVolumesSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.ExtraVolumesSpec{
		HostPath:        *v.HostPath,
		DestinationPath: *v.DestinationPath,
	}

	return res
}

// unmarshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec builds a
// value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBody.
func unmarshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username: *v.Username,
		Password: *v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneTaskToTaskResponseBody builds a value of type
// *TaskResponseBody from a value of type *controlplane.Task.
func marshalControlplaneTaskToTaskResponseBody(v *controlplane.Task) *TaskResponseBody {
	if v == nil {
		return nil
	}
	res := &TaskResponseBody{
		ParentID:    v.ParentID,
		DatabaseID:  v.DatabaseID,
		NodeName:    v.NodeName,
		InstanceID:  v.InstanceID,
		HostID:      v.HostID,
		TaskID:      v.TaskID,
		CreatedAt:   v.CreatedAt,
		CompletedAt: v.CompletedAt,
		Type:        v.Type,
		Status:      v.Status,
		Error:       v.Error,
	}

	return res
}

// marshalControlplaneDatabaseToDatabaseResponseBody builds a value of type
// *DatabaseResponseBody from a value of type *controlplane.Database.
func marshalControlplaneDatabaseToDatabaseResponseBody(v *controlplane.Database) *DatabaseResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseResponseBody{
		ID:        v.ID,
		TenantID:  v.TenantID,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
		State:     v.State,
	}
	if v.Instances != nil {
		res.Instances = make([]*InstanceResponseBody, len(v.Instances))
		for i, val := range v.Instances {
			res.Instances[i] = marshalControlplaneInstanceToInstanceResponseBody(val)
		}
	}
	if v.Spec != nil {
		res.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody(v.Spec)
	}

	return res
}

// marshalControlplaneInstanceToInstanceResponseBody builds a value of type
// *InstanceResponseBody from a value of type *controlplane.Instance.
func marshalControlplaneInstanceToInstanceResponseBody(v *controlplane.Instance) *InstanceResponseBody {
	if v == nil {
		return nil
	}
	res := &InstanceResponseBody{
		ID:              v.ID,
		HostID:          v.HostID,
		NodeName:        v.NodeName,
		CreatedAt:       v.CreatedAt,
		UpdatedAt:       v.UpdatedAt,
		State:           v.State,
		PatroniState:    v.PatroniState,
		Role:            v.Role,
		ReadOnly:        v.ReadOnly,
		PendingRestart:  v.PendingRestart,
		PatroniPaused:   v.PatroniPaused,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
	}
	if v.Interfaces != nil {
		res.Interfaces = make([]*InstanceInterfaceResponseBody, len(v.Interfaces))
		for i, val := range v.Interfaces {
			res.Interfaces[i] = marshalControlplaneInstanceInterfaceToInstanceInterfaceResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneInstanceInterfaceToInstanceInterfaceResponseBody builds a
// value of type *InstanceInterfaceResponseBody from a value of type
// *controlplane.InstanceInterface.
func marshalControlplaneInstanceInterfaceToInstanceInterfaceResponseBody(v *controlplane.InstanceInterface) *InstanceInterfaceResponseBody {
	if v == nil {
		return nil
	}
	res := &InstanceInterfaceResponseBody{
		NetworkType: v.NetworkType,
		NetworkID:   v.NetworkID,
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody builds a value of
// type *DatabaseSpecResponseBody from a value of type
// *controlplane.DatabaseSpec.
func marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody(v *controlplane.DatabaseSpec) *DatabaseSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecResponseBody{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecResponseBody, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponseBody(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecResponseBody{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecResponseBody, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponseBody(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneRestoreConfigSpecToRestoreConfigSpecResponseBody(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*ExtraVolumesSpecResponseBody, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = marshalControlplaneExtraVolumesSpecToExtraVolumesSpecResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponseBody builds a
// value of type *DatabaseNodeSpecResponseBody from a value of type
// *controlplane.DatabaseNodeSpec.
func marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponseBody(v *controlplane.DatabaseNodeSpec) *DatabaseNodeSpecResponseBody {
	res := &DatabaseNodeSpecResponseBody{
		Name:            v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = val
		}
	} else {
		res.HostIds = []string{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneRestoreConfigSpecToRestoreConfigSpecResponseBody(v.RestoreConfig)
	}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*ExtraVolumesSpecResponseBody, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = marshalControlplaneExtraVolumesSpecToExtraVolumesSpecResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody builds a
// value of type *BackupConfigSpecResponseBody from a value of type
// *controlplane.BackupConfigSpec.
func marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody(v *controlplane.BackupConfigSpec) *BackupConfigSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecResponseBody{
		Provider: v.Provider,
	}
	{
		var zero string
		if res.Provider == zero {
			res.Provider = "pgbackrest"
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecResponseBody, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponseBody(val)
		}
	} else {
		res.Repositories = []*BackupRepositorySpecResponseBody{}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecResponseBody, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponseBody
// builds a value of type *BackupRepositorySpecResponseBody from a value of
// type *controlplane.BackupRepositorySpec.
func marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponseBody(v *controlplane.BackupRepositorySpec) *BackupRepositorySpecResponseBody {
	res := &BackupRepositorySpecResponseBody{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponseBody builds
// a value of type *BackupScheduleSpecResponseBody from a value of type
// *controlplane.BackupScheduleSpec.
func marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponseBody(v *controlplane.BackupScheduleSpec) *BackupScheduleSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecResponseBody{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// marshalControlplaneRestoreConfigSpecToRestoreConfigSpecResponseBody builds a
// value of type *RestoreConfigSpecResponseBody from a value of type
// *controlplane.RestoreConfigSpec.
func marshalControlplaneRestoreConfigSpecToRestoreConfigSpecResponseBody(v *controlplane.RestoreConfigSpec) *RestoreConfigSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &RestoreConfigSpecResponseBody{
		Provider:           v.Provider,
		SourceDatabaseID:   v.SourceDatabaseID,
		SourceNodeName:     v.SourceNodeName,
		SourceDatabaseName: v.SourceDatabaseName,
	}
	{
		var zero string
		if res.Provider == zero {
			res.Provider = "pgbackrest"
		}
	}
	if v.Repository != nil {
		res.Repository = marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecResponseBody(v.Repository)
	}
	if v.RestoreOptions != nil {
		res.RestoreOptions = make([]string, len(v.RestoreOptions))
		for i, val := range v.RestoreOptions {
			res.RestoreOptions[i] = val
		}
	}

	return res
}

// marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecResponseBody
// builds a value of type *RestoreRepositorySpecResponseBody from a value of
// type *controlplane.RestoreRepositorySpec.
func marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecResponseBody(v *controlplane.RestoreRepositorySpec) *RestoreRepositorySpecResponseBody {
	res := &RestoreRepositorySpecResponseBody{
		ID:             v.ID,
		Type:           v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneExtraVolumesSpecToExtraVolumesSpecResponseBody builds a
// value of type *ExtraVolumesSpecResponseBody from a value of type
// *controlplane.ExtraVolumesSpec.
func marshalControlplaneExtraVolumesSpecToExtraVolumesSpecResponseBody(v *controlplane.ExtraVolumesSpec) *ExtraVolumesSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &ExtraVolumesSpecResponseBody{
		HostPath:        v.HostPath,
		DestinationPath: v.DestinationPath,
	}

	return res
}

// marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponseBody builds a
// value of type *DatabaseUserSpecResponseBody from a value of type
// *controlplane.DatabaseUserSpec.
func marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponseBody(v *controlplane.DatabaseUserSpec) *DatabaseUserSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecResponseBody{
		Username: v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneviewsInstanceViewToInstanceResponseBodyAbbreviated builds
// a value of type *InstanceResponseBodyAbbreviated from a value of type
// *controlplaneviews.InstanceView.
func marshalControlplaneviewsInstanceViewToInstanceResponseBodyAbbreviated(v *controlplaneviews.InstanceView) *InstanceResponseBodyAbbreviated {
	if v == nil {
		return nil
	}
	res := &InstanceResponseBodyAbbreviated{
		ID:       *v.ID,
		HostID:   *v.HostID,
		NodeName: *v.NodeName,
		State:    *v.State,
	}

	return res
}

// marshalControlplaneviewsDatabaseSpecViewToDatabaseSpecResponseBody builds a
// value of type *DatabaseSpecResponseBody from a value of type
// *controlplaneviews.DatabaseSpecView.
func marshalControlplaneviewsDatabaseSpecViewToDatabaseSpecResponseBody(v *controlplaneviews.DatabaseSpecView) *DatabaseSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecResponseBody{
		DatabaseName:       *v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecResponseBody, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalControlplaneviewsDatabaseNodeSpecViewToDatabaseNodeSpecResponseBody(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecResponseBody{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecResponseBody, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalControlplaneviewsDatabaseUserSpecViewToDatabaseUserSpecResponseBody(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneviewsBackupConfigSpecViewToBackupConfigSpecResponseBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpecResponseBody(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*ExtraVolumesSpecResponseBody, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = marshalControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpecResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneviewsDatabaseNodeSpecViewToDatabaseNodeSpecResponseBody
// builds a value of type *DatabaseNodeSpecResponseBody from a value of type
// *controlplaneviews.DatabaseNodeSpecView.
func marshalControlplaneviewsDatabaseNodeSpecViewToDatabaseNodeSpecResponseBody(v *controlplaneviews.DatabaseNodeSpecView) *DatabaseNodeSpecResponseBody {
	res := &DatabaseNodeSpecResponseBody{
		Name:            *v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = val
		}
	} else {
		res.HostIds = []string{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneviewsBackupConfigSpecViewToBackupConfigSpecResponseBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpecResponseBody(v.RestoreConfig)
	}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*ExtraVolumesSpecResponseBody, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = marshalControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpecResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneviewsBackupConfigSpecViewToBackupConfigSpecResponseBody
// builds a value of type *BackupConfigSpecResponseBody from a value of type
// *controlplaneviews.BackupConfigSpecView.
func marshalControlplaneviewsBackupConfigSpecViewToBackupConfigSpecResponseBody(v *controlplaneviews.BackupConfigSpecView) *BackupConfigSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecResponseBody{}
	if v.Provider != nil {
		res.Provider = *v.Provider
	}
	if v.Provider == nil {
		res.Provider = "pgbackrest"
	}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecResponseBody, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalControlplaneviewsBackupRepositorySpecViewToBackupRepositorySpecResponseBody(val)
		}
	} else {
		res.Repositories = []*BackupRepositorySpecResponseBody{}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecResponseBody, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalControlplaneviewsBackupScheduleSpecViewToBackupScheduleSpecResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneviewsBackupRepositorySpecViewToBackupRepositorySpecResponseBody
// builds a value of type *BackupRepositorySpecResponseBody from a value of
// type *controlplaneviews.BackupRepositorySpecView.
func marshalControlplaneviewsBackupRepositorySpecViewToBackupRepositorySpecResponseBody(v *controlplaneviews.BackupRepositorySpecView) *BackupRepositorySpecResponseBody {
	res := &BackupRepositorySpecResponseBody{
		ID:                v.ID,
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneviewsBackupScheduleSpecViewToBackupScheduleSpecResponseBody
// builds a value of type *BackupScheduleSpecResponseBody from a value of type
// *controlplaneviews.BackupScheduleSpecView.
func marshalControlplaneviewsBackupScheduleSpecViewToBackupScheduleSpecResponseBody(v *controlplaneviews.BackupScheduleSpecView) *BackupScheduleSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecResponseBody{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// marshalControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpecResponseBody
// builds a value of type *RestoreConfigSpecResponseBody from a value of type
// *controlplaneviews.RestoreConfigSpecView.
func marshalControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpecResponseBody(v *controlplaneviews.RestoreConfigSpecView) *RestoreConfigSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &RestoreConfigSpecResponseBody{
		SourceDatabaseID:   *v.SourceDatabaseID,
		SourceNodeName:     *v.SourceNodeName,
		SourceDatabaseName: *v.SourceDatabaseName,
	}
	if v.Provider != nil {
		res.Provider = *v.Provider
	}
	if v.Provider == nil {
		res.Provider = "pgbackrest"
	}
	if v.Repository != nil {
		res.Repository = marshalControlplaneviewsRestoreRepositorySpecViewToRestoreRepositorySpecResponseBody(v.Repository)
	}
	if v.RestoreOptions != nil {
		res.RestoreOptions = make([]string, len(v.RestoreOptions))
		for i, val := range v.RestoreOptions {
			res.RestoreOptions[i] = val
		}
	}

	return res
}

// marshalControlplaneviewsRestoreRepositorySpecViewToRestoreRepositorySpecResponseBody
// builds a value of type *RestoreRepositorySpecResponseBody from a value of
// type *controlplaneviews.RestoreRepositorySpecView.
func marshalControlplaneviewsRestoreRepositorySpecViewToRestoreRepositorySpecResponseBody(v *controlplaneviews.RestoreRepositorySpecView) *RestoreRepositorySpecResponseBody {
	res := &RestoreRepositorySpecResponseBody{
		ID:             v.ID,
		Type:           *v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpecResponseBody
// builds a value of type *ExtraVolumesSpecResponseBody from a value of type
// *controlplaneviews.ExtraVolumesSpecView.
func marshalControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpecResponseBody(v *controlplaneviews.ExtraVolumesSpecView) *ExtraVolumesSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &ExtraVolumesSpecResponseBody{
		HostPath:        *v.HostPath,
		DestinationPath: *v.DestinationPath,
	}

	return res
}

// marshalControlplaneviewsDatabaseUserSpecViewToDatabaseUserSpecResponseBody
// builds a value of type *DatabaseUserSpecResponseBody from a value of type
// *controlplaneviews.DatabaseUserSpecView.
func marshalControlplaneviewsDatabaseUserSpecViewToDatabaseUserSpecResponseBody(v *controlplaneviews.DatabaseUserSpecView) *DatabaseUserSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecResponseBody{
		Username: *v.Username,
		Password: *v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// unmarshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec builds
// a value of type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBodyRequestBody.
func unmarshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBodyRequestBody) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       *v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
	for i, val := range v.Nodes {
		res.Nodes[i] = unmarshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*controlplane.ExtraVolumesSpec, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = unmarshalExtraVolumesSpecRequestBodyRequestBodyToControlplaneExtraVolumesSpec(val)
		}
	}

	return res
}

// unmarshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec
// builds a value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBodyRequestBody.
func unmarshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBodyRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            *v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	res.HostIds = make([]string, len(v.HostIds))
	for i, val := range v.HostIds {
		res.HostIds[i] = val
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*controlplane.ExtraVolumesSpec, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = unmarshalExtraVolumesSpecRequestBodyRequestBodyToControlplaneExtraVolumesSpec(val)
		}
	}

	return res
}

// unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec
// builds a value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBodyRequestBody.
func unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBodyRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{}
	if v.Provider != nil {
		res.Provider = *v.Provider
	}
	if v.Provider == nil {
		res.Provider = "pgbackrest"
	}
	res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
	for i, val := range v.Repositories {
		res.Repositories[i] = unmarshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(val)
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = unmarshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBodyRequestBody.
func unmarshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBodyRequestBody) *controlplane.BackupRepositorySpec {
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec
// builds a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBodyRequestBody.
func unmarshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBodyRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// unmarshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec
// builds a value of type *controlplane.RestoreConfigSpec from a value of type
// *RestoreConfigSpecRequestBodyRequestBody.
func unmarshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec(v *RestoreConfigSpecRequestBodyRequestBody) *controlplane.RestoreConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.RestoreConfigSpec{
		SourceDatabaseID:   *v.SourceDatabaseID,
		SourceNodeName:     *v.SourceNodeName,
		SourceDatabaseName: *v.SourceDatabaseName,
	}
	if v.Provider != nil {
		res.Provider = *v.Provider
	}
	if v.Provider == nil {
		res.Provider = "pgbackrest"
	}
	res.Repository = unmarshalRestoreRepositorySpecRequestBodyRequestBodyToControlplaneRestoreRepositorySpec(v.Repository)
	if v.RestoreOptions != nil {
		res.RestoreOptions = make([]string, len(v.RestoreOptions))
		for i, val := range v.RestoreOptions {
			res.RestoreOptions[i] = val
		}
	}

	return res
}

// unmarshalRestoreRepositorySpecRequestBodyRequestBodyToControlplaneRestoreRepositorySpec
// builds a value of type *controlplane.RestoreRepositorySpec from a value of
// type *RestoreRepositorySpecRequestBodyRequestBody.
func unmarshalRestoreRepositorySpecRequestBodyRequestBodyToControlplaneRestoreRepositorySpec(v *RestoreRepositorySpecRequestBodyRequestBody) *controlplane.RestoreRepositorySpec {
	res := &controlplane.RestoreRepositorySpec{
		ID:             v.ID,
		Type:           *v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalExtraVolumesSpecRequestBodyRequestBodyToControlplaneExtraVolumesSpec
// builds a value of type *controlplane.ExtraVolumesSpec from a value of type
// *ExtraVolumesSpecRequestBodyRequestBody.
func unmarshalExtraVolumesSpecRequestBodyRequestBodyToControlplaneExtraVolumesSpec(v *ExtraVolumesSpecRequestBodyRequestBody) *controlplane.ExtraVolumesSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.ExtraVolumesSpec{
		HostPath:        *v.HostPath,
		DestinationPath: *v.DestinationPath,
	}

	return res
}

// unmarshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec
// builds a value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBodyRequestBody.
func unmarshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBodyRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username: *v.Username,
		Password: *v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneTaskToTaskResponse builds a value of type *TaskResponse
// from a value of type *controlplane.Task.
func marshalControlplaneTaskToTaskResponse(v *controlplane.Task) *TaskResponse {
	res := &TaskResponse{
		ParentID:    v.ParentID,
		DatabaseID:  v.DatabaseID,
		NodeName:    v.NodeName,
		InstanceID:  v.InstanceID,
		HostID:      v.HostID,
		TaskID:      v.TaskID,
		CreatedAt:   v.CreatedAt,
		CompletedAt: v.CompletedAt,
		Type:        v.Type,
		Status:      v.Status,
		Error:       v.Error,
	}

	return res
}
