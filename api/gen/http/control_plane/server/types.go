// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane HTTP server types
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/design

package server

import (
	controlplane "github.com/pgEdge/control-plane/api/gen/control_plane"
	controlplaneviews "github.com/pgEdge/control-plane/api/gen/control_plane/views"
	goa "goa.design/goa/v3/pkg"
)

// JoinClusterRequestBody is the type of the "control-plane" service
// "join-cluster" endpoint HTTP request body.
type JoinClusterRequestBody struct {
	// Token to join an existing cluster.
	Token *string `form:"token,omitempty" json:"token,omitempty" xml:"token,omitempty"`
	// Existing server to join
	ServerURL *string `form:"server_url,omitempty" json:"server_url,omitempty" xml:"server_url,omitempty"`
}

// GetJoinOptionsRequestBody is the type of the "control-plane" service
// "get-join-options" endpoint HTTP request body.
type GetJoinOptionsRequestBody struct {
	// Token to join the cluster.
	Token *string `form:"token,omitempty" json:"token,omitempty" xml:"token,omitempty"`
	// The unique identifier for the host that's joining the cluster.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The hostname of the host that's joining the cluster.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of the host that's joining the cluster.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
}

// CreateDatabaseRequestBody is the type of the "control-plane" service
// "create-database" endpoint HTTP request body.
type CreateDatabaseRequestBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The specification for the database.
	Spec *DatabaseSpecRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseRequestBody is the type of the "control-plane" service
// "update-database" endpoint HTTP request body.
type UpdateDatabaseRequestBody struct {
	// The specification for the database.
	Spec *DatabaseSpecRequestBodyRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InitClusterResponseBody is the type of the "control-plane" service
// "init-cluster" endpoint HTTP response body.
type InitClusterResponseBody struct {
	// Token to join an existing cluster.
	Token string `form:"token" json:"token" xml:"token"`
	// Existing server to join
	ServerURL string `form:"server_url" json:"server_url" xml:"server_url"`
}

// GetJoinTokenResponseBody is the type of the "control-plane" service
// "get-join-token" endpoint HTTP response body.
type GetJoinTokenResponseBody struct {
	// Token to join an existing cluster.
	Token string `form:"token" json:"token" xml:"token"`
	// Existing server to join
	ServerURL string `form:"server_url" json:"server_url" xml:"server_url"`
}

// GetJoinOptionsResponseBody is the type of the "control-plane" service
// "get-join-options" endpoint HTTP response body.
type GetJoinOptionsResponseBody struct {
	// Information about this cluster member
	Peer *ClusterPeerResponseBody `form:"peer" json:"peer" xml:"peer"`
	// Credentials for the new host joining the cluster.
	Credentials *ClusterCredentialsResponseBody `form:"credentials,omitempty" json:"credentials,omitempty" xml:"credentials,omitempty"`
}

// InspectClusterResponseBody is the type of the "control-plane" service
// "inspect-cluster" endpoint HTTP response body.
type InspectClusterResponseBody struct {
	// Unique identifier for the cluster.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the cluster's owner.
	TenantID string `form:"tenant_id" json:"tenant_id" xml:"tenant_id"`
	// Current status of the cluster.
	Status *ClusterStatusResponseBody `form:"status" json:"status" xml:"status"`
	// All of the hosts in the cluster.
	Hosts []*HostResponseBody `form:"hosts" json:"hosts" xml:"hosts"`
}

// ListHostsResponseBody is the type of the "control-plane" service
// "list-hosts" endpoint HTTP response body.
type ListHostsResponseBody []*HostResponse

// InspectHostResponseBody is the type of the "control-plane" service
// "inspect-host" endpoint HTTP response body.
type InspectHostResponseBody struct {
	// Unique identifier for the host.
	ID string `form:"id" json:"id" xml:"id"`
	// The orchestrator used by this host.
	Orchestrator string `form:"orchestrator" json:"orchestrator" xml:"orchestrator"`
	// The cohort that this host belongs to/
	Cohort *HostCohortResponseBody `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of this host.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
	// The number of CPUs on this host.
	Cpus int `form:"cpus" json:"cpus" xml:"cpus"`
	// The amount of memory available on this host.
	Memory string `form:"memory" json:"memory" xml:"memory"`
	// Current status of the host.
	Status *HostStatusResponseBody `form:"status" json:"status" xml:"status"`
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersionResponseBody `form:"default_pgedge_version" json:"default_pgedge_version" xml:"default_pgedge_version"`
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersionResponseBody `form:"supported_pgedge_versions" json:"supported_pgedge_versions" xml:"supported_pgedge_versions"`
}

// DatabaseResponseAbbreviatedCollection is the type of the "control-plane"
// service "list-databases" endpoint HTTP response body.
type DatabaseResponseAbbreviatedCollection []*DatabaseResponseAbbreviated

// CreateDatabaseResponseBody is the type of the "control-plane" service
// "create-database" endpoint HTTP response body.
type CreateDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time that the database was last updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// Current state of the database.
	State string `form:"state" json:"state" xml:"state"`
	// All of the instances in the database.
	Instances InstanceResponseBodyAbbreviatedCollection `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InspectDatabaseResponseBody is the type of the "control-plane" service
// "inspect-database" endpoint HTTP response body.
type InspectDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time that the database was last updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// Current state of the database.
	State string `form:"state" json:"state" xml:"state"`
	// All of the instances in the database.
	Instances InstanceResponseBodyAbbreviatedCollection `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseResponseBody is the type of the "control-plane" service
// "update-database" endpoint HTTP response body.
type UpdateDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time that the database was last updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// Current state of the database.
	State string `form:"state" json:"state" xml:"state"`
	// All of the instances in the database.
	Instances InstanceResponseBodyAbbreviatedCollection `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InitClusterClusterAlreadyInitializedResponseBody is the type of the
// "control-plane" service "init-cluster" endpoint HTTP response body for the
// "cluster_already_initialized" error.
type InitClusterClusterAlreadyInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// JoinClusterClusterAlreadyInitializedResponseBody is the type of the
// "control-plane" service "join-cluster" endpoint HTTP response body for the
// "cluster_already_initialized" error.
type JoinClusterClusterAlreadyInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetJoinTokenClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-join-token" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type GetJoinTokenClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetJoinOptionsClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-join-options" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type GetJoinOptionsClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetJoinOptionsInvalidJoinTokenResponseBody is the type of the
// "control-plane" service "get-join-options" endpoint HTTP response body for
// the "invalid_join_token" error.
type GetJoinOptionsInvalidJoinTokenResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// InspectClusterClusterNotInitializedResponseBody is the type of the
// "control-plane" service "inspect-cluster" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type InspectClusterClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// ListHostsClusterNotInitializedResponseBody is the type of the
// "control-plane" service "list-hosts" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type ListHostsClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// InspectHostClusterNotInitializedResponseBody is the type of the
// "control-plane" service "inspect-host" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type InspectHostClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// RemoveHostClusterNotInitializedResponseBody is the type of the
// "control-plane" service "remove-host" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type RemoveHostClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// ListDatabasesClusterNotInitializedResponseBody is the type of the
// "control-plane" service "list-databases" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type ListDatabasesClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// CreateDatabaseDatabaseAlreadyExistsResponseBody is the type of the
// "control-plane" service "create-database" endpoint HTTP response body for
// the "database_already_exists" error.
type CreateDatabaseDatabaseAlreadyExistsResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// CreateDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "create-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type CreateDatabaseClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// CreateDatabaseInvalidInputResponseBody is the type of the "control-plane"
// service "create-database" endpoint HTTP response body for the
// "invalid_input" error.
type CreateDatabaseInvalidInputResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// InspectDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "inspect-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type InspectDatabaseClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// UpdateDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "update-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type UpdateDatabaseClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// DeleteDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "delete-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type DeleteDatabaseClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// ClusterPeerResponseBody is used to define fields on response body types.
type ClusterPeerResponseBody struct {
	// The name of the cluster member.
	Name string `form:"name" json:"name" xml:"name"`
	// The Etcd peer endpoint for this cluster member.
	PeerURL string `form:"peer_url" json:"peer_url" xml:"peer_url"`
	// The Etcd client endpoint for this cluster member.
	ClientURL string `form:"client_url" json:"client_url" xml:"client_url"`
}

// ClusterCredentialsResponseBody is used to define fields on response body
// types.
type ClusterCredentialsResponseBody struct {
	// The base64-encoded CA certificate for the cluster.
	CaCert string `form:"ca_cert" json:"ca_cert" xml:"ca_cert"`
	// The base64-encoded etcd client certificate for the new cluster member.
	ClientCert string `form:"client_cert" json:"client_cert" xml:"client_cert"`
	// The base64-encoded etcd client key for the new cluster member.
	ClientKey string `form:"client_key" json:"client_key" xml:"client_key"`
	// The base64-encoded etcd server certificate for the new cluster member.
	ServerCert string `form:"server_cert" json:"server_cert" xml:"server_cert"`
	// The base64-encoded etcd server key for the new cluster member.
	ServerKey string `form:"server_key" json:"server_key" xml:"server_key"`
}

// ClusterStatusResponseBody is used to define fields on response body types.
type ClusterStatusResponseBody struct {
	// The current state of the cluster.
	State string `form:"state" json:"state" xml:"state"`
}

// HostResponseBody is used to define fields on response body types.
type HostResponseBody struct {
	// Unique identifier for the host.
	ID string `form:"id" json:"id" xml:"id"`
	// The orchestrator used by this host.
	Orchestrator string `form:"orchestrator" json:"orchestrator" xml:"orchestrator"`
	// The cohort that this host belongs to/
	Cohort *HostCohortResponseBody `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of this host.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
	// The number of CPUs on this host.
	Cpus int `form:"cpus" json:"cpus" xml:"cpus"`
	// The amount of memory available on this host.
	Memory string `form:"memory" json:"memory" xml:"memory"`
	// Current status of the host.
	Status *HostStatusResponseBody `form:"status" json:"status" xml:"status"`
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersionResponseBody `form:"default_pgedge_version" json:"default_pgedge_version" xml:"default_pgedge_version"`
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersionResponseBody `form:"supported_pgedge_versions" json:"supported_pgedge_versions" xml:"supported_pgedge_versions"`
}

// HostCohortResponseBody is used to define fields on response body types.
type HostCohortResponseBody struct {
	// The type of cohort that the host belongs to.
	Type string `form:"type" json:"type" xml:"type"`
	// The cohort ID that the host belongs to.
	CohortID string `form:"cohort_id" json:"cohort_id" xml:"cohort_id"`
	// The member ID of the host within the cohort.
	MemberID string `form:"member_id" json:"member_id" xml:"member_id"`
	// Indicates if the host is a control node in the cohort.
	ControlAvailable bool `form:"control_available" json:"control_available" xml:"control_available"`
}

// HostStatusResponseBody is used to define fields on response body types.
type HostStatusResponseBody struct {
	State string `form:"state" json:"state" xml:"state"`
	// The last time the host status was updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// The status of each component of the host.
	Components map[string]*ComponentStatusResponseBody `form:"components" json:"components" xml:"components"`
}

// ComponentStatusResponseBody is used to define fields on response body types.
type ComponentStatusResponseBody struct {
	// Indicates if the component is healthy.
	Healthy *bool `form:"healthy,omitempty" json:"healthy,omitempty" xml:"healthy,omitempty"`
	// Error message from any errors that occurred during the health check.
	Error string `form:"error" json:"error" xml:"error"`
	// Additional details about the component.
	Details map[string]any `form:"details" json:"details" xml:"details"`
}

// PgEdgeVersionResponseBody is used to define fields on response body types.
type PgEdgeVersionResponseBody struct {
	// The Postgres major version.
	PostgresVersion string `form:"postgres_version" json:"postgres_version" xml:"postgres_version"`
	// The Spock major version.
	SpockVersion string `form:"spock_version" json:"spock_version" xml:"spock_version"`
}

// HostResponse is used to define fields on response body types.
type HostResponse struct {
	// Unique identifier for the host.
	ID string `form:"id" json:"id" xml:"id"`
	// The orchestrator used by this host.
	Orchestrator string `form:"orchestrator" json:"orchestrator" xml:"orchestrator"`
	// The cohort that this host belongs to/
	Cohort *HostCohortResponse `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of this host.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
	// The number of CPUs on this host.
	Cpus int `form:"cpus" json:"cpus" xml:"cpus"`
	// The amount of memory available on this host.
	Memory string `form:"memory" json:"memory" xml:"memory"`
	// Current status of the host.
	Status *HostStatusResponse `form:"status" json:"status" xml:"status"`
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersionResponse `form:"default_pgedge_version" json:"default_pgedge_version" xml:"default_pgedge_version"`
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersionResponse `form:"supported_pgedge_versions" json:"supported_pgedge_versions" xml:"supported_pgedge_versions"`
}

// HostCohortResponse is used to define fields on response body types.
type HostCohortResponse struct {
	// The type of cohort that the host belongs to.
	Type string `form:"type" json:"type" xml:"type"`
	// The cohort ID that the host belongs to.
	CohortID string `form:"cohort_id" json:"cohort_id" xml:"cohort_id"`
	// The member ID of the host within the cohort.
	MemberID string `form:"member_id" json:"member_id" xml:"member_id"`
	// Indicates if the host is a control node in the cohort.
	ControlAvailable bool `form:"control_available" json:"control_available" xml:"control_available"`
}

// HostStatusResponse is used to define fields on response body types.
type HostStatusResponse struct {
	State string `form:"state" json:"state" xml:"state"`
	// The last time the host status was updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// The status of each component of the host.
	Components map[string]*ComponentStatusResponse `form:"components" json:"components" xml:"components"`
}

// ComponentStatusResponse is used to define fields on response body types.
type ComponentStatusResponse struct {
	// Indicates if the component is healthy.
	Healthy *bool `form:"healthy,omitempty" json:"healthy,omitempty" xml:"healthy,omitempty"`
	// Error message from any errors that occurred during the health check.
	Error string `form:"error" json:"error" xml:"error"`
	// Additional details about the component.
	Details map[string]any `form:"details" json:"details" xml:"details"`
}

// PgEdgeVersionResponse is used to define fields on response body types.
type PgEdgeVersionResponse struct {
	// The Postgres major version.
	PostgresVersion string `form:"postgres_version" json:"postgres_version" xml:"postgres_version"`
	// The Spock major version.
	SpockVersion string `form:"spock_version" json:"spock_version" xml:"spock_version"`
}

// DatabaseResponseAbbreviated is used to define fields on response body types.
type DatabaseResponseAbbreviated struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time that the database was last updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// Current state of the database.
	State string `form:"state" json:"state" xml:"state"`
	// All of the instances in the database.
	Instances InstanceResponseAbbreviatedCollection `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
}

// InstanceResponseAbbreviatedCollection is used to define fields on response
// body types.
type InstanceResponseAbbreviatedCollection []*InstanceResponseAbbreviated

// InstanceResponseAbbreviated is used to define fields on response body types.
type InstanceResponseAbbreviated struct {
	// Unique identifier for the instance.
	ID string `form:"id" json:"id" xml:"id"`
	// The ID of the host this instance is running on.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
	// The Spock node name for this instance.
	NodeName string `form:"node_name" json:"node_name" xml:"node_name"`
	State    string `form:"state" json:"state" xml:"state"`
}

// InstanceResponseBodyAbbreviatedCollection is used to define fields on
// response body types.
type InstanceResponseBodyAbbreviatedCollection []*InstanceResponseBodyAbbreviated

// InstanceResponseBodyAbbreviated is used to define fields on response body
// types.
type InstanceResponseBodyAbbreviated struct {
	// Unique identifier for the instance.
	ID string `form:"id" json:"id" xml:"id"`
	// The ID of the host this instance is running on.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
	// The Spock node name for this instance.
	NodeName string `form:"node_name" json:"node_name" xml:"node_name"`
	State    string `form:"state" json:"state" xml:"state"`
}

// DatabaseSpecResponseBody is used to define fields on response body types.
type DatabaseSpecResponseBody struct {
	// The name of the Postgres database.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The storage class to use for the database. The possible values and defaults
	// depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage in SI or IEC notation. Support for this value
	// depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will be
	// enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit will be enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecResponseBody `form:"nodes" json:"nodes" xml:"nodes"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecResponseBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecResponseBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecResponseBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecResponseBody is used to define fields on response body types.
type DatabaseNodeSpecResponseBody struct {
	// The name of the database node.
	Name string `form:"name" json:"name" xml:"name"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary and the others will be read
	// replicas.
	HostIds []string `form:"host_ids" json:"host_ids" xml:"host_ids"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The storage class to use for the database on this node. The possible values
	// and defaults depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage for this node in SI or IEC notation. Support for
	// this value depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. Defaults to the number of available CPUs on the host. Can
	// include an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will
	// be enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit will be enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecResponseBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
}

// BackupConfigSpecResponseBody is used to define fields on response body types.
type BackupConfigSpecResponseBody struct {
	// The backup provider for this backup configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecResponseBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecResponseBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecResponseBody is used to define fields on response body
// types.
type BackupRepositorySpecResponseBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecResponseBody is used to define fields on response body
// types.
type BackupScheduleSpecResponseBody struct {
	// The unique identifier for this backup schedule.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of backup to take on this schedule.
	Type string `form:"type" json:"type" xml:"type"`
	// The cron expression for this schedule.
	CronExpression string `form:"cron_expression" json:"cron_expression" xml:"cron_expression"`
}

// DatabaseUserSpecResponseBody is used to define fields on response body types.
type DatabaseUserSpecResponseBody struct {
	// The username for this database user.
	Username string `form:"username" json:"username" xml:"username"`
	// The password for this database user.
	Password string `form:"password" json:"password" xml:"password"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// RestoreConfigSpecResponseBody is used to define fields on response body
// types.
type RestoreConfigSpecResponseBody struct {
	// The backup provider for this restore configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The name of the node to restore this database from.
	NodeName string `form:"node_name" json:"node_name" xml:"node_name"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecResponseBody `form:"repository" json:"repository" xml:"repository"`
}

// RestoreRepositorySpecResponseBody is used to define fields on response body
// types.
type RestoreRepositorySpecResponseBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The base path within the repository where backups are stored.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// DatabaseSpecRequestBody is used to define fields on request body types.
type DatabaseSpecRequestBody struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The storage class to use for the database. The possible values and defaults
	// depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage in SI or IEC notation. Support for this value
	// depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will be
	// enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit will be enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecRequestBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecRequestBody is used to define fields on request body types.
type DatabaseNodeSpecRequestBody struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary and the others will be read
	// replicas.
	HostIds []string `form:"host_ids,omitempty" json:"host_ids,omitempty" xml:"host_ids,omitempty"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The storage class to use for the database on this node. The possible values
	// and defaults depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage for this node in SI or IEC notation. Support for
	// this value depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. Defaults to the number of available CPUs on the host. Can
	// include an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will
	// be enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit will be enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
}

// BackupConfigSpecRequestBody is used to define fields on request body types.
type BackupConfigSpecRequestBody struct {
	// The backup provider for this backup configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBody is used to define fields on request body
// types.
type BackupRepositorySpecRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecRequestBody is used to define fields on request body types.
type BackupScheduleSpecRequestBody struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// DatabaseUserSpecRequestBody is used to define fields on request body types.
type DatabaseUserSpecRequestBody struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// RestoreConfigSpecRequestBody is used to define fields on request body types.
type RestoreConfigSpecRequestBody struct {
	// The backup provider for this restore configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The name of the node to restore this database from.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecRequestBody `form:"repository,omitempty" json:"repository,omitempty" xml:"repository,omitempty"`
}

// RestoreRepositorySpecRequestBody is used to define fields on request body
// types.
type RestoreRepositorySpecRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The base path within the repository where backups are stored.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// DatabaseSpecRequestBodyRequestBody is used to define fields on request body
// types.
type DatabaseSpecRequestBodyRequestBody struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The storage class to use for the database. The possible values and defaults
	// depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage in SI or IEC notation. Support for this value
	// depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will be
	// enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit will be enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBodyRequestBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBodyRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecRequestBodyRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecRequestBodyRequestBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseNodeSpecRequestBodyRequestBody struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary and the others will be read
	// replicas.
	HostIds []string `form:"host_ids,omitempty" json:"host_ids,omitempty" xml:"host_ids,omitempty"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The storage class to use for the database on this node. The possible values
	// and defaults depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage for this node in SI or IEC notation. Support for
	// this value depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. Defaults to the number of available CPUs on the host. Can
	// include an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will
	// be enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit will be enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecRequestBodyRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
}

// BackupConfigSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupConfigSpecRequestBodyRequestBody struct {
	// The backup provider for this backup configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBodyRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBodyRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBodyRequestBody is used to define fields on
// request body types.
type BackupRepositorySpecRequestBodyRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupScheduleSpecRequestBodyRequestBody struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// DatabaseUserSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseUserSpecRequestBodyRequestBody struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// RestoreConfigSpecRequestBodyRequestBody is used to define fields on request
// body types.
type RestoreConfigSpecRequestBodyRequestBody struct {
	// The backup provider for this restore configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The name of the node to restore this database from.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecRequestBodyRequestBody `form:"repository,omitempty" json:"repository,omitempty" xml:"repository,omitempty"`
}

// RestoreRepositorySpecRequestBodyRequestBody is used to define fields on
// request body types.
type RestoreRepositorySpecRequestBodyRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The base path within the repository where backups are stored.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// NewInitClusterResponseBody builds the HTTP response body from the result of
// the "init-cluster" endpoint of the "control-plane" service.
func NewInitClusterResponseBody(res *controlplane.ClusterJoinToken) *InitClusterResponseBody {
	body := &InitClusterResponseBody{
		Token:     res.Token,
		ServerURL: res.ServerURL,
	}
	return body
}

// NewGetJoinTokenResponseBody builds the HTTP response body from the result of
// the "get-join-token" endpoint of the "control-plane" service.
func NewGetJoinTokenResponseBody(res *controlplane.ClusterJoinToken) *GetJoinTokenResponseBody {
	body := &GetJoinTokenResponseBody{
		Token:     res.Token,
		ServerURL: res.ServerURL,
	}
	return body
}

// NewGetJoinOptionsResponseBody builds the HTTP response body from the result
// of the "get-join-options" endpoint of the "control-plane" service.
func NewGetJoinOptionsResponseBody(res *controlplane.ClusterJoinOptions) *GetJoinOptionsResponseBody {
	body := &GetJoinOptionsResponseBody{}
	if res.Peer != nil {
		body.Peer = marshalControlplaneClusterPeerToClusterPeerResponseBody(res.Peer)
	}
	if res.Credentials != nil {
		body.Credentials = marshalControlplaneClusterCredentialsToClusterCredentialsResponseBody(res.Credentials)
	}
	return body
}

// NewInspectClusterResponseBody builds the HTTP response body from the result
// of the "inspect-cluster" endpoint of the "control-plane" service.
func NewInspectClusterResponseBody(res *controlplane.Cluster) *InspectClusterResponseBody {
	body := &InspectClusterResponseBody{
		ID:       res.ID,
		TenantID: res.TenantID,
	}
	if res.Status != nil {
		body.Status = marshalControlplaneClusterStatusToClusterStatusResponseBody(res.Status)
	}
	if res.Hosts != nil {
		body.Hosts = make([]*HostResponseBody, len(res.Hosts))
		for i, val := range res.Hosts {
			body.Hosts[i] = marshalControlplaneHostToHostResponseBody(val)
		}
	} else {
		body.Hosts = []*HostResponseBody{}
	}
	return body
}

// NewListHostsResponseBody builds the HTTP response body from the result of
// the "list-hosts" endpoint of the "control-plane" service.
func NewListHostsResponseBody(res []*controlplane.Host) ListHostsResponseBody {
	body := make([]*HostResponse, len(res))
	for i, val := range res {
		body[i] = marshalControlplaneHostToHostResponse(val)
	}
	return body
}

// NewInspectHostResponseBody builds the HTTP response body from the result of
// the "inspect-host" endpoint of the "control-plane" service.
func NewInspectHostResponseBody(res *controlplane.Host) *InspectHostResponseBody {
	body := &InspectHostResponseBody{
		ID:           res.ID,
		Orchestrator: res.Orchestrator,
		Hostname:     res.Hostname,
		Ipv4Address:  res.Ipv4Address,
		Cpus:         res.Cpus,
		Memory:       res.Memory,
	}
	if res.Cohort != nil {
		body.Cohort = marshalControlplaneHostCohortToHostCohortResponseBody(res.Cohort)
	}
	if res.Status != nil {
		body.Status = marshalControlplaneHostStatusToHostStatusResponseBody(res.Status)
	}
	if res.DefaultPgedgeVersion != nil {
		body.DefaultPgedgeVersion = marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(res.DefaultPgedgeVersion)
	}
	if res.SupportedPgedgeVersions != nil {
		body.SupportedPgedgeVersions = make([]*PgEdgeVersionResponseBody, len(res.SupportedPgedgeVersions))
		for i, val := range res.SupportedPgedgeVersions {
			body.SupportedPgedgeVersions[i] = marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(val)
		}
	} else {
		body.SupportedPgedgeVersions = []*PgEdgeVersionResponseBody{}
	}
	return body
}

// NewDatabaseResponseAbbreviatedCollection builds the HTTP response body from
// the result of the "list-databases" endpoint of the "control-plane" service.
func NewDatabaseResponseAbbreviatedCollection(res controlplaneviews.DatabaseCollectionView) DatabaseResponseAbbreviatedCollection {
	body := make([]*DatabaseResponseAbbreviated, len(res))
	for i, val := range res {
		body[i] = marshalControlplaneviewsDatabaseViewToDatabaseResponseAbbreviated(val)
	}
	return body
}

// NewCreateDatabaseResponseBody builds the HTTP response body from the result
// of the "create-database" endpoint of the "control-plane" service.
func NewCreateDatabaseResponseBody(res *controlplaneviews.DatabaseView) *CreateDatabaseResponseBody {
	body := &CreateDatabaseResponseBody{
		ID:        *res.ID,
		TenantID:  res.TenantID,
		CreatedAt: *res.CreatedAt,
		UpdatedAt: *res.UpdatedAt,
		State:     *res.State,
	}
	if res.Instances != nil {
		body.Instances = make([]*InstanceResponseBodyAbbreviated, len(res.Instances))
		for i, val := range res.Instances {
			body.Instances[i] = marshalControlplaneviewsInstanceViewToInstanceResponseBodyAbbreviated(val)
		}
	}
	if res.Spec != nil {
		body.Spec = marshalControlplaneviewsDatabaseSpecViewToDatabaseSpecResponseBody(res.Spec)
	}
	return body
}

// NewInspectDatabaseResponseBody builds the HTTP response body from the result
// of the "inspect-database" endpoint of the "control-plane" service.
func NewInspectDatabaseResponseBody(res *controlplaneviews.DatabaseView) *InspectDatabaseResponseBody {
	body := &InspectDatabaseResponseBody{
		ID:        *res.ID,
		TenantID:  res.TenantID,
		CreatedAt: *res.CreatedAt,
		UpdatedAt: *res.UpdatedAt,
		State:     *res.State,
	}
	if res.Instances != nil {
		body.Instances = make([]*InstanceResponseBodyAbbreviated, len(res.Instances))
		for i, val := range res.Instances {
			body.Instances[i] = marshalControlplaneviewsInstanceViewToInstanceResponseBodyAbbreviated(val)
		}
	}
	if res.Spec != nil {
		body.Spec = marshalControlplaneviewsDatabaseSpecViewToDatabaseSpecResponseBody(res.Spec)
	}
	return body
}

// NewUpdateDatabaseResponseBody builds the HTTP response body from the result
// of the "update-database" endpoint of the "control-plane" service.
func NewUpdateDatabaseResponseBody(res *controlplaneviews.DatabaseView) *UpdateDatabaseResponseBody {
	body := &UpdateDatabaseResponseBody{
		ID:        *res.ID,
		TenantID:  res.TenantID,
		CreatedAt: *res.CreatedAt,
		UpdatedAt: *res.UpdatedAt,
		State:     *res.State,
	}
	if res.Instances != nil {
		body.Instances = make([]*InstanceResponseBodyAbbreviated, len(res.Instances))
		for i, val := range res.Instances {
			body.Instances[i] = marshalControlplaneviewsInstanceViewToInstanceResponseBodyAbbreviated(val)
		}
	}
	if res.Spec != nil {
		body.Spec = marshalControlplaneviewsDatabaseSpecViewToDatabaseSpecResponseBody(res.Spec)
	}
	return body
}

// NewInitClusterClusterAlreadyInitializedResponseBody builds the HTTP response
// body from the result of the "init-cluster" endpoint of the "control-plane"
// service.
func NewInitClusterClusterAlreadyInitializedResponseBody(res *goa.ServiceError) *InitClusterClusterAlreadyInitializedResponseBody {
	body := &InitClusterClusterAlreadyInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewJoinClusterClusterAlreadyInitializedResponseBody builds the HTTP response
// body from the result of the "join-cluster" endpoint of the "control-plane"
// service.
func NewJoinClusterClusterAlreadyInitializedResponseBody(res *goa.ServiceError) *JoinClusterClusterAlreadyInitializedResponseBody {
	body := &JoinClusterClusterAlreadyInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetJoinTokenClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "get-join-token" endpoint of the "control-plane"
// service.
func NewGetJoinTokenClusterNotInitializedResponseBody(res *goa.ServiceError) *GetJoinTokenClusterNotInitializedResponseBody {
	body := &GetJoinTokenClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetJoinOptionsClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "get-join-options" endpoint of the
// "control-plane" service.
func NewGetJoinOptionsClusterNotInitializedResponseBody(res *goa.ServiceError) *GetJoinOptionsClusterNotInitializedResponseBody {
	body := &GetJoinOptionsClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetJoinOptionsInvalidJoinTokenResponseBody builds the HTTP response body
// from the result of the "get-join-options" endpoint of the "control-plane"
// service.
func NewGetJoinOptionsInvalidJoinTokenResponseBody(res *goa.ServiceError) *GetJoinOptionsInvalidJoinTokenResponseBody {
	body := &GetJoinOptionsInvalidJoinTokenResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewInspectClusterClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "inspect-cluster" endpoint of the
// "control-plane" service.
func NewInspectClusterClusterNotInitializedResponseBody(res *goa.ServiceError) *InspectClusterClusterNotInitializedResponseBody {
	body := &InspectClusterClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewListHostsClusterNotInitializedResponseBody builds the HTTP response body
// from the result of the "list-hosts" endpoint of the "control-plane" service.
func NewListHostsClusterNotInitializedResponseBody(res *goa.ServiceError) *ListHostsClusterNotInitializedResponseBody {
	body := &ListHostsClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewInspectHostClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "inspect-host" endpoint of the "control-plane"
// service.
func NewInspectHostClusterNotInitializedResponseBody(res *goa.ServiceError) *InspectHostClusterNotInitializedResponseBody {
	body := &InspectHostClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewRemoveHostClusterNotInitializedResponseBody builds the HTTP response body
// from the result of the "remove-host" endpoint of the "control-plane" service.
func NewRemoveHostClusterNotInitializedResponseBody(res *goa.ServiceError) *RemoveHostClusterNotInitializedResponseBody {
	body := &RemoveHostClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewListDatabasesClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "list-databases" endpoint of the "control-plane"
// service.
func NewListDatabasesClusterNotInitializedResponseBody(res *goa.ServiceError) *ListDatabasesClusterNotInitializedResponseBody {
	body := &ListDatabasesClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewCreateDatabaseDatabaseAlreadyExistsResponseBody builds the HTTP response
// body from the result of the "create-database" endpoint of the
// "control-plane" service.
func NewCreateDatabaseDatabaseAlreadyExistsResponseBody(res *goa.ServiceError) *CreateDatabaseDatabaseAlreadyExistsResponseBody {
	body := &CreateDatabaseDatabaseAlreadyExistsResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewCreateDatabaseClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "create-database" endpoint of the
// "control-plane" service.
func NewCreateDatabaseClusterNotInitializedResponseBody(res *goa.ServiceError) *CreateDatabaseClusterNotInitializedResponseBody {
	body := &CreateDatabaseClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewCreateDatabaseInvalidInputResponseBody builds the HTTP response body from
// the result of the "create-database" endpoint of the "control-plane" service.
func NewCreateDatabaseInvalidInputResponseBody(res *goa.ServiceError) *CreateDatabaseInvalidInputResponseBody {
	body := &CreateDatabaseInvalidInputResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewInspectDatabaseClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "inspect-database" endpoint of the
// "control-plane" service.
func NewInspectDatabaseClusterNotInitializedResponseBody(res *goa.ServiceError) *InspectDatabaseClusterNotInitializedResponseBody {
	body := &InspectDatabaseClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewUpdateDatabaseClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "update-database" endpoint of the
// "control-plane" service.
func NewUpdateDatabaseClusterNotInitializedResponseBody(res *goa.ServiceError) *UpdateDatabaseClusterNotInitializedResponseBody {
	body := &UpdateDatabaseClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewDeleteDatabaseClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "delete-database" endpoint of the
// "control-plane" service.
func NewDeleteDatabaseClusterNotInitializedResponseBody(res *goa.ServiceError) *DeleteDatabaseClusterNotInitializedResponseBody {
	body := &DeleteDatabaseClusterNotInitializedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewJoinClusterClusterJoinToken builds a control-plane service join-cluster
// endpoint payload.
func NewJoinClusterClusterJoinToken(body *JoinClusterRequestBody) *controlplane.ClusterJoinToken {
	v := &controlplane.ClusterJoinToken{
		Token:     *body.Token,
		ServerURL: *body.ServerURL,
	}

	return v
}

// NewGetJoinOptionsClusterJoinRequest builds a control-plane service
// get-join-options endpoint payload.
func NewGetJoinOptionsClusterJoinRequest(body *GetJoinOptionsRequestBody) *controlplane.ClusterJoinRequest {
	v := &controlplane.ClusterJoinRequest{
		Token:       *body.Token,
		HostID:      *body.HostID,
		Hostname:    *body.Hostname,
		Ipv4Address: *body.Ipv4Address,
	}

	return v
}

// NewInspectHostPayload builds a control-plane service inspect-host endpoint
// payload.
func NewInspectHostPayload(hostID string) *controlplane.InspectHostPayload {
	v := &controlplane.InspectHostPayload{}
	v.HostID = &hostID

	return v
}

// NewRemoveHostPayload builds a control-plane service remove-host endpoint
// payload.
func NewRemoveHostPayload(hostID string) *controlplane.RemoveHostPayload {
	v := &controlplane.RemoveHostPayload{}
	v.HostID = &hostID

	return v
}

// NewCreateDatabaseRequest builds a control-plane service create-database
// endpoint payload.
func NewCreateDatabaseRequest(body *CreateDatabaseRequestBody) *controlplane.CreateDatabaseRequest {
	v := &controlplane.CreateDatabaseRequest{
		ID:       body.ID,
		TenantID: body.TenantID,
	}
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec(body.Spec)
	}

	return v
}

// NewInspectDatabasePayload builds a control-plane service inspect-database
// endpoint payload.
func NewInspectDatabasePayload(databaseID string) *controlplane.InspectDatabasePayload {
	v := &controlplane.InspectDatabasePayload{}
	v.DatabaseID = &databaseID

	return v
}

// NewUpdateDatabasePayload builds a control-plane service update-database
// endpoint payload.
func NewUpdateDatabasePayload(body *UpdateDatabaseRequestBody, databaseID string) *controlplane.UpdateDatabasePayload {
	v := &controlplane.UpdateDatabaseRequest{}
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec(body.Spec)
	}
	res := &controlplane.UpdateDatabasePayload{
		Request: v,
	}
	res.DatabaseID = &databaseID

	return res
}

// NewDeleteDatabasePayload builds a control-plane service delete-database
// endpoint payload.
func NewDeleteDatabasePayload(databaseID string) *controlplane.DeleteDatabasePayload {
	v := &controlplane.DeleteDatabasePayload{}
	v.DatabaseID = &databaseID

	return v
}

// ValidateJoinClusterRequestBody runs the validations defined on
// Join-ClusterRequestBody
func ValidateJoinClusterRequestBody(body *JoinClusterRequestBody) (err error) {
	if body.Token == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("token", "body"))
	}
	if body.ServerURL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("server_url", "body"))
	}
	if body.ServerURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.server_url", *body.ServerURL, goa.FormatURI))
	}
	return
}

// ValidateGetJoinOptionsRequestBody runs the validations defined on
// Get-Join-OptionsRequestBody
func ValidateGetJoinOptionsRequestBody(body *GetJoinOptionsRequestBody) (err error) {
	if body.Token == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("token", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	if body.Hostname == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hostname", "body"))
	}
	if body.Ipv4Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ipv4_address", "body"))
	}
	if body.HostID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.host_id", *body.HostID, goa.FormatUUID))
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	return
}

// ValidateCreateDatabaseRequestBody runs the validations defined on
// Create-DatabaseRequestBody
func ValidateCreateDatabaseRequestBody(body *CreateDatabaseRequestBody) (err error) {
	if body.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", *body.ID, goa.FormatUUID))
	}
	if body.TenantID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.tenant_id", *body.TenantID, goa.FormatUUID))
	}
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecRequestBody(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateUpdateDatabaseRequestBody runs the validations defined on
// Update-DatabaseRequestBody
func ValidateUpdateDatabaseRequestBody(body *UpdateDatabaseRequestBody) (err error) {
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecRequestBodyRequestBody(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseSpecRequestBody runs the validations defined on
// DatabaseSpecRequestBody
func ValidateDatabaseSpecRequestBody(body *DatabaseSpecRequestBody) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecRequestBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBody runs the validations defined on
// DatabaseNodeSpecRequestBody
func ValidateDatabaseNodeSpecRequestBody(body *DatabaseNodeSpecRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "body"))
	}
	if body.Name != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.name", *body.Name, "n[0-9]+"))
	}
	if len(body.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids", body.HostIds, len(body.HostIds), 1, true))
	}
	for _, e := range body.HostIds {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.host_ids[*]", e, goa.FormatUUID))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBackupConfigSpecRequestBody runs the validations defined on
// BackupConfigSpecRequestBody
func ValidateBackupConfigSpecRequestBody(body *BackupConfigSpecRequestBody) (err error) {
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBody runs the validations defined on
// BackupRepositorySpecRequestBody
func ValidateBackupRepositorySpecRequestBody(body *BackupRepositorySpecRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBody runs the validations defined on
// BackupScheduleSpecRequestBody
func ValidateBackupScheduleSpecRequestBody(body *BackupScheduleSpecRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	return
}

// ValidateDatabaseUserSpecRequestBody runs the validations defined on
// DatabaseUserSpecRequestBody
func ValidateDatabaseUserSpecRequestBody(body *DatabaseUserSpecRequestBody) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Password == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("password", "body"))
	}
	return
}

// ValidateRestoreConfigSpecRequestBody runs the validations defined on
// RestoreConfigSpecRequestBody
func ValidateRestoreConfigSpecRequestBody(body *RestoreConfigSpecRequestBody) (err error) {
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "body"))
	}
	if body.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	if body.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecRequestBody(body.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateRestoreRepositorySpecRequestBody runs the validations defined on
// RestoreRepositorySpecRequestBody
func ValidateRestoreRepositorySpecRequestBody(body *RestoreRepositorySpecRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	return
}

// ValidateDatabaseSpecRequestBodyRequestBody runs the validations defined on
// DatabaseSpecRequestBodyRequestBody
func ValidateDatabaseSpecRequestBodyRequestBody(body *DatabaseSpecRequestBodyRequestBody) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBodyRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecRequestBodyRequestBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBodyRequestBody runs the validations defined
// on DatabaseNodeSpecRequestBodyRequestBody
func ValidateDatabaseNodeSpecRequestBodyRequestBody(body *DatabaseNodeSpecRequestBodyRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "body"))
	}
	if body.Name != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.name", *body.Name, "n[0-9]+"))
	}
	if len(body.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids", body.HostIds, len(body.HostIds), 1, true))
	}
	for _, e := range body.HostIds {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.host_ids[*]", e, goa.FormatUUID))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBodyRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBackupConfigSpecRequestBodyRequestBody runs the validations defined
// on BackupConfigSpecRequestBodyRequestBody
func ValidateBackupConfigSpecRequestBodyRequestBody(body *BackupConfigSpecRequestBodyRequestBody) (err error) {
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBodyRequestBody runs the validations
// defined on BackupRepositorySpecRequestBodyRequestBody
func ValidateBackupRepositorySpecRequestBodyRequestBody(body *BackupRepositorySpecRequestBodyRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBodyRequestBody runs the validations
// defined on BackupScheduleSpecRequestBodyRequestBody
func ValidateBackupScheduleSpecRequestBodyRequestBody(body *BackupScheduleSpecRequestBodyRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	return
}

// ValidateDatabaseUserSpecRequestBodyRequestBody runs the validations defined
// on DatabaseUserSpecRequestBodyRequestBody
func ValidateDatabaseUserSpecRequestBodyRequestBody(body *DatabaseUserSpecRequestBodyRequestBody) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Password == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("password", "body"))
	}
	return
}

// ValidateRestoreConfigSpecRequestBodyRequestBody runs the validations defined
// on RestoreConfigSpecRequestBodyRequestBody
func ValidateRestoreConfigSpecRequestBodyRequestBody(body *RestoreConfigSpecRequestBodyRequestBody) (err error) {
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "body"))
	}
	if body.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	if body.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecRequestBodyRequestBody(body.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateRestoreRepositorySpecRequestBodyRequestBody runs the validations
// defined on RestoreRepositorySpecRequestBodyRequestBody
func ValidateRestoreRepositorySpecRequestBodyRequestBody(body *RestoreRepositorySpecRequestBodyRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	return
}
