// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane HTTP server types
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/design

package server

import (
	controlplane "github.com/pgEdge/control-plane/api/gen/control_plane"
	goa "goa.design/goa/v3/pkg"
)

// CreateDatabaseRequestBody is the type of the "control-plane" service
// "create-database" endpoint HTTP request body.
type CreateDatabaseRequestBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The specification for the database.
	Spec *DatabaseSpecRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseRequestBody is the type of the "control-plane" service
// "update-database" endpoint HTTP request body.
type UpdateDatabaseRequestBody struct {
	// The specification for the database.
	Spec *DatabaseSpecRequestBodyRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InspectClusterResponseBody is the type of the "control-plane" service
// "inspect-cluster" endpoint HTTP response body.
type InspectClusterResponseBody struct {
	// Unique identifier for the cluster.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the cluster's owner.
	TenantID string `form:"tenant_id" json:"tenant_id" xml:"tenant_id"`
	// Current status of the cluster.
	Status *ClusterStatusResponseBody `form:"status" json:"status" xml:"status"`
	// All of the hosts in the cluster.
	Hosts []*HostResponseBody `form:"hosts" json:"hosts" xml:"hosts"`
}

// ListHostsResponseBody is the type of the "control-plane" service
// "list-hosts" endpoint HTTP response body.
type ListHostsResponseBody []*HostResponse

// InspectHostResponseBody is the type of the "control-plane" service
// "inspect-host" endpoint HTTP response body.
type InspectHostResponseBody struct {
	// Unique identifier for the host
	ID string `form:"id" json:"id" xml:"id"`
	// The type of this host
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cohort that this host belongs to
	Cohort *string `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of this host.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
	// The configuration for this host
	Config *HostConfigurationResponseBody `form:"config,omitempty" json:"config,omitempty" xml:"config,omitempty"`
	// Current status of the host
	Status *HostStatusResponseBody `form:"status" json:"status" xml:"status"`
}

// ListDatabasesResponseBody is the type of the "control-plane" service
// "list-databases" endpoint HTTP response body.
type ListDatabasesResponseBody []*DatabaseResponse

// CreateDatabaseResponseBody is the type of the "control-plane" service
// "create-database" endpoint HTTP response body.
type CreateDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the database.
	Status *DatabaseStatusResponseBody `form:"status" json:"status" xml:"status"`
	// All of the instances in the database.
	Instances *InstanceResponseBody `form:"instances" json:"instances" xml:"instances"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InspectDatabaseResponseBody is the type of the "control-plane" service
// "inspect-database" endpoint HTTP response body.
type InspectDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the database.
	Status *DatabaseStatusResponseBody `form:"status" json:"status" xml:"status"`
	// All of the instances in the database.
	Instances *InstanceResponseBody `form:"instances" json:"instances" xml:"instances"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseResponseBody is the type of the "control-plane" service
// "update-database" endpoint HTTP response body.
type UpdateDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the database.
	Status *DatabaseStatusResponseBody `form:"status" json:"status" xml:"status"`
	// All of the instances in the database.
	Instances *InstanceResponseBody `form:"instances" json:"instances" xml:"instances"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// ClusterStatusResponseBody is used to define fields on response body types.
type ClusterStatusResponseBody struct {
	// The current state of the cluster.
	State string `form:"state" json:"state" xml:"state"`
}

// HostResponseBody is used to define fields on response body types.
type HostResponseBody struct {
	// Unique identifier for the host
	ID string `form:"id" json:"id" xml:"id"`
	// The type of this host
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cohort that this host belongs to
	Cohort *string `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of this host.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
	// The configuration for this host
	Config *HostConfigurationResponseBody `form:"config,omitempty" json:"config,omitempty" xml:"config,omitempty"`
	// Current status of the host
	Status *HostStatusResponseBody `form:"status" json:"status" xml:"status"`
}

// HostConfigurationResponseBody is used to define fields on response body
// types.
type HostConfigurationResponseBody struct {
	// Enables the Vector service for metrics and log collection
	VectorEnabled *bool `form:"vector_enabled,omitempty" json:"vector_enabled,omitempty" xml:"vector_enabled,omitempty"`
	// Enables the Treafik load balancer
	TraefikEnabled *bool `form:"traefik_enabled,omitempty" json:"traefik_enabled,omitempty" xml:"traefik_enabled,omitempty"`
}

// HostStatusResponseBody is used to define fields on response body types.
type HostStatusResponseBody struct {
	State string `form:"state" json:"state" xml:"state"`
}

// HostResponse is used to define fields on response body types.
type HostResponse struct {
	// Unique identifier for the host
	ID string `form:"id" json:"id" xml:"id"`
	// The type of this host
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cohort that this host belongs to
	Cohort *string `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of this host.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
	// The configuration for this host
	Config *HostConfigurationResponse `form:"config,omitempty" json:"config,omitempty" xml:"config,omitempty"`
	// Current status of the host
	Status *HostStatusResponse `form:"status" json:"status" xml:"status"`
}

// HostConfigurationResponse is used to define fields on response body types.
type HostConfigurationResponse struct {
	// Enables the Vector service for metrics and log collection
	VectorEnabled *bool `form:"vector_enabled,omitempty" json:"vector_enabled,omitempty" xml:"vector_enabled,omitempty"`
	// Enables the Treafik load balancer
	TraefikEnabled *bool `form:"traefik_enabled,omitempty" json:"traefik_enabled,omitempty" xml:"traefik_enabled,omitempty"`
}

// HostStatusResponse is used to define fields on response body types.
type HostStatusResponse struct {
	State string `form:"state" json:"state" xml:"state"`
}

// DatabaseResponse is used to define fields on response body types.
type DatabaseResponse struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the database.
	Status *DatabaseStatusResponse `form:"status" json:"status" xml:"status"`
	// All of the instances in the database.
	Instances *InstanceResponse `form:"instances" json:"instances" xml:"instances"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponse `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// DatabaseStatusResponse is used to define fields on response body types.
type DatabaseStatusResponse struct {
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The time that the database status was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// InstanceResponse is used to define fields on response body types.
type InstanceResponse struct {
	// Unique identifier for the instance.
	ID string `form:"id" json:"id" xml:"id"`
	// The ID of the host this instance is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The Spock node name for this instance.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The time that the instance was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the instance was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the instance.
	Status *InstanceStatusResponse `form:"status" json:"status" xml:"status"`
	// All interfaces that this instance serves on.
	Interfaces []*InstanceInterfaceResponse `form:"interfaces,omitempty" json:"interfaces,omitempty" xml:"interfaces,omitempty"`
}

// InstanceStatusResponse is used to define fields on response body types.
type InstanceStatusResponse struct {
	State        string  `form:"state" json:"state" xml:"state"`
	PatroniState *string `form:"patroni_state,omitempty" json:"patroni_state,omitempty" xml:"patroni_state,omitempty"`
	Role         *string `form:"role,omitempty" json:"role,omitempty" xml:"role,omitempty"`
	// True if this instance is in read-only mode.
	ReadOnly *bool `form:"read_only,omitempty" json:"read_only,omitempty" xml:"read_only,omitempty"`
	// True if this instance is pending to be restarted from a configuration change.
	PendingRestart *bool `form:"pending_restart,omitempty" json:"pending_restart,omitempty" xml:"pending_restart,omitempty"`
	// True if Patroni has been paused for this instance.
	PatroniPaused *bool `form:"patroni_paused,omitempty" json:"patroni_paused,omitempty" xml:"patroni_paused,omitempty"`
	// The version of Postgres for this instance.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The version of Spock for this instance.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The time that the instance status was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// InstanceInterfaceResponse is used to define fields on response body types.
type InstanceInterfaceResponse struct {
	// The type of network for this interface.
	NetworkType *string `form:"network_type,omitempty" json:"network_type,omitempty" xml:"network_type,omitempty"`
	// The unique identifier of the network for this interface.
	NetworkID *string `form:"network_id,omitempty" json:"network_id,omitempty" xml:"network_id,omitempty"`
	// The hostname of the instance on this interface.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of the instance on this interface.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The Postgres port for the instance on this interface.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
}

// DatabaseSpecResponse is used to define fields on response body types.
type DatabaseSpecResponse struct {
	// The name of the Postgres database.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecResponse `form:"nodes" json:"nodes" xml:"nodes"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecResponse `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The extensions to install for this database.
	Extensions []*DatabaseExtensionSpecResponse `form:"extensions,omitempty" json:"extensions,omitempty" xml:"extensions,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configurations for this database.
	BackupConfigs []*BackupConfigSpecResponse `form:"backup_configs,omitempty" json:"backup_configs,omitempty" xml:"backup_configs,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecResponse is used to define fields on response body types.
type DatabaseNodeSpecResponse struct {
	// The name of the database node.
	Name string `form:"name" json:"name" xml:"name"`
	// A unique identifier for the instance that will be created from this node
	// specification.
	InstanceID string `form:"instance_id" json:"instance_id" xml:"instance_id"`
	// The ID of the host that should run this node.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Read replicas for this database node.
	ReadReplicas *DatabaseReplicaSpecResponse `form:"read_replicas,omitempty" json:"read_replicas,omitempty" xml:"read_replicas,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseReplicaSpecResponse is used to define fields on response body types.
type DatabaseReplicaSpecResponse struct {
	// A unique identifier for the instance that will be created from this replica
	// specification.
	InstanceID string `form:"instance_id" json:"instance_id" xml:"instance_id"`
	// The ID of the host that should run this read replica.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
}

// DatabaseUserSpecResponse is used to define fields on response body types.
type DatabaseUserSpecResponse struct {
	// The username for this database user.
	Username string `form:"username" json:"username" xml:"username"`
	// The password for this database user.
	Password string `form:"password" json:"password" xml:"password"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
	// Enables SUPERUSER for this database user when true.
	Superuser *bool `form:"superuser,omitempty" json:"superuser,omitempty" xml:"superuser,omitempty"`
}

// DatabaseExtensionSpecResponse is used to define fields on response body
// types.
type DatabaseExtensionSpecResponse struct {
	// The name of the extension to install in this database.
	Name string `form:"name" json:"name" xml:"name"`
	// The version of the extension to install in this database.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// BackupConfigSpecResponse is used to define fields on response body types.
type BackupConfigSpecResponse struct {
	// The unique identifier for this backup configuration.
	ID string `form:"id" json:"id" xml:"id"`
	// The names of the nodes where this backup configuration should be applied.
	// The configuration will apply to all nodes when this field is empty or
	// unspecified.
	NodeNames []string `form:"node_names,omitempty" json:"node_names,omitempty" xml:"node_names,omitempty"`
	// The backup provider for this backup configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecResponse `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecResponse `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecResponse is used to define fields on response body types.
type BackupRepositorySpecResponse struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
}

// BackupScheduleSpecResponse is used to define fields on response body types.
type BackupScheduleSpecResponse struct {
	// The unique identifier for this backup schedule.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of backup to take on this schedule.
	Type string `form:"type" json:"type" xml:"type"`
	// The cron expression for this schedule.
	CronExpression string `form:"cron_expression" json:"cron_expression" xml:"cron_expression"`
}

// DatabaseStatusResponseBody is used to define fields on response body types.
type DatabaseStatusResponseBody struct {
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The time that the database status was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// InstanceResponseBody is used to define fields on response body types.
type InstanceResponseBody struct {
	// Unique identifier for the instance.
	ID string `form:"id" json:"id" xml:"id"`
	// The ID of the host this instance is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The Spock node name for this instance.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The time that the instance was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the instance was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the instance.
	Status *InstanceStatusResponseBody `form:"status" json:"status" xml:"status"`
	// All interfaces that this instance serves on.
	Interfaces []*InstanceInterfaceResponseBody `form:"interfaces,omitempty" json:"interfaces,omitempty" xml:"interfaces,omitempty"`
}

// InstanceStatusResponseBody is used to define fields on response body types.
type InstanceStatusResponseBody struct {
	State        string  `form:"state" json:"state" xml:"state"`
	PatroniState *string `form:"patroni_state,omitempty" json:"patroni_state,omitempty" xml:"patroni_state,omitempty"`
	Role         *string `form:"role,omitempty" json:"role,omitempty" xml:"role,omitempty"`
	// True if this instance is in read-only mode.
	ReadOnly *bool `form:"read_only,omitempty" json:"read_only,omitempty" xml:"read_only,omitempty"`
	// True if this instance is pending to be restarted from a configuration change.
	PendingRestart *bool `form:"pending_restart,omitempty" json:"pending_restart,omitempty" xml:"pending_restart,omitempty"`
	// True if Patroni has been paused for this instance.
	PatroniPaused *bool `form:"patroni_paused,omitempty" json:"patroni_paused,omitempty" xml:"patroni_paused,omitempty"`
	// The version of Postgres for this instance.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The version of Spock for this instance.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The time that the instance status was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// InstanceInterfaceResponseBody is used to define fields on response body
// types.
type InstanceInterfaceResponseBody struct {
	// The type of network for this interface.
	NetworkType *string `form:"network_type,omitempty" json:"network_type,omitempty" xml:"network_type,omitempty"`
	// The unique identifier of the network for this interface.
	NetworkID *string `form:"network_id,omitempty" json:"network_id,omitempty" xml:"network_id,omitempty"`
	// The hostname of the instance on this interface.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of the instance on this interface.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The Postgres port for the instance on this interface.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
}

// DatabaseSpecResponseBody is used to define fields on response body types.
type DatabaseSpecResponseBody struct {
	// The name of the Postgres database.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecResponseBody `form:"nodes" json:"nodes" xml:"nodes"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecResponseBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The extensions to install for this database.
	Extensions []*DatabaseExtensionSpecResponseBody `form:"extensions,omitempty" json:"extensions,omitempty" xml:"extensions,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configurations for this database.
	BackupConfigs []*BackupConfigSpecResponseBody `form:"backup_configs,omitempty" json:"backup_configs,omitempty" xml:"backup_configs,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecResponseBody is used to define fields on response body types.
type DatabaseNodeSpecResponseBody struct {
	// The name of the database node.
	Name string `form:"name" json:"name" xml:"name"`
	// A unique identifier for the instance that will be created from this node
	// specification.
	InstanceID string `form:"instance_id" json:"instance_id" xml:"instance_id"`
	// The ID of the host that should run this node.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Read replicas for this database node.
	ReadReplicas *DatabaseReplicaSpecResponseBody `form:"read_replicas,omitempty" json:"read_replicas,omitempty" xml:"read_replicas,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseReplicaSpecResponseBody is used to define fields on response body
// types.
type DatabaseReplicaSpecResponseBody struct {
	// A unique identifier for the instance that will be created from this replica
	// specification.
	InstanceID string `form:"instance_id" json:"instance_id" xml:"instance_id"`
	// The ID of the host that should run this read replica.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
}

// DatabaseUserSpecResponseBody is used to define fields on response body types.
type DatabaseUserSpecResponseBody struct {
	// The username for this database user.
	Username string `form:"username" json:"username" xml:"username"`
	// The password for this database user.
	Password string `form:"password" json:"password" xml:"password"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
	// Enables SUPERUSER for this database user when true.
	Superuser *bool `form:"superuser,omitempty" json:"superuser,omitempty" xml:"superuser,omitempty"`
}

// DatabaseExtensionSpecResponseBody is used to define fields on response body
// types.
type DatabaseExtensionSpecResponseBody struct {
	// The name of the extension to install in this database.
	Name string `form:"name" json:"name" xml:"name"`
	// The version of the extension to install in this database.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// BackupConfigSpecResponseBody is used to define fields on response body types.
type BackupConfigSpecResponseBody struct {
	// The unique identifier for this backup configuration.
	ID string `form:"id" json:"id" xml:"id"`
	// The names of the nodes where this backup configuration should be applied.
	// The configuration will apply to all nodes when this field is empty or
	// unspecified.
	NodeNames []string `form:"node_names,omitempty" json:"node_names,omitempty" xml:"node_names,omitempty"`
	// The backup provider for this backup configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecResponseBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecResponseBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecResponseBody is used to define fields on response body
// types.
type BackupRepositorySpecResponseBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
}

// BackupScheduleSpecResponseBody is used to define fields on response body
// types.
type BackupScheduleSpecResponseBody struct {
	// The unique identifier for this backup schedule.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of backup to take on this schedule.
	Type string `form:"type" json:"type" xml:"type"`
	// The cron expression for this schedule.
	CronExpression string `form:"cron_expression" json:"cron_expression" xml:"cron_expression"`
}

// DatabaseSpecRequestBody is used to define fields on request body types.
type DatabaseSpecRequestBody struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The extensions to install for this database.
	Extensions []*DatabaseExtensionSpecRequestBody `form:"extensions,omitempty" json:"extensions,omitempty" xml:"extensions,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configurations for this database.
	BackupConfigs []*BackupConfigSpecRequestBody `form:"backup_configs,omitempty" json:"backup_configs,omitempty" xml:"backup_configs,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecRequestBody is used to define fields on request body types.
type DatabaseNodeSpecRequestBody struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// A unique identifier for the instance that will be created from this node
	// specification.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that should run this node.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Read replicas for this database node.
	ReadReplicas *DatabaseReplicaSpecRequestBody `form:"read_replicas,omitempty" json:"read_replicas,omitempty" xml:"read_replicas,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseReplicaSpecRequestBody is used to define fields on request body
// types.
type DatabaseReplicaSpecRequestBody struct {
	// A unique identifier for the instance that will be created from this replica
	// specification.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that should run this read replica.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
}

// DatabaseUserSpecRequestBody is used to define fields on request body types.
type DatabaseUserSpecRequestBody struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
	// Enables SUPERUSER for this database user when true.
	Superuser *bool `form:"superuser,omitempty" json:"superuser,omitempty" xml:"superuser,omitempty"`
}

// DatabaseExtensionSpecRequestBody is used to define fields on request body
// types.
type DatabaseExtensionSpecRequestBody struct {
	// The name of the extension to install in this database.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The version of the extension to install in this database.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// BackupConfigSpecRequestBody is used to define fields on request body types.
type BackupConfigSpecRequestBody struct {
	// The unique identifier for this backup configuration.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The names of the nodes where this backup configuration should be applied.
	// The configuration will apply to all nodes when this field is empty or
	// unspecified.
	NodeNames []string `form:"node_names,omitempty" json:"node_names,omitempty" xml:"node_names,omitempty"`
	// The backup provider for this backup configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBody is used to define fields on request body
// types.
type BackupRepositorySpecRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
}

// BackupScheduleSpecRequestBody is used to define fields on request body types.
type BackupScheduleSpecRequestBody struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// DatabaseSpecRequestBodyRequestBody is used to define fields on request body
// types.
type DatabaseSpecRequestBodyRequestBody struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBodyRequestBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBodyRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The extensions to install for this database.
	Extensions []*DatabaseExtensionSpecRequestBodyRequestBody `form:"extensions,omitempty" json:"extensions,omitempty" xml:"extensions,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configurations for this database.
	BackupConfigs []*BackupConfigSpecRequestBodyRequestBody `form:"backup_configs,omitempty" json:"backup_configs,omitempty" xml:"backup_configs,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseNodeSpecRequestBodyRequestBody struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// A unique identifier for the instance that will be created from this node
	// specification.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that should run this node.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Read replicas for this database node.
	ReadReplicas *DatabaseReplicaSpecRequestBodyRequestBody `form:"read_replicas,omitempty" json:"read_replicas,omitempty" xml:"read_replicas,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseReplicaSpecRequestBodyRequestBody is used to define fields on
// request body types.
type DatabaseReplicaSpecRequestBodyRequestBody struct {
	// A unique identifier for the instance that will be created from this replica
	// specification.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that should run this read replica.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
}

// DatabaseUserSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseUserSpecRequestBodyRequestBody struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
	// Enables SUPERUSER for this database user when true.
	Superuser *bool `form:"superuser,omitempty" json:"superuser,omitempty" xml:"superuser,omitempty"`
}

// DatabaseExtensionSpecRequestBodyRequestBody is used to define fields on
// request body types.
type DatabaseExtensionSpecRequestBodyRequestBody struct {
	// The name of the extension to install in this database.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The version of the extension to install in this database.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// BackupConfigSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupConfigSpecRequestBodyRequestBody struct {
	// The unique identifier for this backup configuration.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The names of the nodes where this backup configuration should be applied.
	// The configuration will apply to all nodes when this field is empty or
	// unspecified.
	NodeNames []string `form:"node_names,omitempty" json:"node_names,omitempty" xml:"node_names,omitempty"`
	// The backup provider for this backup configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBodyRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBodyRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBodyRequestBody is used to define fields on
// request body types.
type BackupRepositorySpecRequestBodyRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
}

// BackupScheduleSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupScheduleSpecRequestBodyRequestBody struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// NewInspectClusterResponseBody builds the HTTP response body from the result
// of the "inspect-cluster" endpoint of the "control-plane" service.
func NewInspectClusterResponseBody(res *controlplane.Cluster) *InspectClusterResponseBody {
	body := &InspectClusterResponseBody{
		ID:       res.ID,
		TenantID: res.TenantID,
	}
	if res.Status != nil {
		body.Status = marshalControlplaneClusterStatusToClusterStatusResponseBody(res.Status)
	}
	if res.Hosts != nil {
		body.Hosts = make([]*HostResponseBody, len(res.Hosts))
		for i, val := range res.Hosts {
			body.Hosts[i] = marshalControlplaneHostToHostResponseBody(val)
		}
	} else {
		body.Hosts = []*HostResponseBody{}
	}
	return body
}

// NewListHostsResponseBody builds the HTTP response body from the result of
// the "list-hosts" endpoint of the "control-plane" service.
func NewListHostsResponseBody(res []*controlplane.Host) ListHostsResponseBody {
	body := make([]*HostResponse, len(res))
	for i, val := range res {
		body[i] = marshalControlplaneHostToHostResponse(val)
	}
	return body
}

// NewInspectHostResponseBody builds the HTTP response body from the result of
// the "inspect-host" endpoint of the "control-plane" service.
func NewInspectHostResponseBody(res *controlplane.Host) *InspectHostResponseBody {
	body := &InspectHostResponseBody{
		ID:          res.ID,
		Type:        res.Type,
		Cohort:      res.Cohort,
		Hostname:    res.Hostname,
		Ipv4Address: res.Ipv4Address,
	}
	if res.Config != nil {
		body.Config = marshalControlplaneHostConfigurationToHostConfigurationResponseBody(res.Config)
	}
	if res.Status != nil {
		body.Status = marshalControlplaneHostStatusToHostStatusResponseBody(res.Status)
	}
	return body
}

// NewListDatabasesResponseBody builds the HTTP response body from the result
// of the "list-databases" endpoint of the "control-plane" service.
func NewListDatabasesResponseBody(res []*controlplane.Database) ListDatabasesResponseBody {
	body := make([]*DatabaseResponse, len(res))
	for i, val := range res {
		body[i] = marshalControlplaneDatabaseToDatabaseResponse(val)
	}
	return body
}

// NewCreateDatabaseResponseBody builds the HTTP response body from the result
// of the "create-database" endpoint of the "control-plane" service.
func NewCreateDatabaseResponseBody(res *controlplane.Database) *CreateDatabaseResponseBody {
	body := &CreateDatabaseResponseBody{
		ID:        res.ID,
		TenantID:  res.TenantID,
		CreatedAt: res.CreatedAt,
		UpdatedAt: res.UpdatedAt,
	}
	if res.Status != nil {
		body.Status = marshalControlplaneDatabaseStatusToDatabaseStatusResponseBody(res.Status)
	}
	if res.Instances != nil {
		body.Instances = marshalControlplaneInstanceToInstanceResponseBody(res.Instances)
	}
	if res.Spec != nil {
		body.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody(res.Spec)
	}
	return body
}

// NewInspectDatabaseResponseBody builds the HTTP response body from the result
// of the "inspect-database" endpoint of the "control-plane" service.
func NewInspectDatabaseResponseBody(res *controlplane.Database) *InspectDatabaseResponseBody {
	body := &InspectDatabaseResponseBody{
		ID:        res.ID,
		TenantID:  res.TenantID,
		CreatedAt: res.CreatedAt,
		UpdatedAt: res.UpdatedAt,
	}
	if res.Status != nil {
		body.Status = marshalControlplaneDatabaseStatusToDatabaseStatusResponseBody(res.Status)
	}
	if res.Instances != nil {
		body.Instances = marshalControlplaneInstanceToInstanceResponseBody(res.Instances)
	}
	if res.Spec != nil {
		body.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody(res.Spec)
	}
	return body
}

// NewUpdateDatabaseResponseBody builds the HTTP response body from the result
// of the "update-database" endpoint of the "control-plane" service.
func NewUpdateDatabaseResponseBody(res *controlplane.Database) *UpdateDatabaseResponseBody {
	body := &UpdateDatabaseResponseBody{
		ID:        res.ID,
		TenantID:  res.TenantID,
		CreatedAt: res.CreatedAt,
		UpdatedAt: res.UpdatedAt,
	}
	if res.Status != nil {
		body.Status = marshalControlplaneDatabaseStatusToDatabaseStatusResponseBody(res.Status)
	}
	if res.Instances != nil {
		body.Instances = marshalControlplaneInstanceToInstanceResponseBody(res.Instances)
	}
	if res.Spec != nil {
		body.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody(res.Spec)
	}
	return body
}

// NewInspectHostPayload builds a control-plane service inspect-host endpoint
// payload.
func NewInspectHostPayload(hostID string) *controlplane.InspectHostPayload {
	v := &controlplane.InspectHostPayload{}
	v.HostID = &hostID

	return v
}

// NewRemoveHostPayload builds a control-plane service remove-host endpoint
// payload.
func NewRemoveHostPayload(hostID string) *controlplane.RemoveHostPayload {
	v := &controlplane.RemoveHostPayload{}
	v.HostID = &hostID

	return v
}

// NewCreateDatabaseRequest builds a control-plane service create-database
// endpoint payload.
func NewCreateDatabaseRequest(body *CreateDatabaseRequestBody) *controlplane.CreateDatabaseRequest {
	v := &controlplane.CreateDatabaseRequest{
		ID:       body.ID,
		TenantID: body.TenantID,
	}
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec(body.Spec)
	}

	return v
}

// NewInspectDatabasePayload builds a control-plane service inspect-database
// endpoint payload.
func NewInspectDatabasePayload(databaseID string) *controlplane.InspectDatabasePayload {
	v := &controlplane.InspectDatabasePayload{}
	v.DatabaseID = &databaseID

	return v
}

// NewUpdateDatabasePayload builds a control-plane service update-database
// endpoint payload.
func NewUpdateDatabasePayload(body *UpdateDatabaseRequestBody, databaseID string) *controlplane.UpdateDatabasePayload {
	v := &controlplane.UpdateDatabaseRequest{}
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec(body.Spec)
	}
	res := &controlplane.UpdateDatabasePayload{
		Request: v,
	}
	res.DatabaseID = &databaseID

	return res
}

// NewDeleteDatabasePayload builds a control-plane service delete-database
// endpoint payload.
func NewDeleteDatabasePayload(databaseID string) *controlplane.DeleteDatabasePayload {
	v := &controlplane.DeleteDatabasePayload{}
	v.DatabaseID = &databaseID

	return v
}

// ValidateCreateDatabaseRequestBody runs the validations defined on
// Create-DatabaseRequestBody
func ValidateCreateDatabaseRequestBody(body *CreateDatabaseRequestBody) (err error) {
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecRequestBody(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateUpdateDatabaseRequestBody runs the validations defined on
// Update-DatabaseRequestBody
func ValidateUpdateDatabaseRequestBody(body *UpdateDatabaseRequestBody) (err error) {
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecRequestBodyRequestBody(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseSpecRequestBody runs the validations defined on
// DatabaseSpecRequestBody
func ValidateDatabaseSpecRequestBody(body *DatabaseSpecRequestBody) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Extensions {
		if e != nil {
			if err2 := ValidateDatabaseExtensionSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.BackupConfigs {
		if e != nil {
			if err2 := ValidateBackupConfigSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBody runs the validations defined on
// DatabaseNodeSpecRequestBody
func ValidateDatabaseNodeSpecRequestBody(body *DatabaseNodeSpecRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.InstanceID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instance_id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.ReadReplicas != nil {
		if err2 := ValidateDatabaseReplicaSpecRequestBody(body.ReadReplicas); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseReplicaSpecRequestBody runs the validations defined on
// DatabaseReplicaSpecRequestBody
func ValidateDatabaseReplicaSpecRequestBody(body *DatabaseReplicaSpecRequestBody) (err error) {
	if body.InstanceID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instance_id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	return
}

// ValidateDatabaseUserSpecRequestBody runs the validations defined on
// DatabaseUserSpecRequestBody
func ValidateDatabaseUserSpecRequestBody(body *DatabaseUserSpecRequestBody) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Password == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("password", "body"))
	}
	return
}

// ValidateDatabaseExtensionSpecRequestBody runs the validations defined on
// DatabaseExtensionSpecRequestBody
func ValidateDatabaseExtensionSpecRequestBody(body *DatabaseExtensionSpecRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	return
}

// ValidateBackupConfigSpecRequestBody runs the validations defined on
// BackupConfigSpecRequestBody
func ValidateBackupConfigSpecRequestBody(body *BackupConfigSpecRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBody runs the validations defined on
// BackupRepositorySpecRequestBody
func ValidateBackupRepositorySpecRequestBody(body *BackupRepositorySpecRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBody runs the validations defined on
// BackupScheduleSpecRequestBody
func ValidateBackupScheduleSpecRequestBody(body *BackupScheduleSpecRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	return
}

// ValidateDatabaseSpecRequestBodyRequestBody runs the validations defined on
// DatabaseSpecRequestBodyRequestBody
func ValidateDatabaseSpecRequestBodyRequestBody(body *DatabaseSpecRequestBodyRequestBody) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Extensions {
		if e != nil {
			if err2 := ValidateDatabaseExtensionSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.BackupConfigs {
		if e != nil {
			if err2 := ValidateBackupConfigSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBodyRequestBody runs the validations defined
// on DatabaseNodeSpecRequestBodyRequestBody
func ValidateDatabaseNodeSpecRequestBodyRequestBody(body *DatabaseNodeSpecRequestBodyRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.InstanceID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instance_id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.ReadReplicas != nil {
		if err2 := ValidateDatabaseReplicaSpecRequestBodyRequestBody(body.ReadReplicas); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseReplicaSpecRequestBodyRequestBody runs the validations
// defined on DatabaseReplicaSpecRequestBodyRequestBody
func ValidateDatabaseReplicaSpecRequestBodyRequestBody(body *DatabaseReplicaSpecRequestBodyRequestBody) (err error) {
	if body.InstanceID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instance_id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	return
}

// ValidateDatabaseUserSpecRequestBodyRequestBody runs the validations defined
// on DatabaseUserSpecRequestBodyRequestBody
func ValidateDatabaseUserSpecRequestBodyRequestBody(body *DatabaseUserSpecRequestBodyRequestBody) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Password == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("password", "body"))
	}
	return
}

// ValidateDatabaseExtensionSpecRequestBodyRequestBody runs the validations
// defined on DatabaseExtensionSpecRequestBodyRequestBody
func ValidateDatabaseExtensionSpecRequestBodyRequestBody(body *DatabaseExtensionSpecRequestBodyRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	return
}

// ValidateBackupConfigSpecRequestBodyRequestBody runs the validations defined
// on BackupConfigSpecRequestBodyRequestBody
func ValidateBackupConfigSpecRequestBodyRequestBody(body *BackupConfigSpecRequestBodyRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBodyRequestBody runs the validations
// defined on BackupRepositorySpecRequestBodyRequestBody
func ValidateBackupRepositorySpecRequestBodyRequestBody(body *BackupRepositorySpecRequestBodyRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBodyRequestBody runs the validations
// defined on BackupScheduleSpecRequestBodyRequestBody
func ValidateBackupScheduleSpecRequestBodyRequestBody(body *BackupScheduleSpecRequestBodyRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	return
}
