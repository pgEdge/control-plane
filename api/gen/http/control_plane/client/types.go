// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane HTTP client types
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/design

package client

import (
	controlplane "github.com/pgEdge/control-plane/api/gen/control_plane"
	goa "goa.design/goa/v3/pkg"
)

// CreateDatabaseRequestBody is the type of the "control-plane" service
// "create-database" endpoint HTTP request body.
type CreateDatabaseRequestBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The specification for the database.
	Spec *DatabaseSpecRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseRequestBody is the type of the "control-plane" service
// "update-database" endpoint HTTP request body.
type UpdateDatabaseRequestBody struct {
	// The specification for the database.
	Spec *DatabaseSpecRequestBodyRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InspectClusterResponseBody is the type of the "control-plane" service
// "inspect-cluster" endpoint HTTP response body.
type InspectClusterResponseBody struct {
	// Unique identifier for the cluster.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the cluster's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// Current status of the cluster.
	Status *ClusterStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// All of the hosts in the cluster.
	Hosts []*HostResponseBody `form:"hosts,omitempty" json:"hosts,omitempty" xml:"hosts,omitempty"`
}

// ListHostsResponseBody is the type of the "control-plane" service
// "list-hosts" endpoint HTTP response body.
type ListHostsResponseBody []*HostResponse

// InspectHostResponseBody is the type of the "control-plane" service
// "inspect-host" endpoint HTTP response body.
type InspectHostResponseBody struct {
	// Unique identifier for the host
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this host
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cohort that this host belongs to
	Cohort *string `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of this host.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The configuration for this host
	Config *HostConfigurationResponseBody `form:"config,omitempty" json:"config,omitempty" xml:"config,omitempty"`
	// Current status of the host
	Status *HostStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// ListDatabasesResponseBody is the type of the "control-plane" service
// "list-databases" endpoint HTTP response body.
type ListDatabasesResponseBody []*DatabaseResponse

// CreateDatabaseResponseBody is the type of the "control-plane" service
// "create-database" endpoint HTTP response body.
type CreateDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the database.
	Status *DatabaseStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// All of the instances in the database.
	Instances *InstanceResponseBody `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InspectDatabaseResponseBody is the type of the "control-plane" service
// "inspect-database" endpoint HTTP response body.
type InspectDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the database.
	Status *DatabaseStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// All of the instances in the database.
	Instances *InstanceResponseBody `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseResponseBody is the type of the "control-plane" service
// "update-database" endpoint HTTP response body.
type UpdateDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the database.
	Status *DatabaseStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// All of the instances in the database.
	Instances *InstanceResponseBody `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// ClusterStatusResponseBody is used to define fields on response body types.
type ClusterStatusResponseBody struct {
	// The current state of the cluster.
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
}

// HostResponseBody is used to define fields on response body types.
type HostResponseBody struct {
	// Unique identifier for the host
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this host
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cohort that this host belongs to
	Cohort *string `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of this host.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The configuration for this host
	Config *HostConfigurationResponseBody `form:"config,omitempty" json:"config,omitempty" xml:"config,omitempty"`
	// Current status of the host
	Status *HostStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// HostConfigurationResponseBody is used to define fields on response body
// types.
type HostConfigurationResponseBody struct {
	// Enables the Vector service for metrics and log collection
	VectorEnabled *bool `form:"vector_enabled,omitempty" json:"vector_enabled,omitempty" xml:"vector_enabled,omitempty"`
	// Enables the Treafik load balancer
	TraefikEnabled *bool `form:"traefik_enabled,omitempty" json:"traefik_enabled,omitempty" xml:"traefik_enabled,omitempty"`
}

// HostStatusResponseBody is used to define fields on response body types.
type HostStatusResponseBody struct {
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
}

// HostResponse is used to define fields on response body types.
type HostResponse struct {
	// Unique identifier for the host
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this host
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cohort that this host belongs to
	Cohort *string `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of this host.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The configuration for this host
	Config *HostConfigurationResponse `form:"config,omitempty" json:"config,omitempty" xml:"config,omitempty"`
	// Current status of the host
	Status *HostStatusResponse `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// HostConfigurationResponse is used to define fields on response body types.
type HostConfigurationResponse struct {
	// Enables the Vector service for metrics and log collection
	VectorEnabled *bool `form:"vector_enabled,omitempty" json:"vector_enabled,omitempty" xml:"vector_enabled,omitempty"`
	// Enables the Treafik load balancer
	TraefikEnabled *bool `form:"traefik_enabled,omitempty" json:"traefik_enabled,omitempty" xml:"traefik_enabled,omitempty"`
}

// HostStatusResponse is used to define fields on response body types.
type HostStatusResponse struct {
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
}

// DatabaseResponse is used to define fields on response body types.
type DatabaseResponse struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the database.
	Status *DatabaseStatusResponse `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// All of the instances in the database.
	Instances *InstanceResponse `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponse `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// DatabaseStatusResponse is used to define fields on response body types.
type DatabaseStatusResponse struct {
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The time that the database status was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// InstanceResponse is used to define fields on response body types.
type InstanceResponse struct {
	// Unique identifier for the instance.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The ID of the host this instance is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The Spock node name for this instance.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The time that the instance was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the instance was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the instance.
	Status *InstanceStatusResponse `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// All interfaces that this instance serves on.
	Interfaces []*InstanceInterfaceResponse `form:"interfaces,omitempty" json:"interfaces,omitempty" xml:"interfaces,omitempty"`
}

// InstanceStatusResponse is used to define fields on response body types.
type InstanceStatusResponse struct {
	State        *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	PatroniState *string `form:"patroni_state,omitempty" json:"patroni_state,omitempty" xml:"patroni_state,omitempty"`
	Role         *string `form:"role,omitempty" json:"role,omitempty" xml:"role,omitempty"`
	// True if this instance is in read-only mode.
	ReadOnly *bool `form:"read_only,omitempty" json:"read_only,omitempty" xml:"read_only,omitempty"`
	// True if this instance is pending to be restarted from a configuration change.
	PendingRestart *bool `form:"pending_restart,omitempty" json:"pending_restart,omitempty" xml:"pending_restart,omitempty"`
	// True if Patroni has been paused for this instance.
	PatroniPaused *bool `form:"patroni_paused,omitempty" json:"patroni_paused,omitempty" xml:"patroni_paused,omitempty"`
	// The version of Postgres for this instance.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The version of Spock for this instance.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The time that the instance status was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// InstanceInterfaceResponse is used to define fields on response body types.
type InstanceInterfaceResponse struct {
	// The type of network for this interface.
	NetworkType *string `form:"network_type,omitempty" json:"network_type,omitempty" xml:"network_type,omitempty"`
	// The unique identifier of the network for this interface.
	NetworkID *string `form:"network_id,omitempty" json:"network_id,omitempty" xml:"network_id,omitempty"`
	// The hostname of the instance on this interface.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of the instance on this interface.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The Postgres port for the instance on this interface.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
}

// DatabaseSpecResponse is used to define fields on response body types.
type DatabaseSpecResponse struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecResponse `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecResponse `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The extensions to install for this database.
	Extensions []*DatabaseExtensionSpecResponse `form:"extensions,omitempty" json:"extensions,omitempty" xml:"extensions,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configurations for this database.
	BackupConfigs []*BackupConfigSpecResponse `form:"backup_configs,omitempty" json:"backup_configs,omitempty" xml:"backup_configs,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecResponse is used to define fields on response body types.
type DatabaseNodeSpecResponse struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// A unique identifier for the instance that will be created from this node
	// specification.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that should run this node.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Read replicas for this database node.
	ReadReplicas *DatabaseReplicaSpecResponse `form:"read_replicas,omitempty" json:"read_replicas,omitempty" xml:"read_replicas,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseReplicaSpecResponse is used to define fields on response body types.
type DatabaseReplicaSpecResponse struct {
	// A unique identifier for the instance that will be created from this replica
	// specification.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that should run this read replica.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
}

// DatabaseUserSpecResponse is used to define fields on response body types.
type DatabaseUserSpecResponse struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
	// Enables SUPERUSER for this database user when true.
	Superuser *bool `form:"superuser,omitempty" json:"superuser,omitempty" xml:"superuser,omitempty"`
}

// DatabaseExtensionSpecResponse is used to define fields on response body
// types.
type DatabaseExtensionSpecResponse struct {
	// The name of the extension to install in this database.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The version of the extension to install in this database.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// BackupConfigSpecResponse is used to define fields on response body types.
type BackupConfigSpecResponse struct {
	// The unique identifier for this backup configuration.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The names of the nodes where this backup configuration should be applied.
	// The configuration will apply to all nodes when this field is empty or
	// unspecified.
	NodeNames []string `form:"node_names,omitempty" json:"node_names,omitempty" xml:"node_names,omitempty"`
	// The backup provider for this backup configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecResponse `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecResponse `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecResponse is used to define fields on response body types.
type BackupRepositorySpecResponse struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
}

// BackupScheduleSpecResponse is used to define fields on response body types.
type BackupScheduleSpecResponse struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// DatabaseSpecRequestBody is used to define fields on request body types.
type DatabaseSpecRequestBody struct {
	// The name of the Postgres database.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBody `form:"nodes" json:"nodes" xml:"nodes"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The extensions to install for this database.
	Extensions []*DatabaseExtensionSpecRequestBody `form:"extensions,omitempty" json:"extensions,omitempty" xml:"extensions,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configurations for this database.
	BackupConfigs []*BackupConfigSpecRequestBody `form:"backup_configs,omitempty" json:"backup_configs,omitempty" xml:"backup_configs,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecRequestBody is used to define fields on request body types.
type DatabaseNodeSpecRequestBody struct {
	// The name of the database node.
	Name string `form:"name" json:"name" xml:"name"`
	// A unique identifier for the instance that will be created from this node
	// specification.
	InstanceID string `form:"instance_id" json:"instance_id" xml:"instance_id"`
	// The ID of the host that should run this node.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Read replicas for this database node.
	ReadReplicas *DatabaseReplicaSpecRequestBody `form:"read_replicas,omitempty" json:"read_replicas,omitempty" xml:"read_replicas,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseReplicaSpecRequestBody is used to define fields on request body
// types.
type DatabaseReplicaSpecRequestBody struct {
	// A unique identifier for the instance that will be created from this replica
	// specification.
	InstanceID string `form:"instance_id" json:"instance_id" xml:"instance_id"`
	// The ID of the host that should run this read replica.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
}

// DatabaseUserSpecRequestBody is used to define fields on request body types.
type DatabaseUserSpecRequestBody struct {
	// The username for this database user.
	Username string `form:"username" json:"username" xml:"username"`
	// The password for this database user.
	Password string `form:"password" json:"password" xml:"password"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
	// Enables SUPERUSER for this database user when true.
	Superuser *bool `form:"superuser,omitempty" json:"superuser,omitempty" xml:"superuser,omitempty"`
}

// DatabaseExtensionSpecRequestBody is used to define fields on request body
// types.
type DatabaseExtensionSpecRequestBody struct {
	// The name of the extension to install in this database.
	Name string `form:"name" json:"name" xml:"name"`
	// The version of the extension to install in this database.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// BackupConfigSpecRequestBody is used to define fields on request body types.
type BackupConfigSpecRequestBody struct {
	// The unique identifier for this backup configuration.
	ID string `form:"id" json:"id" xml:"id"`
	// The names of the nodes where this backup configuration should be applied.
	// The configuration will apply to all nodes when this field is empty or
	// unspecified.
	NodeNames []string `form:"node_names,omitempty" json:"node_names,omitempty" xml:"node_names,omitempty"`
	// The backup provider for this backup configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBody is used to define fields on request body
// types.
type BackupRepositorySpecRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
}

// BackupScheduleSpecRequestBody is used to define fields on request body types.
type BackupScheduleSpecRequestBody struct {
	// The unique identifier for this backup schedule.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of backup to take on this schedule.
	Type string `form:"type" json:"type" xml:"type"`
	// The cron expression for this schedule.
	CronExpression string `form:"cron_expression" json:"cron_expression" xml:"cron_expression"`
}

// DatabaseStatusResponseBody is used to define fields on response body types.
type DatabaseStatusResponseBody struct {
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The time that the database status was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// InstanceResponseBody is used to define fields on response body types.
type InstanceResponseBody struct {
	// Unique identifier for the instance.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The ID of the host this instance is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The Spock node name for this instance.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The time that the instance was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the instance was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current status of the instance.
	Status *InstanceStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// All interfaces that this instance serves on.
	Interfaces []*InstanceInterfaceResponseBody `form:"interfaces,omitempty" json:"interfaces,omitempty" xml:"interfaces,omitempty"`
}

// InstanceStatusResponseBody is used to define fields on response body types.
type InstanceStatusResponseBody struct {
	State        *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	PatroniState *string `form:"patroni_state,omitempty" json:"patroni_state,omitempty" xml:"patroni_state,omitempty"`
	Role         *string `form:"role,omitempty" json:"role,omitempty" xml:"role,omitempty"`
	// True if this instance is in read-only mode.
	ReadOnly *bool `form:"read_only,omitempty" json:"read_only,omitempty" xml:"read_only,omitempty"`
	// True if this instance is pending to be restarted from a configuration change.
	PendingRestart *bool `form:"pending_restart,omitempty" json:"pending_restart,omitempty" xml:"pending_restart,omitempty"`
	// True if Patroni has been paused for this instance.
	PatroniPaused *bool `form:"patroni_paused,omitempty" json:"patroni_paused,omitempty" xml:"patroni_paused,omitempty"`
	// The version of Postgres for this instance.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The version of Spock for this instance.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The time that the instance status was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// InstanceInterfaceResponseBody is used to define fields on response body
// types.
type InstanceInterfaceResponseBody struct {
	// The type of network for this interface.
	NetworkType *string `form:"network_type,omitempty" json:"network_type,omitempty" xml:"network_type,omitempty"`
	// The unique identifier of the network for this interface.
	NetworkID *string `form:"network_id,omitempty" json:"network_id,omitempty" xml:"network_id,omitempty"`
	// The hostname of the instance on this interface.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of the instance on this interface.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The Postgres port for the instance on this interface.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
}

// DatabaseSpecResponseBody is used to define fields on response body types.
type DatabaseSpecResponseBody struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecResponseBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecResponseBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The extensions to install for this database.
	Extensions []*DatabaseExtensionSpecResponseBody `form:"extensions,omitempty" json:"extensions,omitempty" xml:"extensions,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configurations for this database.
	BackupConfigs []*BackupConfigSpecResponseBody `form:"backup_configs,omitempty" json:"backup_configs,omitempty" xml:"backup_configs,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecResponseBody is used to define fields on response body types.
type DatabaseNodeSpecResponseBody struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// A unique identifier for the instance that will be created from this node
	// specification.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that should run this node.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Read replicas for this database node.
	ReadReplicas *DatabaseReplicaSpecResponseBody `form:"read_replicas,omitempty" json:"read_replicas,omitempty" xml:"read_replicas,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseReplicaSpecResponseBody is used to define fields on response body
// types.
type DatabaseReplicaSpecResponseBody struct {
	// A unique identifier for the instance that will be created from this replica
	// specification.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that should run this read replica.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
}

// DatabaseUserSpecResponseBody is used to define fields on response body types.
type DatabaseUserSpecResponseBody struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
	// Enables SUPERUSER for this database user when true.
	Superuser *bool `form:"superuser,omitempty" json:"superuser,omitempty" xml:"superuser,omitempty"`
}

// DatabaseExtensionSpecResponseBody is used to define fields on response body
// types.
type DatabaseExtensionSpecResponseBody struct {
	// The name of the extension to install in this database.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The version of the extension to install in this database.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// BackupConfigSpecResponseBody is used to define fields on response body types.
type BackupConfigSpecResponseBody struct {
	// The unique identifier for this backup configuration.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The names of the nodes where this backup configuration should be applied.
	// The configuration will apply to all nodes when this field is empty or
	// unspecified.
	NodeNames []string `form:"node_names,omitempty" json:"node_names,omitempty" xml:"node_names,omitempty"`
	// The backup provider for this backup configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecResponseBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecResponseBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecResponseBody is used to define fields on response body
// types.
type BackupRepositorySpecResponseBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
}

// BackupScheduleSpecResponseBody is used to define fields on response body
// types.
type BackupScheduleSpecResponseBody struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// DatabaseSpecRequestBodyRequestBody is used to define fields on request body
// types.
type DatabaseSpecRequestBodyRequestBody struct {
	// The name of the Postgres database.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBodyRequestBody `form:"nodes" json:"nodes" xml:"nodes"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBodyRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The extensions to install for this database.
	Extensions []*DatabaseExtensionSpecRequestBodyRequestBody `form:"extensions,omitempty" json:"extensions,omitempty" xml:"extensions,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configurations for this database.
	BackupConfigs []*BackupConfigSpecRequestBodyRequestBody `form:"backup_configs,omitempty" json:"backup_configs,omitempty" xml:"backup_configs,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseNodeSpecRequestBodyRequestBody struct {
	// The name of the database node.
	Name string `form:"name" json:"name" xml:"name"`
	// A unique identifier for the instance that will be created from this node
	// specification.
	InstanceID string `form:"instance_id" json:"instance_id" xml:"instance_id"`
	// The ID of the host that should run this node.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Read replicas for this database node.
	ReadReplicas *DatabaseReplicaSpecRequestBodyRequestBody `form:"read_replicas,omitempty" json:"read_replicas,omitempty" xml:"read_replicas,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseReplicaSpecRequestBodyRequestBody is used to define fields on
// request body types.
type DatabaseReplicaSpecRequestBodyRequestBody struct {
	// A unique identifier for the instance that will be created from this replica
	// specification.
	InstanceID string `form:"instance_id" json:"instance_id" xml:"instance_id"`
	// The ID of the host that should run this read replica.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
}

// DatabaseUserSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseUserSpecRequestBodyRequestBody struct {
	// The username for this database user.
	Username string `form:"username" json:"username" xml:"username"`
	// The password for this database user.
	Password string `form:"password" json:"password" xml:"password"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
	// Enables SUPERUSER for this database user when true.
	Superuser *bool `form:"superuser,omitempty" json:"superuser,omitempty" xml:"superuser,omitempty"`
}

// DatabaseExtensionSpecRequestBodyRequestBody is used to define fields on
// request body types.
type DatabaseExtensionSpecRequestBodyRequestBody struct {
	// The name of the extension to install in this database.
	Name string `form:"name" json:"name" xml:"name"`
	// The version of the extension to install in this database.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// BackupConfigSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupConfigSpecRequestBodyRequestBody struct {
	// The unique identifier for this backup configuration.
	ID string `form:"id" json:"id" xml:"id"`
	// The names of the nodes where this backup configuration should be applied.
	// The configuration will apply to all nodes when this field is empty or
	// unspecified.
	NodeNames []string `form:"node_names,omitempty" json:"node_names,omitempty" xml:"node_names,omitempty"`
	// The backup provider for this backup configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBodyRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBodyRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBodyRequestBody is used to define fields on
// request body types.
type BackupRepositorySpecRequestBodyRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
}

// BackupScheduleSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupScheduleSpecRequestBodyRequestBody struct {
	// The unique identifier for this backup schedule.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of backup to take on this schedule.
	Type string `form:"type" json:"type" xml:"type"`
	// The cron expression for this schedule.
	CronExpression string `form:"cron_expression" json:"cron_expression" xml:"cron_expression"`
}

// NewCreateDatabaseRequestBody builds the HTTP request body from the payload
// of the "create-database" endpoint of the "control-plane" service.
func NewCreateDatabaseRequestBody(p *controlplane.CreateDatabaseRequest) *CreateDatabaseRequestBody {
	body := &CreateDatabaseRequestBody{
		ID:       p.ID,
		TenantID: p.TenantID,
	}
	if p.Spec != nil {
		body.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecRequestBody(p.Spec)
	}
	return body
}

// NewUpdateDatabaseRequestBody builds the HTTP request body from the payload
// of the "update-database" endpoint of the "control-plane" service.
func NewUpdateDatabaseRequestBody(p *controlplane.UpdateDatabasePayload) *UpdateDatabaseRequestBody {
	body := &UpdateDatabaseRequestBody{}
	if p.Request.Spec != nil {
		body.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecRequestBodyRequestBody(p.Request.Spec)
	}
	return body
}

// NewInspectClusterClusterOK builds a "control-plane" service
// "inspect-cluster" endpoint result from a HTTP "OK" response.
func NewInspectClusterClusterOK(body *InspectClusterResponseBody) *controlplane.Cluster {
	v := &controlplane.Cluster{
		ID:       *body.ID,
		TenantID: *body.TenantID,
	}
	v.Status = unmarshalClusterStatusResponseBodyToControlplaneClusterStatus(body.Status)
	v.Hosts = make([]*controlplane.Host, len(body.Hosts))
	for i, val := range body.Hosts {
		v.Hosts[i] = unmarshalHostResponseBodyToControlplaneHost(val)
	}

	return v
}

// NewListHostsHostOK builds a "control-plane" service "list-hosts" endpoint
// result from a HTTP "OK" response.
func NewListHostsHostOK(body []*HostResponse) []*controlplane.Host {
	v := make([]*controlplane.Host, len(body))
	for i, val := range body {
		v[i] = unmarshalHostResponseToControlplaneHost(val)
	}

	return v
}

// NewInspectHostHostOK builds a "control-plane" service "inspect-host"
// endpoint result from a HTTP "OK" response.
func NewInspectHostHostOK(body *InspectHostResponseBody) *controlplane.Host {
	v := &controlplane.Host{
		ID:          *body.ID,
		Type:        body.Type,
		Cohort:      body.Cohort,
		Hostname:    *body.Hostname,
		Ipv4Address: *body.Ipv4Address,
	}
	if body.Config != nil {
		v.Config = unmarshalHostConfigurationResponseBodyToControlplaneHostConfiguration(body.Config)
	}
	v.Status = unmarshalHostStatusResponseBodyToControlplaneHostStatus(body.Status)

	return v
}

// NewListDatabasesDatabaseOK builds a "control-plane" service "list-databases"
// endpoint result from a HTTP "OK" response.
func NewListDatabasesDatabaseOK(body []*DatabaseResponse) []*controlplane.Database {
	v := make([]*controlplane.Database, len(body))
	for i, val := range body {
		v[i] = unmarshalDatabaseResponseToControlplaneDatabase(val)
	}

	return v
}

// NewCreateDatabaseDatabaseOK builds a "control-plane" service
// "create-database" endpoint result from a HTTP "OK" response.
func NewCreateDatabaseDatabaseOK(body *CreateDatabaseResponseBody) *controlplane.Database {
	v := &controlplane.Database{
		ID:        *body.ID,
		TenantID:  body.TenantID,
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
	}
	v.Status = unmarshalDatabaseStatusResponseBodyToControlplaneDatabaseStatus(body.Status)
	v.Instances = unmarshalInstanceResponseBodyToControlplaneInstance(body.Instances)
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecResponseBodyToControlplaneDatabaseSpec(body.Spec)
	}

	return v
}

// NewInspectDatabaseDatabaseOK builds a "control-plane" service
// "inspect-database" endpoint result from a HTTP "OK" response.
func NewInspectDatabaseDatabaseOK(body *InspectDatabaseResponseBody) *controlplane.Database {
	v := &controlplane.Database{
		ID:        *body.ID,
		TenantID:  body.TenantID,
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
	}
	v.Status = unmarshalDatabaseStatusResponseBodyToControlplaneDatabaseStatus(body.Status)
	v.Instances = unmarshalInstanceResponseBodyToControlplaneInstance(body.Instances)
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecResponseBodyToControlplaneDatabaseSpec(body.Spec)
	}

	return v
}

// NewUpdateDatabaseDatabaseOK builds a "control-plane" service
// "update-database" endpoint result from a HTTP "OK" response.
func NewUpdateDatabaseDatabaseOK(body *UpdateDatabaseResponseBody) *controlplane.Database {
	v := &controlplane.Database{
		ID:        *body.ID,
		TenantID:  body.TenantID,
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
	}
	v.Status = unmarshalDatabaseStatusResponseBodyToControlplaneDatabaseStatus(body.Status)
	v.Instances = unmarshalInstanceResponseBodyToControlplaneInstance(body.Instances)
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecResponseBodyToControlplaneDatabaseSpec(body.Spec)
	}

	return v
}

// ValidateInspectClusterResponseBody runs the validations defined on
// Inspect-ClusterResponseBody
func ValidateInspectClusterResponseBody(body *InspectClusterResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.TenantID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("tenant_id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Hosts == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hosts", "body"))
	}
	if body.Status != nil {
		if err2 := ValidateClusterStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Hosts {
		if e != nil {
			if err2 := ValidateHostResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInspectHostResponseBody runs the validations defined on
// Inspect-HostResponseBody
func ValidateInspectHostResponseBody(body *InspectHostResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Hostname == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hostname", "body"))
	}
	if body.Ipv4Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ipv4_address", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "swarm" || *body.Type == "systemd") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"swarm", "systemd"}))
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	if body.Status != nil {
		if err2 := ValidateHostStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateCreateDatabaseResponseBody runs the validations defined on
// Create-DatabaseResponseBody
func ValidateCreateDatabaseResponseBody(body *CreateDatabaseResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Instances == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instances", "body"))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	if body.Status != nil {
		if err2 := ValidateDatabaseStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Instances != nil {
		if err2 := ValidateInstanceResponseBody(body.Instances); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecResponseBody(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateInspectDatabaseResponseBody runs the validations defined on
// Inspect-DatabaseResponseBody
func ValidateInspectDatabaseResponseBody(body *InspectDatabaseResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Instances == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instances", "body"))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	if body.Status != nil {
		if err2 := ValidateDatabaseStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Instances != nil {
		if err2 := ValidateInstanceResponseBody(body.Instances); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecResponseBody(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateUpdateDatabaseResponseBody runs the validations defined on
// Update-DatabaseResponseBody
func ValidateUpdateDatabaseResponseBody(body *UpdateDatabaseResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Instances == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instances", "body"))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	if body.Status != nil {
		if err2 := ValidateDatabaseStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Instances != nil {
		if err2 := ValidateInstanceResponseBody(body.Instances); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecResponseBody(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateClusterStatusResponseBody runs the validations defined on
// ClusterStatusResponseBody
func ValidateClusterStatusResponseBody(body *ClusterStatusResponseBody) (err error) {
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.State != nil {
		if !(*body.State == "available" || *body.State == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"available", "error"}))
		}
	}
	return
}

// ValidateHostResponseBody runs the validations defined on HostResponseBody
func ValidateHostResponseBody(body *HostResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Hostname == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hostname", "body"))
	}
	if body.Ipv4Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ipv4_address", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "swarm" || *body.Type == "systemd") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"swarm", "systemd"}))
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	if body.Status != nil {
		if err2 := ValidateHostStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateHostStatusResponseBody runs the validations defined on
// HostStatusResponseBody
func ValidateHostStatusResponseBody(body *HostStatusResponseBody) (err error) {
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.State != nil {
		if !(*body.State == "available" || *body.State == "unreachable" || *body.State == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"available", "unreachable", "error"}))
		}
	}
	return
}

// ValidateHostResponse runs the validations defined on HostResponse
func ValidateHostResponse(body *HostResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Hostname == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hostname", "body"))
	}
	if body.Ipv4Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ipv4_address", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "swarm" || *body.Type == "systemd") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"swarm", "systemd"}))
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	if body.Status != nil {
		if err2 := ValidateHostStatusResponse(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateHostStatusResponse runs the validations defined on HostStatusResponse
func ValidateHostStatusResponse(body *HostStatusResponse) (err error) {
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.State != nil {
		if !(*body.State == "available" || *body.State == "unreachable" || *body.State == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"available", "unreachable", "error"}))
		}
	}
	return
}

// ValidateDatabaseResponse runs the validations defined on DatabaseResponse
func ValidateDatabaseResponse(body *DatabaseResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Instances == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instances", "body"))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	if body.Status != nil {
		if err2 := ValidateDatabaseStatusResponse(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Instances != nil {
		if err2 := ValidateInstanceResponse(body.Instances); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecResponse(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseStatusResponse runs the validations defined on
// DatabaseStatusResponse
func ValidateDatabaseStatusResponse(body *DatabaseStatusResponse) (err error) {
	if body.State != nil {
		if !(*body.State == "creating" || *body.State == "modifying" || *body.State == "available" || *body.State == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"creating", "modifying", "available", "error"}))
		}
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	return
}

// ValidateInstanceResponse runs the validations defined on InstanceResponse
func ValidateInstanceResponse(body *InstanceResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	if body.Status != nil {
		if err2 := ValidateInstanceStatusResponse(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Interfaces {
		if e != nil {
			if err2 := ValidateInstanceInterfaceResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInstanceStatusResponse runs the validations defined on
// InstanceStatusResponse
func ValidateInstanceStatusResponse(body *InstanceStatusResponse) (err error) {
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.State != nil {
		if !(*body.State == "creating" || *body.State == "modifying" || *body.State == "backing_up" || *body.State == "available" || *body.State == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"creating", "modifying", "backing_up", "available", "error"}))
		}
	}
	if body.PatroniState != nil {
		if !(*body.PatroniState == "stopping" || *body.PatroniState == "stopped" || *body.PatroniState == "stop failed" || *body.PatroniState == "crashed" || *body.PatroniState == "running" || *body.PatroniState == "starting" || *body.PatroniState == "start failed" || *body.PatroniState == "restarting" || *body.PatroniState == "restart failed" || *body.PatroniState == "initializing new cluster" || *body.PatroniState == "initdb failed" || *body.PatroniState == "running custom bootstrap script" || *body.PatroniState == "custom bootstrap failed" || *body.PatroniState == "creating replica" || *body.PatroniState == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.patroni_state", *body.PatroniState, []any{"stopping", "stopped", "stop failed", "crashed", "running", "starting", "start failed", "restarting", "restart failed", "initializing new cluster", "initdb failed", "running custom bootstrap script", "custom bootstrap failed", "creating replica", "unknown"}))
		}
	}
	if body.Role != nil {
		if !(*body.Role == "replica" || *body.Role == "primary") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.role", *body.Role, []any{"replica", "primary"}))
		}
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	return
}

// ValidateInstanceInterfaceResponse runs the validations defined on
// InstanceInterfaceResponse
func ValidateInstanceInterfaceResponse(body *InstanceInterfaceResponse) (err error) {
	if body.NetworkType != nil {
		if !(*body.NetworkType == "docker" || *body.NetworkType == "host") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.network_type", *body.NetworkType, []any{"docker", "host"}))
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	return
}

// ValidateDatabaseSpecResponse runs the validations defined on
// DatabaseSpecResponse
func ValidateDatabaseSpecResponse(body *DatabaseSpecResponse) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Extensions {
		if e != nil {
			if err2 := ValidateDatabaseExtensionSpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.BackupConfigs {
		if e != nil {
			if err2 := ValidateBackupConfigSpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDatabaseNodeSpecResponse runs the validations defined on
// DatabaseNodeSpecResponse
func ValidateDatabaseNodeSpecResponse(body *DatabaseNodeSpecResponse) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.InstanceID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instance_id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.ReadReplicas != nil {
		if err2 := ValidateDatabaseReplicaSpecResponse(body.ReadReplicas); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseReplicaSpecResponse runs the validations defined on
// DatabaseReplicaSpecResponse
func ValidateDatabaseReplicaSpecResponse(body *DatabaseReplicaSpecResponse) (err error) {
	if body.InstanceID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instance_id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	return
}

// ValidateDatabaseUserSpecResponse runs the validations defined on
// DatabaseUserSpecResponse
func ValidateDatabaseUserSpecResponse(body *DatabaseUserSpecResponse) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Password == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("password", "body"))
	}
	return
}

// ValidateDatabaseExtensionSpecResponse runs the validations defined on
// DatabaseExtensionSpecResponse
func ValidateDatabaseExtensionSpecResponse(body *DatabaseExtensionSpecResponse) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	return
}

// ValidateBackupConfigSpecResponse runs the validations defined on
// BackupConfigSpecResponse
func ValidateBackupConfigSpecResponse(body *BackupConfigSpecResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecResponse runs the validations defined on
// BackupRepositorySpecResponse
func ValidateBackupRepositorySpecResponse(body *BackupRepositorySpecResponse) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecResponse runs the validations defined on
// BackupScheduleSpecResponse
func ValidateBackupScheduleSpecResponse(body *BackupScheduleSpecResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	return
}

// ValidateDatabaseSpecRequestBody runs the validations defined on
// DatabaseSpecRequestBody
func ValidateDatabaseSpecRequestBody(body *DatabaseSpecRequestBody) (err error) {
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.BackupConfigs {
		if e != nil {
			if err2 := ValidateBackupConfigSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBody runs the validations defined on
// DatabaseNodeSpecRequestBody
func ValidateDatabaseNodeSpecRequestBody(body *DatabaseNodeSpecRequestBody) (err error) {
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	return
}

// ValidateBackupConfigSpecRequestBody runs the validations defined on
// BackupConfigSpecRequestBody
func ValidateBackupConfigSpecRequestBody(body *BackupConfigSpecRequestBody) (err error) {
	if !(body.Provider == "pgbackrest" || body.Provider == "pg_dump") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", body.Provider, []any{"pgbackrest", "pg_dump"}))
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBody runs the validations defined on
// BackupRepositorySpecRequestBody
func ValidateBackupRepositorySpecRequestBody(body *BackupRepositorySpecRequestBody) (err error) {
	if !(body.Type == "s3" || body.Type == "gcs" || body.Type == "azure") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"s3", "gcs", "azure"}))
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBody runs the validations defined on
// BackupScheduleSpecRequestBody
func ValidateBackupScheduleSpecRequestBody(body *BackupScheduleSpecRequestBody) (err error) {
	if !(body.Type == "full" || body.Type == "incr") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"full", "incr"}))
	}
	return
}

// ValidateDatabaseStatusResponseBody runs the validations defined on
// DatabaseStatusResponseBody
func ValidateDatabaseStatusResponseBody(body *DatabaseStatusResponseBody) (err error) {
	if body.State != nil {
		if !(*body.State == "creating" || *body.State == "modifying" || *body.State == "available" || *body.State == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"creating", "modifying", "available", "error"}))
		}
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	return
}

// ValidateInstanceResponseBody runs the validations defined on
// InstanceResponseBody
func ValidateInstanceResponseBody(body *InstanceResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	if body.Status != nil {
		if err2 := ValidateInstanceStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Interfaces {
		if e != nil {
			if err2 := ValidateInstanceInterfaceResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInstanceStatusResponseBody runs the validations defined on
// InstanceStatusResponseBody
func ValidateInstanceStatusResponseBody(body *InstanceStatusResponseBody) (err error) {
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.State != nil {
		if !(*body.State == "creating" || *body.State == "modifying" || *body.State == "backing_up" || *body.State == "available" || *body.State == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"creating", "modifying", "backing_up", "available", "error"}))
		}
	}
	if body.PatroniState != nil {
		if !(*body.PatroniState == "stopping" || *body.PatroniState == "stopped" || *body.PatroniState == "stop failed" || *body.PatroniState == "crashed" || *body.PatroniState == "running" || *body.PatroniState == "starting" || *body.PatroniState == "start failed" || *body.PatroniState == "restarting" || *body.PatroniState == "restart failed" || *body.PatroniState == "initializing new cluster" || *body.PatroniState == "initdb failed" || *body.PatroniState == "running custom bootstrap script" || *body.PatroniState == "custom bootstrap failed" || *body.PatroniState == "creating replica" || *body.PatroniState == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.patroni_state", *body.PatroniState, []any{"stopping", "stopped", "stop failed", "crashed", "running", "starting", "start failed", "restarting", "restart failed", "initializing new cluster", "initdb failed", "running custom bootstrap script", "custom bootstrap failed", "creating replica", "unknown"}))
		}
	}
	if body.Role != nil {
		if !(*body.Role == "replica" || *body.Role == "primary") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.role", *body.Role, []any{"replica", "primary"}))
		}
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	return
}

// ValidateInstanceInterfaceResponseBody runs the validations defined on
// InstanceInterfaceResponseBody
func ValidateInstanceInterfaceResponseBody(body *InstanceInterfaceResponseBody) (err error) {
	if body.NetworkType != nil {
		if !(*body.NetworkType == "docker" || *body.NetworkType == "host") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.network_type", *body.NetworkType, []any{"docker", "host"}))
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	return
}

// ValidateDatabaseSpecResponseBody runs the validations defined on
// DatabaseSpecResponseBody
func ValidateDatabaseSpecResponseBody(body *DatabaseSpecResponseBody) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Extensions {
		if e != nil {
			if err2 := ValidateDatabaseExtensionSpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.BackupConfigs {
		if e != nil {
			if err2 := ValidateBackupConfigSpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDatabaseNodeSpecResponseBody runs the validations defined on
// DatabaseNodeSpecResponseBody
func ValidateDatabaseNodeSpecResponseBody(body *DatabaseNodeSpecResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.InstanceID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instance_id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.ReadReplicas != nil {
		if err2 := ValidateDatabaseReplicaSpecResponseBody(body.ReadReplicas); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseReplicaSpecResponseBody runs the validations defined on
// DatabaseReplicaSpecResponseBody
func ValidateDatabaseReplicaSpecResponseBody(body *DatabaseReplicaSpecResponseBody) (err error) {
	if body.InstanceID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("instance_id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	return
}

// ValidateDatabaseUserSpecResponseBody runs the validations defined on
// DatabaseUserSpecResponseBody
func ValidateDatabaseUserSpecResponseBody(body *DatabaseUserSpecResponseBody) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Password == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("password", "body"))
	}
	return
}

// ValidateDatabaseExtensionSpecResponseBody runs the validations defined on
// DatabaseExtensionSpecResponseBody
func ValidateDatabaseExtensionSpecResponseBody(body *DatabaseExtensionSpecResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	return
}

// ValidateBackupConfigSpecResponseBody runs the validations defined on
// BackupConfigSpecResponseBody
func ValidateBackupConfigSpecResponseBody(body *BackupConfigSpecResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecResponseBody runs the validations defined on
// BackupRepositorySpecResponseBody
func ValidateBackupRepositorySpecResponseBody(body *BackupRepositorySpecResponseBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecResponseBody runs the validations defined on
// BackupScheduleSpecResponseBody
func ValidateBackupScheduleSpecResponseBody(body *BackupScheduleSpecResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	return
}

// ValidateDatabaseSpecRequestBodyRequestBody runs the validations defined on
// DatabaseSpecRequestBodyRequestBody
func ValidateDatabaseSpecRequestBodyRequestBody(body *DatabaseSpecRequestBodyRequestBody) (err error) {
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.BackupConfigs {
		if e != nil {
			if err2 := ValidateBackupConfigSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBodyRequestBody runs the validations defined
// on DatabaseNodeSpecRequestBodyRequestBody
func ValidateDatabaseNodeSpecRequestBodyRequestBody(body *DatabaseNodeSpecRequestBodyRequestBody) (err error) {
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	return
}

// ValidateBackupConfigSpecRequestBodyRequestBody runs the validations defined
// on BackupConfigSpecRequestBodyRequestBody
func ValidateBackupConfigSpecRequestBodyRequestBody(body *BackupConfigSpecRequestBodyRequestBody) (err error) {
	if !(body.Provider == "pgbackrest" || body.Provider == "pg_dump") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", body.Provider, []any{"pgbackrest", "pg_dump"}))
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBodyRequestBody runs the validations
// defined on BackupRepositorySpecRequestBodyRequestBody
func ValidateBackupRepositorySpecRequestBodyRequestBody(body *BackupRepositorySpecRequestBodyRequestBody) (err error) {
	if !(body.Type == "s3" || body.Type == "gcs" || body.Type == "azure") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"s3", "gcs", "azure"}))
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBodyRequestBody runs the validations
// defined on BackupScheduleSpecRequestBodyRequestBody
func ValidateBackupScheduleSpecRequestBodyRequestBody(body *BackupScheduleSpecRequestBodyRequestBody) (err error) {
	if !(body.Type == "full" || body.Type == "incr") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"full", "incr"}))
	}
	return
}
