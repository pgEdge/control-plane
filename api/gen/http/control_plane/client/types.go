// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane HTTP client types
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/design

package client

import (
	controlplane "github.com/pgEdge/control-plane/api/gen/control_plane"
	controlplaneviews "github.com/pgEdge/control-plane/api/gen/control_plane/views"
	goa "goa.design/goa/v3/pkg"
)

// JoinClusterRequestBody is the type of the "control-plane" service
// "join-cluster" endpoint HTTP request body.
type JoinClusterRequestBody struct {
	// Token to join an existing cluster.
	Token string `form:"token" json:"token" xml:"token"`
	// Existing server to join
	ServerURL string `form:"server_url" json:"server_url" xml:"server_url"`
}

// GetJoinOptionsRequestBody is the type of the "control-plane" service
// "get-join-options" endpoint HTTP request body.
type GetJoinOptionsRequestBody struct {
	// Token to join the cluster.
	Token string `form:"token" json:"token" xml:"token"`
	// The unique identifier for the host that's joining the cluster.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
	// The hostname of the host that's joining the cluster.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of the host that's joining the cluster.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
}

// CreateDatabaseRequestBody is the type of the "control-plane" service
// "create-database" endpoint HTTP request body.
type CreateDatabaseRequestBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The specification for the database.
	Spec *DatabaseSpecRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseRequestBody is the type of the "control-plane" service
// "update-database" endpoint HTTP request body.
type UpdateDatabaseRequestBody struct {
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The specification for the database.
	Spec *DatabaseSpecRequestBodyRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InitiateDatabaseBackupRequestBody is the type of the "control-plane" service
// "initiate-database-backup" endpoint HTTP request body.
type InitiateDatabaseBackupRequestBody struct {
	// The type of backup.
	Type string `form:"type" json:"type" xml:"type"`
	// Annotations for the backup.
	Annotations map[string]string `form:"annotations,omitempty" json:"annotations,omitempty" xml:"annotations,omitempty"`
	// Extra options for the backup.
	ExtraOptions []string `form:"extra_options,omitempty" json:"extra_options,omitempty" xml:"extra_options,omitempty"`
}

// InitClusterResponseBody is the type of the "control-plane" service
// "init-cluster" endpoint HTTP response body.
type InitClusterResponseBody struct {
	// Token to join an existing cluster.
	Token *string `form:"token,omitempty" json:"token,omitempty" xml:"token,omitempty"`
	// Existing server to join
	ServerURL *string `form:"server_url,omitempty" json:"server_url,omitempty" xml:"server_url,omitempty"`
}

// GetJoinTokenResponseBody is the type of the "control-plane" service
// "get-join-token" endpoint HTTP response body.
type GetJoinTokenResponseBody struct {
	// Token to join an existing cluster.
	Token *string `form:"token,omitempty" json:"token,omitempty" xml:"token,omitempty"`
	// Existing server to join
	ServerURL *string `form:"server_url,omitempty" json:"server_url,omitempty" xml:"server_url,omitempty"`
}

// GetJoinOptionsResponseBody is the type of the "control-plane" service
// "get-join-options" endpoint HTTP response body.
type GetJoinOptionsResponseBody struct {
	// Information about this cluster member
	Peer *ClusterPeerResponseBody `form:"peer,omitempty" json:"peer,omitempty" xml:"peer,omitempty"`
	// Credentials for the new host joining the cluster.
	Credentials *ClusterCredentialsResponseBody `form:"credentials,omitempty" json:"credentials,omitempty" xml:"credentials,omitempty"`
}

// InspectClusterResponseBody is the type of the "control-plane" service
// "inspect-cluster" endpoint HTTP response body.
type InspectClusterResponseBody struct {
	// Unique identifier for the cluster.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the cluster's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// Current status of the cluster.
	Status *ClusterStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// All of the hosts in the cluster.
	Hosts []*HostResponseBody `form:"hosts,omitempty" json:"hosts,omitempty" xml:"hosts,omitempty"`
}

// ListHostsResponseBody is the type of the "control-plane" service
// "list-hosts" endpoint HTTP response body.
type ListHostsResponseBody []*HostResponse

// InspectHostResponseBody is the type of the "control-plane" service
// "inspect-host" endpoint HTTP response body.
type InspectHostResponseBody struct {
	// Unique identifier for the host.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The orchestrator used by this host.
	Orchestrator *string `form:"orchestrator,omitempty" json:"orchestrator,omitempty" xml:"orchestrator,omitempty"`
	// The cohort that this host belongs to/
	Cohort *HostCohortResponseBody `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of this host.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The number of CPUs on this host.
	Cpus *int `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory available on this host.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Current status of the host.
	Status *HostStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersionResponseBody `form:"default_pgedge_version,omitempty" json:"default_pgedge_version,omitempty" xml:"default_pgedge_version,omitempty"`
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersionResponseBody `form:"supported_pgedge_versions,omitempty" json:"supported_pgedge_versions,omitempty" xml:"supported_pgedge_versions,omitempty"`
}

// ListDatabasesResponseBody is the type of the "control-plane" service
// "list-databases" endpoint HTTP response body.
type ListDatabasesResponseBody []*DatabaseResponse

// CreateDatabaseResponseBody is the type of the "control-plane" service
// "create-database" endpoint HTTP response body.
type CreateDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current state of the database.
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// All of the instances in the database.
	Instances InstanceResponseBodyAbbreviatedCollection `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InspectDatabaseResponseBody is the type of the "control-plane" service
// "inspect-database" endpoint HTTP response body.
type InspectDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current state of the database.
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// All of the instances in the database.
	Instances InstanceResponseBodyAbbreviatedCollection `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseResponseBody is the type of the "control-plane" service
// "update-database" endpoint HTTP response body.
type UpdateDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current state of the database.
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// All of the instances in the database.
	Instances InstanceResponseBodyAbbreviatedCollection `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InitiateDatabaseBackupResponseBody is the type of the "control-plane"
// service "initiate-database-backup" endpoint HTTP response body.
type InitiateDatabaseBackupResponseBody struct {
	// The database ID of the task.
	DatabaseID *string `form:"database_id,omitempty" json:"database_id,omitempty" xml:"database_id,omitempty"`
	// The unique ID of the task.
	TaskID *string `form:"task_id,omitempty" json:"task_id,omitempty" xml:"task_id,omitempty"`
	// The time when the task was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time when the task was completed.
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
	// The type of the task.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The status of the task.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// The error message if the task failed.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// ListDatabaseTasksResponseBody is the type of the "control-plane" service
// "list-database-tasks" endpoint HTTP response body.
type ListDatabaseTasksResponseBody []*TaskResponse

// InspectDatabaseTaskResponseBody is the type of the "control-plane" service
// "inspect-database-task" endpoint HTTP response body.
type InspectDatabaseTaskResponseBody struct {
	// The database ID of the task.
	DatabaseID *string `form:"database_id,omitempty" json:"database_id,omitempty" xml:"database_id,omitempty"`
	// The unique ID of the task.
	TaskID *string `form:"task_id,omitempty" json:"task_id,omitempty" xml:"task_id,omitempty"`
	// The time when the task was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time when the task was completed.
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
	// The type of the task.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The status of the task.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// The error message if the task failed.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// GetDatabaseTaskLogResponseBody is the type of the "control-plane" service
// "get-database-task-log" endpoint HTTP response body.
type GetDatabaseTaskLogResponseBody struct {
	// The database ID of the task log.
	DatabaseID *string `form:"database_id,omitempty" json:"database_id,omitempty" xml:"database_id,omitempty"`
	// The unique ID of the task log.
	TaskID *string `form:"task_id,omitempty" json:"task_id,omitempty" xml:"task_id,omitempty"`
	// The status of the task.
	TaskStatus *string `form:"task_status,omitempty" json:"task_status,omitempty" xml:"task_status,omitempty"`
	// The ID of the last line in the task log.
	LastLineID *string `form:"last_line_id,omitempty" json:"last_line_id,omitempty" xml:"last_line_id,omitempty"`
	// The lines of the task log.
	Lines []string `form:"lines,omitempty" json:"lines,omitempty" xml:"lines,omitempty"`
}

// InitClusterClusterAlreadyInitializedResponseBody is the type of the
// "control-plane" service "init-cluster" endpoint HTTP response body for the
// "cluster_already_initialized" error.
type InitClusterClusterAlreadyInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// JoinClusterClusterAlreadyInitializedResponseBody is the type of the
// "control-plane" service "join-cluster" endpoint HTTP response body for the
// "cluster_already_initialized" error.
type JoinClusterClusterAlreadyInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// GetJoinTokenClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-join-token" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type GetJoinTokenClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// GetJoinOptionsClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-join-options" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type GetJoinOptionsClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// GetJoinOptionsInvalidJoinTokenResponseBody is the type of the
// "control-plane" service "get-join-options" endpoint HTTP response body for
// the "invalid_join_token" error.
type GetJoinOptionsInvalidJoinTokenResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InspectClusterClusterNotInitializedResponseBody is the type of the
// "control-plane" service "inspect-cluster" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type InspectClusterClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InspectClusterNotFoundResponseBody is the type of the "control-plane"
// service "inspect-cluster" endpoint HTTP response body for the "not_found"
// error.
type InspectClusterNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ListHostsClusterNotInitializedResponseBody is the type of the
// "control-plane" service "list-hosts" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type ListHostsClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InspectHostClusterNotInitializedResponseBody is the type of the
// "control-plane" service "inspect-host" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type InspectHostClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InspectHostNotFoundResponseBody is the type of the "control-plane" service
// "inspect-host" endpoint HTTP response body for the "not_found" error.
type InspectHostNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RemoveHostClusterNotInitializedResponseBody is the type of the
// "control-plane" service "remove-host" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type RemoveHostClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RemoveHostNotFoundResponseBody is the type of the "control-plane" service
// "remove-host" endpoint HTTP response body for the "not_found" error.
type RemoveHostNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ListDatabasesClusterNotInitializedResponseBody is the type of the
// "control-plane" service "list-databases" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type ListDatabasesClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// CreateDatabaseDatabaseAlreadyExistsResponseBody is the type of the
// "control-plane" service "create-database" endpoint HTTP response body for
// the "database_already_exists" error.
type CreateDatabaseDatabaseAlreadyExistsResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// CreateDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "create-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type CreateDatabaseClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// CreateDatabaseInvalidInputResponseBody is the type of the "control-plane"
// service "create-database" endpoint HTTP response body for the
// "invalid_input" error.
type CreateDatabaseInvalidInputResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InspectDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "inspect-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type InspectDatabaseClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InspectDatabaseNotFoundResponseBody is the type of the "control-plane"
// service "inspect-database" endpoint HTTP response body for the "not_found"
// error.
type InspectDatabaseNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// UpdateDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "update-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type UpdateDatabaseClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// UpdateDatabaseDatabaseNotModifiableResponseBody is the type of the
// "control-plane" service "update-database" endpoint HTTP response body for
// the "database_not_modifiable" error.
type UpdateDatabaseDatabaseNotModifiableResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// UpdateDatabaseNotFoundResponseBody is the type of the "control-plane"
// service "update-database" endpoint HTTP response body for the "not_found"
// error.
type UpdateDatabaseNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DeleteDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "delete-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type DeleteDatabaseClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DeleteDatabaseDatabaseNotModifiableResponseBody is the type of the
// "control-plane" service "delete-database" endpoint HTTP response body for
// the "database_not_modifiable" error.
type DeleteDatabaseDatabaseNotModifiableResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DeleteDatabaseNotFoundResponseBody is the type of the "control-plane"
// service "delete-database" endpoint HTTP response body for the "not_found"
// error.
type DeleteDatabaseNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InitiateDatabaseBackupBackupAlreadyInProgressResponseBody is the type of the
// "control-plane" service "initiate-database-backup" endpoint HTTP response
// body for the "backup_already_in_progress" error.
type InitiateDatabaseBackupBackupAlreadyInProgressResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InitiateDatabaseBackupClusterNotInitializedResponseBody is the type of the
// "control-plane" service "initiate-database-backup" endpoint HTTP response
// body for the "cluster_not_initialized" error.
type InitiateDatabaseBackupClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InitiateDatabaseBackupDatabaseNotModifiableResponseBody is the type of the
// "control-plane" service "initiate-database-backup" endpoint HTTP response
// body for the "database_not_modifiable" error.
type InitiateDatabaseBackupDatabaseNotModifiableResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InitiateDatabaseBackupNotFoundResponseBody is the type of the
// "control-plane" service "initiate-database-backup" endpoint HTTP response
// body for the "not_found" error.
type InitiateDatabaseBackupNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ListDatabaseTasksClusterNotInitializedResponseBody is the type of the
// "control-plane" service "list-database-tasks" endpoint HTTP response body
// for the "cluster_not_initialized" error.
type ListDatabaseTasksClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ListDatabaseTasksNotFoundResponseBody is the type of the "control-plane"
// service "list-database-tasks" endpoint HTTP response body for the
// "not_found" error.
type ListDatabaseTasksNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InspectDatabaseTaskClusterNotInitializedResponseBody is the type of the
// "control-plane" service "inspect-database-task" endpoint HTTP response body
// for the "cluster_not_initialized" error.
type InspectDatabaseTaskClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// InspectDatabaseTaskNotFoundResponseBody is the type of the "control-plane"
// service "inspect-database-task" endpoint HTTP response body for the
// "not_found" error.
type InspectDatabaseTaskNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// GetDatabaseTaskLogClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-database-task-log" endpoint HTTP response body
// for the "cluster_not_initialized" error.
type GetDatabaseTaskLogClusterNotInitializedResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// GetDatabaseTaskLogNotFoundResponseBody is the type of the "control-plane"
// service "get-database-task-log" endpoint HTTP response body for the
// "not_found" error.
type GetDatabaseTaskLogNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ClusterPeerResponseBody is used to define fields on response body types.
type ClusterPeerResponseBody struct {
	// The name of the cluster member.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The Etcd peer endpoint for this cluster member.
	PeerURL *string `form:"peer_url,omitempty" json:"peer_url,omitempty" xml:"peer_url,omitempty"`
	// The Etcd client endpoint for this cluster member.
	ClientURL *string `form:"client_url,omitempty" json:"client_url,omitempty" xml:"client_url,omitempty"`
}

// ClusterCredentialsResponseBody is used to define fields on response body
// types.
type ClusterCredentialsResponseBody struct {
	// The base64-encoded CA certificate for the cluster.
	CaCert *string `form:"ca_cert,omitempty" json:"ca_cert,omitempty" xml:"ca_cert,omitempty"`
	// The base64-encoded etcd client certificate for the new cluster member.
	ClientCert *string `form:"client_cert,omitempty" json:"client_cert,omitempty" xml:"client_cert,omitempty"`
	// The base64-encoded etcd client key for the new cluster member.
	ClientKey *string `form:"client_key,omitempty" json:"client_key,omitempty" xml:"client_key,omitempty"`
	// The base64-encoded etcd server certificate for the new cluster member.
	ServerCert *string `form:"server_cert,omitempty" json:"server_cert,omitempty" xml:"server_cert,omitempty"`
	// The base64-encoded etcd server key for the new cluster member.
	ServerKey *string `form:"server_key,omitempty" json:"server_key,omitempty" xml:"server_key,omitempty"`
}

// ClusterStatusResponseBody is used to define fields on response body types.
type ClusterStatusResponseBody struct {
	// The current state of the cluster.
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
}

// HostResponseBody is used to define fields on response body types.
type HostResponseBody struct {
	// Unique identifier for the host.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The orchestrator used by this host.
	Orchestrator *string `form:"orchestrator,omitempty" json:"orchestrator,omitempty" xml:"orchestrator,omitempty"`
	// The cohort that this host belongs to/
	Cohort *HostCohortResponseBody `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of this host.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The number of CPUs on this host.
	Cpus *int `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory available on this host.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Current status of the host.
	Status *HostStatusResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersionResponseBody `form:"default_pgedge_version,omitempty" json:"default_pgedge_version,omitempty" xml:"default_pgedge_version,omitempty"`
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersionResponseBody `form:"supported_pgedge_versions,omitempty" json:"supported_pgedge_versions,omitempty" xml:"supported_pgedge_versions,omitempty"`
}

// HostCohortResponseBody is used to define fields on response body types.
type HostCohortResponseBody struct {
	// The type of cohort that the host belongs to.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cohort ID that the host belongs to.
	CohortID *string `form:"cohort_id,omitempty" json:"cohort_id,omitempty" xml:"cohort_id,omitempty"`
	// The member ID of the host within the cohort.
	MemberID *string `form:"member_id,omitempty" json:"member_id,omitempty" xml:"member_id,omitempty"`
	// Indicates if the host is a control node in the cohort.
	ControlAvailable *bool `form:"control_available,omitempty" json:"control_available,omitempty" xml:"control_available,omitempty"`
}

// HostStatusResponseBody is used to define fields on response body types.
type HostStatusResponseBody struct {
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The last time the host status was updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// The status of each component of the host.
	Components map[string]*ComponentStatusResponseBody `form:"components,omitempty" json:"components,omitempty" xml:"components,omitempty"`
}

// ComponentStatusResponseBody is used to define fields on response body types.
type ComponentStatusResponseBody struct {
	// Indicates if the component is healthy.
	Healthy *bool `form:"healthy,omitempty" json:"healthy,omitempty" xml:"healthy,omitempty"`
	// Error message from any errors that occurred during the health check.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
	// Additional details about the component.
	Details map[string]any `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
}

// PgEdgeVersionResponseBody is used to define fields on response body types.
type PgEdgeVersionResponseBody struct {
	// The Postgres major version.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The Spock major version.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
}

// HostResponse is used to define fields on response body types.
type HostResponse struct {
	// Unique identifier for the host.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The orchestrator used by this host.
	Orchestrator *string `form:"orchestrator,omitempty" json:"orchestrator,omitempty" xml:"orchestrator,omitempty"`
	// The cohort that this host belongs to/
	Cohort *HostCohortResponse `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of this host.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The number of CPUs on this host.
	Cpus *int `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory available on this host.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Current status of the host.
	Status *HostStatusResponse `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersionResponse `form:"default_pgedge_version,omitempty" json:"default_pgedge_version,omitempty" xml:"default_pgedge_version,omitempty"`
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersionResponse `form:"supported_pgedge_versions,omitempty" json:"supported_pgedge_versions,omitempty" xml:"supported_pgedge_versions,omitempty"`
}

// HostCohortResponse is used to define fields on response body types.
type HostCohortResponse struct {
	// The type of cohort that the host belongs to.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cohort ID that the host belongs to.
	CohortID *string `form:"cohort_id,omitempty" json:"cohort_id,omitempty" xml:"cohort_id,omitempty"`
	// The member ID of the host within the cohort.
	MemberID *string `form:"member_id,omitempty" json:"member_id,omitempty" xml:"member_id,omitempty"`
	// Indicates if the host is a control node in the cohort.
	ControlAvailable *bool `form:"control_available,omitempty" json:"control_available,omitempty" xml:"control_available,omitempty"`
}

// HostStatusResponse is used to define fields on response body types.
type HostStatusResponse struct {
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The last time the host status was updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// The status of each component of the host.
	Components map[string]*ComponentStatusResponse `form:"components,omitempty" json:"components,omitempty" xml:"components,omitempty"`
}

// ComponentStatusResponse is used to define fields on response body types.
type ComponentStatusResponse struct {
	// Indicates if the component is healthy.
	Healthy *bool `form:"healthy,omitempty" json:"healthy,omitempty" xml:"healthy,omitempty"`
	// Error message from any errors that occurred during the health check.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
	// Additional details about the component.
	Details map[string]any `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
}

// PgEdgeVersionResponse is used to define fields on response body types.
type PgEdgeVersionResponse struct {
	// The Postgres major version.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The Spock major version.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
}

// DatabaseResponse is used to define fields on response body types.
type DatabaseResponse struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the database was last updated.
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Current state of the database.
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// All of the instances in the database.
	Instances InstanceCollectionResponse `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponse `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InstanceCollectionResponse is used to define fields on response body types.
type InstanceCollectionResponse []*InstanceResponse

// InstanceResponse is used to define fields on response body types.
type InstanceResponse struct {
	// Unique identifier for the instance.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The ID of the host this instance is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The Spock node name for this instance.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The time that the instance was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time that the instance was last updated.
	UpdatedAt    *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	State        *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	PatroniState *string `form:"patroni_state,omitempty" json:"patroni_state,omitempty" xml:"patroni_state,omitempty"`
	Role         *string `form:"role,omitempty" json:"role,omitempty" xml:"role,omitempty"`
	// True if this instance is in read-only mode.
	ReadOnly *bool `form:"read_only,omitempty" json:"read_only,omitempty" xml:"read_only,omitempty"`
	// True if this instance is pending to be restarted from a configuration change.
	PendingRestart *bool `form:"pending_restart,omitempty" json:"pending_restart,omitempty" xml:"pending_restart,omitempty"`
	// True if Patroni has been paused for this instance.
	PatroniPaused *bool `form:"patroni_paused,omitempty" json:"patroni_paused,omitempty" xml:"patroni_paused,omitempty"`
	// The version of Postgres for this instance.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The version of Spock for this instance.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// All interfaces that this instance serves on.
	Interfaces []*InstanceInterfaceResponse `form:"interfaces,omitempty" json:"interfaces,omitempty" xml:"interfaces,omitempty"`
}

// InstanceInterfaceResponse is used to define fields on response body types.
type InstanceInterfaceResponse struct {
	// The type of network for this interface.
	NetworkType *string `form:"network_type,omitempty" json:"network_type,omitempty" xml:"network_type,omitempty"`
	// The unique identifier of the network for this interface.
	NetworkID *string `form:"network_id,omitempty" json:"network_id,omitempty" xml:"network_id,omitempty"`
	// The hostname of the instance on this interface.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of the instance on this interface.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The Postgres port for the instance on this interface.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
}

// DatabaseSpecResponse is used to define fields on response body types.
type DatabaseSpecResponse struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The storage class to use for the database. The possible values and defaults
	// depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage in SI or IEC notation. Support for this value
	// depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will be
	// enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit will be enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecResponse `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecResponse `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecResponse `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecResponse `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecResponse is used to define fields on response body types.
type DatabaseNodeSpecResponse struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary and the others will be read
	// replicas.
	HostIds []string `form:"host_ids,omitempty" json:"host_ids,omitempty" xml:"host_ids,omitempty"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The storage class to use for the database on this node. The possible values
	// and defaults depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage for this node in SI or IEC notation. Support for
	// this value depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. Defaults to the number of available CPUs on the host. Can
	// include an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will
	// be enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit will be enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecResponse `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
}

// BackupConfigSpecResponse is used to define fields on response body types.
type BackupConfigSpecResponse struct {
	// The backup provider for this backup configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecResponse `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecResponse `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecResponse is used to define fields on response body types.
type BackupRepositorySpecResponse struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecResponse is used to define fields on response body types.
type BackupScheduleSpecResponse struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// DatabaseUserSpecResponse is used to define fields on response body types.
type DatabaseUserSpecResponse struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// RestoreConfigSpecResponse is used to define fields on response body types.
type RestoreConfigSpecResponse struct {
	// The backup provider for this restore configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The ID of the database to restore this database from.
	DatabaseID *string `form:"database_id,omitempty" json:"database_id,omitempty" xml:"database_id,omitempty"`
	// The name of the node to restore this database from.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The name of the database in this repository. This database will be renamed
	// to the database_name in the DatabaseSpec.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecResponse `form:"repository,omitempty" json:"repository,omitempty" xml:"repository,omitempty"`
}

// RestoreRepositorySpecResponse is used to define fields on response body
// types.
type RestoreRepositorySpecResponse struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The base path within the repository where backups are stored.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// DatabaseSpecRequestBody is used to define fields on request body types.
type DatabaseSpecRequestBody struct {
	// The name of the Postgres database.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The storage class to use for the database. The possible values and defaults
	// depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage in SI or IEC notation. Support for this value
	// depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will be
	// enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit will be enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBody `form:"nodes" json:"nodes" xml:"nodes"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecRequestBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecRequestBody is used to define fields on request body types.
type DatabaseNodeSpecRequestBody struct {
	// The name of the database node.
	Name string `form:"name" json:"name" xml:"name"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary and the others will be read
	// replicas.
	HostIds []string `form:"host_ids" json:"host_ids" xml:"host_ids"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The storage class to use for the database on this node. The possible values
	// and defaults depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage for this node in SI or IEC notation. Support for
	// this value depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. Defaults to the number of available CPUs on the host. Can
	// include an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will
	// be enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit will be enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
}

// BackupConfigSpecRequestBody is used to define fields on request body types.
type BackupConfigSpecRequestBody struct {
	// The backup provider for this backup configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBody is used to define fields on request body
// types.
type BackupRepositorySpecRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecRequestBody is used to define fields on request body types.
type BackupScheduleSpecRequestBody struct {
	// The unique identifier for this backup schedule.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of backup to take on this schedule.
	Type string `form:"type" json:"type" xml:"type"`
	// The cron expression for this schedule.
	CronExpression string `form:"cron_expression" json:"cron_expression" xml:"cron_expression"`
}

// DatabaseUserSpecRequestBody is used to define fields on request body types.
type DatabaseUserSpecRequestBody struct {
	// The username for this database user.
	Username string `form:"username" json:"username" xml:"username"`
	// The password for this database user.
	Password string `form:"password" json:"password" xml:"password"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// RestoreConfigSpecRequestBody is used to define fields on request body types.
type RestoreConfigSpecRequestBody struct {
	// The backup provider for this restore configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The ID of the database to restore this database from.
	DatabaseID string `form:"database_id" json:"database_id" xml:"database_id"`
	// The name of the node to restore this database from.
	NodeName string `form:"node_name" json:"node_name" xml:"node_name"`
	// The name of the database in this repository. This database will be renamed
	// to the database_name in the DatabaseSpec.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecRequestBody `form:"repository" json:"repository" xml:"repository"`
}

// RestoreRepositorySpecRequestBody is used to define fields on request body
// types.
type RestoreRepositorySpecRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The base path within the repository where backups are stored.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// InstanceResponseBodyAbbreviatedCollection is used to define fields on
// response body types.
type InstanceResponseBodyAbbreviatedCollection []*InstanceResponseBodyAbbreviated

// InstanceResponseBodyAbbreviated is used to define fields on response body
// types.
type InstanceResponseBodyAbbreviated struct {
	// Unique identifier for the instance.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The ID of the host this instance is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The Spock node name for this instance.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	State    *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
}

// DatabaseSpecResponseBody is used to define fields on response body types.
type DatabaseSpecResponseBody struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The storage class to use for the database. The possible values and defaults
	// depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage in SI or IEC notation. Support for this value
	// depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will be
	// enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit will be enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecResponseBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecResponseBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecResponseBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecResponseBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecResponseBody is used to define fields on response body types.
type DatabaseNodeSpecResponseBody struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary and the others will be read
	// replicas.
	HostIds []string `form:"host_ids,omitempty" json:"host_ids,omitempty" xml:"host_ids,omitempty"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The storage class to use for the database on this node. The possible values
	// and defaults depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage for this node in SI or IEC notation. Support for
	// this value depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. Defaults to the number of available CPUs on the host. Can
	// include an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will
	// be enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit will be enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecResponseBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
}

// BackupConfigSpecResponseBody is used to define fields on response body types.
type BackupConfigSpecResponseBody struct {
	// The backup provider for this backup configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecResponseBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecResponseBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecResponseBody is used to define fields on response body
// types.
type BackupRepositorySpecResponseBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecResponseBody is used to define fields on response body
// types.
type BackupScheduleSpecResponseBody struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// DatabaseUserSpecResponseBody is used to define fields on response body types.
type DatabaseUserSpecResponseBody struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// RestoreConfigSpecResponseBody is used to define fields on response body
// types.
type RestoreConfigSpecResponseBody struct {
	// The backup provider for this restore configuration.
	Provider *string `form:"provider,omitempty" json:"provider,omitempty" xml:"provider,omitempty"`
	// The ID of the database to restore this database from.
	DatabaseID *string `form:"database_id,omitempty" json:"database_id,omitempty" xml:"database_id,omitempty"`
	// The name of the node to restore this database from.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The name of the database in this repository. This database will be renamed
	// to the database_name in the DatabaseSpec.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecResponseBody `form:"repository,omitempty" json:"repository,omitempty" xml:"repository,omitempty"`
}

// RestoreRepositorySpecResponseBody is used to define fields on response body
// types.
type RestoreRepositorySpecResponseBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The base path within the repository where backups are stored.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// DatabaseSpecRequestBodyRequestBody is used to define fields on request body
// types.
type DatabaseSpecRequestBodyRequestBody struct {
	// The name of the Postgres database.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The major version of the Postgres database.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// Prevents deletion when true.
	DeletionProtection *bool `form:"deletion_protection,omitempty" json:"deletion_protection,omitempty" xml:"deletion_protection,omitempty"`
	// The storage class to use for the database. The possible values and defaults
	// depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage in SI or IEC notation. Support for this value
	// depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will be
	// enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit will be enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBodyRequestBody `form:"nodes" json:"nodes" xml:"nodes"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBodyRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The feature flags for this database.
	Features map[string]string `form:"features,omitempty" json:"features,omitempty" xml:"features,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecRequestBodyRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecRequestBodyRequestBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
}

// DatabaseNodeSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseNodeSpecRequestBodyRequestBody struct {
	// The name of the database node.
	Name string `form:"name" json:"name" xml:"name"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary and the others will be read
	// replicas.
	HostIds []string `form:"host_ids" json:"host_ids" xml:"host_ids"`
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The storage class to use for the database on this node. The possible values
	// and defaults depend on the orchestrator.
	StorageClass *string `form:"storage_class,omitempty" json:"storage_class,omitempty" xml:"storage_class,omitempty"`
	// The size of the storage for this node in SI or IEC notation. Support for
	// this value depends on the orchestrator and storage class.
	StorageSize *string `form:"storage_size,omitempty" json:"storage_size,omitempty" xml:"storage_size,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. Defaults to the number of available CPUs on the host. Can
	// include an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will
	// be enforced depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit will be enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecRequestBodyRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
}

// BackupConfigSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupConfigSpecRequestBodyRequestBody struct {
	// The backup provider for this backup configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBodyRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBodyRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBodyRequestBody is used to define fields on
// request body types.
type BackupRepositorySpecRequestBodyRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupScheduleSpecRequestBodyRequestBody struct {
	// The unique identifier for this backup schedule.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of backup to take on this schedule.
	Type string `form:"type" json:"type" xml:"type"`
	// The cron expression for this schedule.
	CronExpression string `form:"cron_expression" json:"cron_expression" xml:"cron_expression"`
}

// DatabaseUserSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseUserSpecRequestBodyRequestBody struct {
	// The username for this database user.
	Username string `form:"username" json:"username" xml:"username"`
	// The password for this database user.
	Password string `form:"password" json:"password" xml:"password"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// RestoreConfigSpecRequestBodyRequestBody is used to define fields on request
// body types.
type RestoreConfigSpecRequestBodyRequestBody struct {
	// The backup provider for this restore configuration.
	Provider string `form:"provider" json:"provider" xml:"provider"`
	// The ID of the database to restore this database from.
	DatabaseID string `form:"database_id" json:"database_id" xml:"database_id"`
	// The name of the node to restore this database from.
	NodeName string `form:"node_name" json:"node_name" xml:"node_name"`
	// The name of the database in this repository. This database will be renamed
	// to the database_name in the DatabaseSpec.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecRequestBodyRequestBody `form:"repository" json:"repository" xml:"repository"`
}

// RestoreRepositorySpecRequestBodyRequestBody is used to define fields on
// request body types.
type RestoreRepositorySpecRequestBodyRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The base path within the repository where backups are stored.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// TaskResponse is used to define fields on response body types.
type TaskResponse struct {
	// The database ID of the task.
	DatabaseID *string `form:"database_id,omitempty" json:"database_id,omitempty" xml:"database_id,omitempty"`
	// The unique ID of the task.
	TaskID *string `form:"task_id,omitempty" json:"task_id,omitempty" xml:"task_id,omitempty"`
	// The time when the task was created.
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The time when the task was completed.
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
	// The type of the task.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The status of the task.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// The error message if the task failed.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// NewJoinClusterRequestBody builds the HTTP request body from the payload of
// the "join-cluster" endpoint of the "control-plane" service.
func NewJoinClusterRequestBody(p *controlplane.ClusterJoinToken) *JoinClusterRequestBody {
	body := &JoinClusterRequestBody{
		Token:     p.Token,
		ServerURL: p.ServerURL,
	}
	return body
}

// NewGetJoinOptionsRequestBody builds the HTTP request body from the payload
// of the "get-join-options" endpoint of the "control-plane" service.
func NewGetJoinOptionsRequestBody(p *controlplane.ClusterJoinRequest) *GetJoinOptionsRequestBody {
	body := &GetJoinOptionsRequestBody{
		Token:       p.Token,
		HostID:      p.HostID,
		Hostname:    p.Hostname,
		Ipv4Address: p.Ipv4Address,
	}
	return body
}

// NewCreateDatabaseRequestBody builds the HTTP request body from the payload
// of the "create-database" endpoint of the "control-plane" service.
func NewCreateDatabaseRequestBody(p *controlplane.CreateDatabaseRequest) *CreateDatabaseRequestBody {
	body := &CreateDatabaseRequestBody{
		ID:       p.ID,
		TenantID: p.TenantID,
	}
	if p.Spec != nil {
		body.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecRequestBody(p.Spec)
	}
	return body
}

// NewUpdateDatabaseRequestBody builds the HTTP request body from the payload
// of the "update-database" endpoint of the "control-plane" service.
func NewUpdateDatabaseRequestBody(p *controlplane.UpdateDatabasePayload) *UpdateDatabaseRequestBody {
	body := &UpdateDatabaseRequestBody{
		TenantID: p.Request.TenantID,
	}
	if p.Request.Spec != nil {
		body.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecRequestBodyRequestBody(p.Request.Spec)
	}
	return body
}

// NewInitiateDatabaseBackupRequestBody builds the HTTP request body from the
// payload of the "initiate-database-backup" endpoint of the "control-plane"
// service.
func NewInitiateDatabaseBackupRequestBody(p *controlplane.InitiateDatabaseBackupPayload) *InitiateDatabaseBackupRequestBody {
	body := &InitiateDatabaseBackupRequestBody{
		Type: p.Options.Type,
	}
	if p.Options.Annotations != nil {
		body.Annotations = make(map[string]string, len(p.Options.Annotations))
		for key, val := range p.Options.Annotations {
			tk := key
			tv := val
			body.Annotations[tk] = tv
		}
	}
	if p.Options.ExtraOptions != nil {
		body.ExtraOptions = make([]string, len(p.Options.ExtraOptions))
		for i, val := range p.Options.ExtraOptions {
			body.ExtraOptions[i] = val
		}
	}
	return body
}

// NewInitClusterClusterJoinTokenOK builds a "control-plane" service
// "init-cluster" endpoint result from a HTTP "OK" response.
func NewInitClusterClusterJoinTokenOK(body *InitClusterResponseBody) *controlplane.ClusterJoinToken {
	v := &controlplane.ClusterJoinToken{
		Token:     *body.Token,
		ServerURL: *body.ServerURL,
	}

	return v
}

// NewInitClusterClusterAlreadyInitialized builds a control-plane service
// init-cluster endpoint cluster_already_initialized error.
func NewInitClusterClusterAlreadyInitialized(body *InitClusterClusterAlreadyInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewJoinClusterClusterAlreadyInitialized builds a control-plane service
// join-cluster endpoint cluster_already_initialized error.
func NewJoinClusterClusterAlreadyInitialized(body *JoinClusterClusterAlreadyInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewGetJoinTokenClusterJoinTokenOK builds a "control-plane" service
// "get-join-token" endpoint result from a HTTP "OK" response.
func NewGetJoinTokenClusterJoinTokenOK(body *GetJoinTokenResponseBody) *controlplane.ClusterJoinToken {
	v := &controlplane.ClusterJoinToken{
		Token:     *body.Token,
		ServerURL: *body.ServerURL,
	}

	return v
}

// NewGetJoinTokenClusterNotInitialized builds a control-plane service
// get-join-token endpoint cluster_not_initialized error.
func NewGetJoinTokenClusterNotInitialized(body *GetJoinTokenClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewGetJoinOptionsClusterJoinOptionsOK builds a "control-plane" service
// "get-join-options" endpoint result from a HTTP "OK" response.
func NewGetJoinOptionsClusterJoinOptionsOK(body *GetJoinOptionsResponseBody) *controlplane.ClusterJoinOptions {
	v := &controlplane.ClusterJoinOptions{}
	v.Peer = unmarshalClusterPeerResponseBodyToControlplaneClusterPeer(body.Peer)
	if body.Credentials != nil {
		v.Credentials = unmarshalClusterCredentialsResponseBodyToControlplaneClusterCredentials(body.Credentials)
	}

	return v
}

// NewGetJoinOptionsClusterNotInitialized builds a control-plane service
// get-join-options endpoint cluster_not_initialized error.
func NewGetJoinOptionsClusterNotInitialized(body *GetJoinOptionsClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewGetJoinOptionsInvalidJoinToken builds a control-plane service
// get-join-options endpoint invalid_join_token error.
func NewGetJoinOptionsInvalidJoinToken(body *GetJoinOptionsInvalidJoinTokenResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInspectClusterClusterOK builds a "control-plane" service
// "inspect-cluster" endpoint result from a HTTP "OK" response.
func NewInspectClusterClusterOK(body *InspectClusterResponseBody) *controlplane.Cluster {
	v := &controlplane.Cluster{
		ID:       *body.ID,
		TenantID: *body.TenantID,
	}
	v.Status = unmarshalClusterStatusResponseBodyToControlplaneClusterStatus(body.Status)
	v.Hosts = make([]*controlplane.Host, len(body.Hosts))
	for i, val := range body.Hosts {
		v.Hosts[i] = unmarshalHostResponseBodyToControlplaneHost(val)
	}

	return v
}

// NewInspectClusterClusterNotInitialized builds a control-plane service
// inspect-cluster endpoint cluster_not_initialized error.
func NewInspectClusterClusterNotInitialized(body *InspectClusterClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInspectClusterNotFound builds a control-plane service inspect-cluster
// endpoint not_found error.
func NewInspectClusterNotFound(body *InspectClusterNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewListHostsHostOK builds a "control-plane" service "list-hosts" endpoint
// result from a HTTP "OK" response.
func NewListHostsHostOK(body []*HostResponse) []*controlplane.Host {
	v := make([]*controlplane.Host, len(body))
	for i, val := range body {
		v[i] = unmarshalHostResponseToControlplaneHost(val)
	}

	return v
}

// NewListHostsClusterNotInitialized builds a control-plane service list-hosts
// endpoint cluster_not_initialized error.
func NewListHostsClusterNotInitialized(body *ListHostsClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInspectHostHostOK builds a "control-plane" service "inspect-host"
// endpoint result from a HTTP "OK" response.
func NewInspectHostHostOK(body *InspectHostResponseBody) *controlplane.Host {
	v := &controlplane.Host{
		ID:           *body.ID,
		Orchestrator: *body.Orchestrator,
		Hostname:     *body.Hostname,
		Ipv4Address:  *body.Ipv4Address,
		Cpus:         *body.Cpus,
		Memory:       *body.Memory,
	}
	if body.Cohort != nil {
		v.Cohort = unmarshalHostCohortResponseBodyToControlplaneHostCohort(body.Cohort)
	}
	v.Status = unmarshalHostStatusResponseBodyToControlplaneHostStatus(body.Status)
	v.DefaultPgedgeVersion = unmarshalPgEdgeVersionResponseBodyToControlplanePgEdgeVersion(body.DefaultPgedgeVersion)
	v.SupportedPgedgeVersions = make([]*controlplane.PgEdgeVersion, len(body.SupportedPgedgeVersions))
	for i, val := range body.SupportedPgedgeVersions {
		v.SupportedPgedgeVersions[i] = unmarshalPgEdgeVersionResponseBodyToControlplanePgEdgeVersion(val)
	}

	return v
}

// NewInspectHostClusterNotInitialized builds a control-plane service
// inspect-host endpoint cluster_not_initialized error.
func NewInspectHostClusterNotInitialized(body *InspectHostClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInspectHostNotFound builds a control-plane service inspect-host endpoint
// not_found error.
func NewInspectHostNotFound(body *InspectHostNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRemoveHostClusterNotInitialized builds a control-plane service
// remove-host endpoint cluster_not_initialized error.
func NewRemoveHostClusterNotInitialized(body *RemoveHostClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRemoveHostNotFound builds a control-plane service remove-host endpoint
// not_found error.
func NewRemoveHostNotFound(body *RemoveHostNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewListDatabasesDatabaseCollectionOK builds a "control-plane" service
// "list-databases" endpoint result from a HTTP "OK" response.
func NewListDatabasesDatabaseCollectionOK(body ListDatabasesResponseBody) controlplaneviews.DatabaseCollectionView {
	v := make([]*controlplaneviews.DatabaseView, len(body))
	for i, val := range body {
		v[i] = unmarshalDatabaseResponseToControlplaneviewsDatabaseView(val)
	}

	return v
}

// NewListDatabasesClusterNotInitialized builds a control-plane service
// list-databases endpoint cluster_not_initialized error.
func NewListDatabasesClusterNotInitialized(body *ListDatabasesClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewCreateDatabaseDatabaseOK builds a "control-plane" service
// "create-database" endpoint result from a HTTP "OK" response.
func NewCreateDatabaseDatabaseOK(body *CreateDatabaseResponseBody) *controlplaneviews.DatabaseView {
	v := &controlplaneviews.DatabaseView{
		ID:        body.ID,
		TenantID:  body.TenantID,
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
		State:     body.State,
	}
	if body.Instances != nil {
		v.Instances = make([]*controlplaneviews.InstanceView, len(body.Instances))
		for i, val := range body.Instances {
			v.Instances[i] = unmarshalInstanceResponseBodyAbbreviatedToControlplaneviewsInstanceView(val)
		}
	}
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecResponseBodyToControlplaneviewsDatabaseSpecView(body.Spec)
	}

	return v
}

// NewCreateDatabaseDatabaseAlreadyExists builds a control-plane service
// create-database endpoint database_already_exists error.
func NewCreateDatabaseDatabaseAlreadyExists(body *CreateDatabaseDatabaseAlreadyExistsResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewCreateDatabaseClusterNotInitialized builds a control-plane service
// create-database endpoint cluster_not_initialized error.
func NewCreateDatabaseClusterNotInitialized(body *CreateDatabaseClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewCreateDatabaseInvalidInput builds a control-plane service create-database
// endpoint invalid_input error.
func NewCreateDatabaseInvalidInput(body *CreateDatabaseInvalidInputResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInspectDatabaseDatabaseOK builds a "control-plane" service
// "inspect-database" endpoint result from a HTTP "OK" response.
func NewInspectDatabaseDatabaseOK(body *InspectDatabaseResponseBody) *controlplaneviews.DatabaseView {
	v := &controlplaneviews.DatabaseView{
		ID:        body.ID,
		TenantID:  body.TenantID,
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
		State:     body.State,
	}
	if body.Instances != nil {
		v.Instances = make([]*controlplaneviews.InstanceView, len(body.Instances))
		for i, val := range body.Instances {
			v.Instances[i] = unmarshalInstanceResponseBodyAbbreviatedToControlplaneviewsInstanceView(val)
		}
	}
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecResponseBodyToControlplaneviewsDatabaseSpecView(body.Spec)
	}

	return v
}

// NewInspectDatabaseClusterNotInitialized builds a control-plane service
// inspect-database endpoint cluster_not_initialized error.
func NewInspectDatabaseClusterNotInitialized(body *InspectDatabaseClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInspectDatabaseNotFound builds a control-plane service inspect-database
// endpoint not_found error.
func NewInspectDatabaseNotFound(body *InspectDatabaseNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewUpdateDatabaseDatabaseOK builds a "control-plane" service
// "update-database" endpoint result from a HTTP "OK" response.
func NewUpdateDatabaseDatabaseOK(body *UpdateDatabaseResponseBody) *controlplaneviews.DatabaseView {
	v := &controlplaneviews.DatabaseView{
		ID:        body.ID,
		TenantID:  body.TenantID,
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
		State:     body.State,
	}
	if body.Instances != nil {
		v.Instances = make([]*controlplaneviews.InstanceView, len(body.Instances))
		for i, val := range body.Instances {
			v.Instances[i] = unmarshalInstanceResponseBodyAbbreviatedToControlplaneviewsInstanceView(val)
		}
	}
	if body.Spec != nil {
		v.Spec = unmarshalDatabaseSpecResponseBodyToControlplaneviewsDatabaseSpecView(body.Spec)
	}

	return v
}

// NewUpdateDatabaseClusterNotInitialized builds a control-plane service
// update-database endpoint cluster_not_initialized error.
func NewUpdateDatabaseClusterNotInitialized(body *UpdateDatabaseClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewUpdateDatabaseDatabaseNotModifiable builds a control-plane service
// update-database endpoint database_not_modifiable error.
func NewUpdateDatabaseDatabaseNotModifiable(body *UpdateDatabaseDatabaseNotModifiableResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewUpdateDatabaseNotFound builds a control-plane service update-database
// endpoint not_found error.
func NewUpdateDatabaseNotFound(body *UpdateDatabaseNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDeleteDatabaseClusterNotInitialized builds a control-plane service
// delete-database endpoint cluster_not_initialized error.
func NewDeleteDatabaseClusterNotInitialized(body *DeleteDatabaseClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDeleteDatabaseDatabaseNotModifiable builds a control-plane service
// delete-database endpoint database_not_modifiable error.
func NewDeleteDatabaseDatabaseNotModifiable(body *DeleteDatabaseDatabaseNotModifiableResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDeleteDatabaseNotFound builds a control-plane service delete-database
// endpoint not_found error.
func NewDeleteDatabaseNotFound(body *DeleteDatabaseNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInitiateDatabaseBackupTaskOK builds a "control-plane" service
// "initiate-database-backup" endpoint result from a HTTP "OK" response.
func NewInitiateDatabaseBackupTaskOK(body *InitiateDatabaseBackupResponseBody) *controlplane.Task {
	v := &controlplane.Task{
		DatabaseID:  *body.DatabaseID,
		TaskID:      *body.TaskID,
		CreatedAt:   *body.CreatedAt,
		CompletedAt: body.CompletedAt,
		Type:        *body.Type,
		Status:      *body.Status,
		Error:       body.Error,
	}

	return v
}

// NewInitiateDatabaseBackupBackupAlreadyInProgress builds a control-plane
// service initiate-database-backup endpoint backup_already_in_progress error.
func NewInitiateDatabaseBackupBackupAlreadyInProgress(body *InitiateDatabaseBackupBackupAlreadyInProgressResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInitiateDatabaseBackupClusterNotInitialized builds a control-plane
// service initiate-database-backup endpoint cluster_not_initialized error.
func NewInitiateDatabaseBackupClusterNotInitialized(body *InitiateDatabaseBackupClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInitiateDatabaseBackupDatabaseNotModifiable builds a control-plane
// service initiate-database-backup endpoint database_not_modifiable error.
func NewInitiateDatabaseBackupDatabaseNotModifiable(body *InitiateDatabaseBackupDatabaseNotModifiableResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInitiateDatabaseBackupNotFound builds a control-plane service
// initiate-database-backup endpoint not_found error.
func NewInitiateDatabaseBackupNotFound(body *InitiateDatabaseBackupNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewListDatabaseTasksTaskOK builds a "control-plane" service
// "list-database-tasks" endpoint result from a HTTP "OK" response.
func NewListDatabaseTasksTaskOK(body []*TaskResponse) []*controlplane.Task {
	v := make([]*controlplane.Task, len(body))
	for i, val := range body {
		v[i] = unmarshalTaskResponseToControlplaneTask(val)
	}

	return v
}

// NewListDatabaseTasksClusterNotInitialized builds a control-plane service
// list-database-tasks endpoint cluster_not_initialized error.
func NewListDatabaseTasksClusterNotInitialized(body *ListDatabaseTasksClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewListDatabaseTasksNotFound builds a control-plane service
// list-database-tasks endpoint not_found error.
func NewListDatabaseTasksNotFound(body *ListDatabaseTasksNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInspectDatabaseTaskTaskOK builds a "control-plane" service
// "inspect-database-task" endpoint result from a HTTP "OK" response.
func NewInspectDatabaseTaskTaskOK(body *InspectDatabaseTaskResponseBody) *controlplane.Task {
	v := &controlplane.Task{
		DatabaseID:  *body.DatabaseID,
		TaskID:      *body.TaskID,
		CreatedAt:   *body.CreatedAt,
		CompletedAt: body.CompletedAt,
		Type:        *body.Type,
		Status:      *body.Status,
		Error:       body.Error,
	}

	return v
}

// NewInspectDatabaseTaskClusterNotInitialized builds a control-plane service
// inspect-database-task endpoint cluster_not_initialized error.
func NewInspectDatabaseTaskClusterNotInitialized(body *InspectDatabaseTaskClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewInspectDatabaseTaskNotFound builds a control-plane service
// inspect-database-task endpoint not_found error.
func NewInspectDatabaseTaskNotFound(body *InspectDatabaseTaskNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewGetDatabaseTaskLogTaskLogOK builds a "control-plane" service
// "get-database-task-log" endpoint result from a HTTP "OK" response.
func NewGetDatabaseTaskLogTaskLogOK(body *GetDatabaseTaskLogResponseBody) *controlplane.TaskLog {
	v := &controlplane.TaskLog{
		DatabaseID: *body.DatabaseID,
		TaskID:     *body.TaskID,
		TaskStatus: *body.TaskStatus,
		LastLineID: body.LastLineID,
	}
	v.Lines = make([]string, len(body.Lines))
	for i, val := range body.Lines {
		v.Lines[i] = val
	}

	return v
}

// NewGetDatabaseTaskLogClusterNotInitialized builds a control-plane service
// get-database-task-log endpoint cluster_not_initialized error.
func NewGetDatabaseTaskLogClusterNotInitialized(body *GetDatabaseTaskLogClusterNotInitializedResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewGetDatabaseTaskLogNotFound builds a control-plane service
// get-database-task-log endpoint not_found error.
func NewGetDatabaseTaskLogNotFound(body *GetDatabaseTaskLogNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// ValidateInitClusterResponseBody runs the validations defined on
// Init-ClusterResponseBody
func ValidateInitClusterResponseBody(body *InitClusterResponseBody) (err error) {
	if body.Token == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("token", "body"))
	}
	if body.ServerURL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("server_url", "body"))
	}
	if body.ServerURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.server_url", *body.ServerURL, goa.FormatURI))
	}
	return
}

// ValidateGetJoinTokenResponseBody runs the validations defined on
// Get-Join-TokenResponseBody
func ValidateGetJoinTokenResponseBody(body *GetJoinTokenResponseBody) (err error) {
	if body.Token == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("token", "body"))
	}
	if body.ServerURL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("server_url", "body"))
	}
	if body.ServerURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.server_url", *body.ServerURL, goa.FormatURI))
	}
	return
}

// ValidateGetJoinOptionsResponseBody runs the validations defined on
// Get-Join-OptionsResponseBody
func ValidateGetJoinOptionsResponseBody(body *GetJoinOptionsResponseBody) (err error) {
	if body.Peer == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("peer", "body"))
	}
	if body.Peer != nil {
		if err2 := ValidateClusterPeerResponseBody(body.Peer); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Credentials != nil {
		if err2 := ValidateClusterCredentialsResponseBody(body.Credentials); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateInspectClusterResponseBody runs the validations defined on
// Inspect-ClusterResponseBody
func ValidateInspectClusterResponseBody(body *InspectClusterResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.TenantID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("tenant_id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Hosts == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hosts", "body"))
	}
	if body.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", *body.ID, goa.FormatUUID))
	}
	if body.TenantID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.tenant_id", *body.TenantID, goa.FormatUUID))
	}
	if body.Status != nil {
		if err2 := ValidateClusterStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Hosts {
		if e != nil {
			if err2 := ValidateHostResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInspectHostResponseBody runs the validations defined on
// Inspect-HostResponseBody
func ValidateInspectHostResponseBody(body *InspectHostResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Orchestrator == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("orchestrator", "body"))
	}
	if body.Hostname == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hostname", "body"))
	}
	if body.Ipv4Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ipv4_address", "body"))
	}
	if body.Cpus == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cpus", "body"))
	}
	if body.Memory == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("memory", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.DefaultPgedgeVersion == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("default_pgedge_version", "body"))
	}
	if body.SupportedPgedgeVersions == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("supported_pgedge_versions", "body"))
	}
	if body.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", *body.ID, goa.FormatUUID))
	}
	if body.Cohort != nil {
		if err2 := ValidateHostCohortResponseBody(body.Cohort); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	if body.Status != nil {
		if err2 := ValidateHostStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.DefaultPgedgeVersion != nil {
		if err2 := ValidatePgEdgeVersionResponseBody(body.DefaultPgedgeVersion); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.SupportedPgedgeVersions {
		if e != nil {
			if err2 := ValidatePgEdgeVersionResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInitiateDatabaseBackupResponseBody runs the validations defined on
// Initiate-Database-BackupResponseBody
func ValidateInitiateDatabaseBackupResponseBody(body *InitiateDatabaseBackupResponseBody) (err error) {
	if body.DatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_id", "body"))
	}
	if body.TaskID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task_id", "body"))
	}
	if body.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.CompletedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.completed_at", *body.CompletedAt, goa.FormatDateTime))
	}
	if body.Status != nil {
		if !(*body.Status == "pending" || *body.Status == "running" || *body.Status == "completed" || *body.Status == "failed" || *body.Status == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"pending", "running", "completed", "failed", "unknown"}))
		}
	}
	return
}

// ValidateInspectDatabaseTaskResponseBody runs the validations defined on
// Inspect-Database-TaskResponseBody
func ValidateInspectDatabaseTaskResponseBody(body *InspectDatabaseTaskResponseBody) (err error) {
	if body.DatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_id", "body"))
	}
	if body.TaskID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task_id", "body"))
	}
	if body.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.CompletedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.completed_at", *body.CompletedAt, goa.FormatDateTime))
	}
	if body.Status != nil {
		if !(*body.Status == "pending" || *body.Status == "running" || *body.Status == "completed" || *body.Status == "failed" || *body.Status == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"pending", "running", "completed", "failed", "unknown"}))
		}
	}
	return
}

// ValidateGetDatabaseTaskLogResponseBody runs the validations defined on
// Get-Database-Task-LogResponseBody
func ValidateGetDatabaseTaskLogResponseBody(body *GetDatabaseTaskLogResponseBody) (err error) {
	if body.DatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_id", "body"))
	}
	if body.TaskID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task_id", "body"))
	}
	if body.TaskStatus == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task_status", "body"))
	}
	if body.Lines == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("lines", "body"))
	}
	if body.TaskStatus != nil {
		if !(*body.TaskStatus == "pending" || *body.TaskStatus == "running" || *body.TaskStatus == "completed" || *body.TaskStatus == "failed" || *body.TaskStatus == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.task_status", *body.TaskStatus, []any{"pending", "running", "completed", "failed", "unknown"}))
		}
	}
	return
}

// ValidateInitClusterClusterAlreadyInitializedResponseBody runs the
// validations defined on init-cluster_cluster_already_initialized_response_body
func ValidateInitClusterClusterAlreadyInitializedResponseBody(body *InitClusterClusterAlreadyInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateJoinClusterClusterAlreadyInitializedResponseBody runs the
// validations defined on join-cluster_cluster_already_initialized_response_body
func ValidateJoinClusterClusterAlreadyInitializedResponseBody(body *JoinClusterClusterAlreadyInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateGetJoinTokenClusterNotInitializedResponseBody runs the validations
// defined on get-join-token_cluster_not_initialized_response_body
func ValidateGetJoinTokenClusterNotInitializedResponseBody(body *GetJoinTokenClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateGetJoinOptionsClusterNotInitializedResponseBody runs the validations
// defined on get-join-options_cluster_not_initialized_response_body
func ValidateGetJoinOptionsClusterNotInitializedResponseBody(body *GetJoinOptionsClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateGetJoinOptionsInvalidJoinTokenResponseBody runs the validations
// defined on get-join-options_invalid_join_token_response_body
func ValidateGetJoinOptionsInvalidJoinTokenResponseBody(body *GetJoinOptionsInvalidJoinTokenResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInspectClusterClusterNotInitializedResponseBody runs the validations
// defined on inspect-cluster_cluster_not_initialized_response_body
func ValidateInspectClusterClusterNotInitializedResponseBody(body *InspectClusterClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInspectClusterNotFoundResponseBody runs the validations defined on
// inspect-cluster_not_found_response_body
func ValidateInspectClusterNotFoundResponseBody(body *InspectClusterNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateListHostsClusterNotInitializedResponseBody runs the validations
// defined on list-hosts_cluster_not_initialized_response_body
func ValidateListHostsClusterNotInitializedResponseBody(body *ListHostsClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInspectHostClusterNotInitializedResponseBody runs the validations
// defined on inspect-host_cluster_not_initialized_response_body
func ValidateInspectHostClusterNotInitializedResponseBody(body *InspectHostClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInspectHostNotFoundResponseBody runs the validations defined on
// inspect-host_not_found_response_body
func ValidateInspectHostNotFoundResponseBody(body *InspectHostNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRemoveHostClusterNotInitializedResponseBody runs the validations
// defined on remove-host_cluster_not_initialized_response_body
func ValidateRemoveHostClusterNotInitializedResponseBody(body *RemoveHostClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRemoveHostNotFoundResponseBody runs the validations defined on
// remove-host_not_found_response_body
func ValidateRemoveHostNotFoundResponseBody(body *RemoveHostNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateListDatabasesClusterNotInitializedResponseBody runs the validations
// defined on list-databases_cluster_not_initialized_response_body
func ValidateListDatabasesClusterNotInitializedResponseBody(body *ListDatabasesClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateCreateDatabaseDatabaseAlreadyExistsResponseBody runs the validations
// defined on create-database_database_already_exists_response_body
func ValidateCreateDatabaseDatabaseAlreadyExistsResponseBody(body *CreateDatabaseDatabaseAlreadyExistsResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateCreateDatabaseClusterNotInitializedResponseBody runs the validations
// defined on create-database_cluster_not_initialized_response_body
func ValidateCreateDatabaseClusterNotInitializedResponseBody(body *CreateDatabaseClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateCreateDatabaseInvalidInputResponseBody runs the validations defined
// on create-database_invalid_input_response_body
func ValidateCreateDatabaseInvalidInputResponseBody(body *CreateDatabaseInvalidInputResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInspectDatabaseClusterNotInitializedResponseBody runs the
// validations defined on inspect-database_cluster_not_initialized_response_body
func ValidateInspectDatabaseClusterNotInitializedResponseBody(body *InspectDatabaseClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInspectDatabaseNotFoundResponseBody runs the validations defined on
// inspect-database_not_found_response_body
func ValidateInspectDatabaseNotFoundResponseBody(body *InspectDatabaseNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateUpdateDatabaseClusterNotInitializedResponseBody runs the validations
// defined on update-database_cluster_not_initialized_response_body
func ValidateUpdateDatabaseClusterNotInitializedResponseBody(body *UpdateDatabaseClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateUpdateDatabaseDatabaseNotModifiableResponseBody runs the validations
// defined on update-database_database_not_modifiable_response_body
func ValidateUpdateDatabaseDatabaseNotModifiableResponseBody(body *UpdateDatabaseDatabaseNotModifiableResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateUpdateDatabaseNotFoundResponseBody runs the validations defined on
// update-database_not_found_response_body
func ValidateUpdateDatabaseNotFoundResponseBody(body *UpdateDatabaseNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDeleteDatabaseClusterNotInitializedResponseBody runs the validations
// defined on delete-database_cluster_not_initialized_response_body
func ValidateDeleteDatabaseClusterNotInitializedResponseBody(body *DeleteDatabaseClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDeleteDatabaseDatabaseNotModifiableResponseBody runs the validations
// defined on delete-database_database_not_modifiable_response_body
func ValidateDeleteDatabaseDatabaseNotModifiableResponseBody(body *DeleteDatabaseDatabaseNotModifiableResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDeleteDatabaseNotFoundResponseBody runs the validations defined on
// delete-database_not_found_response_body
func ValidateDeleteDatabaseNotFoundResponseBody(body *DeleteDatabaseNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInitiateDatabaseBackupBackupAlreadyInProgressResponseBody runs the
// validations defined on
// initiate-database-backup_backup_already_in_progress_response_body
func ValidateInitiateDatabaseBackupBackupAlreadyInProgressResponseBody(body *InitiateDatabaseBackupBackupAlreadyInProgressResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInitiateDatabaseBackupClusterNotInitializedResponseBody runs the
// validations defined on
// initiate-database-backup_cluster_not_initialized_response_body
func ValidateInitiateDatabaseBackupClusterNotInitializedResponseBody(body *InitiateDatabaseBackupClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInitiateDatabaseBackupDatabaseNotModifiableResponseBody runs the
// validations defined on
// initiate-database-backup_database_not_modifiable_response_body
func ValidateInitiateDatabaseBackupDatabaseNotModifiableResponseBody(body *InitiateDatabaseBackupDatabaseNotModifiableResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInitiateDatabaseBackupNotFoundResponseBody runs the validations
// defined on initiate-database-backup_not_found_response_body
func ValidateInitiateDatabaseBackupNotFoundResponseBody(body *InitiateDatabaseBackupNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateListDatabaseTasksClusterNotInitializedResponseBody runs the
// validations defined on
// list-database-tasks_cluster_not_initialized_response_body
func ValidateListDatabaseTasksClusterNotInitializedResponseBody(body *ListDatabaseTasksClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateListDatabaseTasksNotFoundResponseBody runs the validations defined
// on list-database-tasks_not_found_response_body
func ValidateListDatabaseTasksNotFoundResponseBody(body *ListDatabaseTasksNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInspectDatabaseTaskClusterNotInitializedResponseBody runs the
// validations defined on
// inspect-database-task_cluster_not_initialized_response_body
func ValidateInspectDatabaseTaskClusterNotInitializedResponseBody(body *InspectDatabaseTaskClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateInspectDatabaseTaskNotFoundResponseBody runs the validations defined
// on inspect-database-task_not_found_response_body
func ValidateInspectDatabaseTaskNotFoundResponseBody(body *InspectDatabaseTaskNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateGetDatabaseTaskLogClusterNotInitializedResponseBody runs the
// validations defined on
// get-database-task-log_cluster_not_initialized_response_body
func ValidateGetDatabaseTaskLogClusterNotInitializedResponseBody(body *GetDatabaseTaskLogClusterNotInitializedResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateGetDatabaseTaskLogNotFoundResponseBody runs the validations defined
// on get-database-task-log_not_found_response_body
func ValidateGetDatabaseTaskLogNotFoundResponseBody(body *GetDatabaseTaskLogNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateClusterPeerResponseBody runs the validations defined on
// ClusterPeerResponseBody
func ValidateClusterPeerResponseBody(body *ClusterPeerResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.PeerURL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("peer_url", "body"))
	}
	if body.ClientURL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("client_url", "body"))
	}
	if body.Name != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.name", *body.Name, goa.FormatUUID))
	}
	if body.PeerURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.peer_url", *body.PeerURL, goa.FormatURI))
	}
	if body.ClientURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.client_url", *body.ClientURL, goa.FormatURI))
	}
	return
}

// ValidateClusterCredentialsResponseBody runs the validations defined on
// ClusterCredentialsResponseBody
func ValidateClusterCredentialsResponseBody(body *ClusterCredentialsResponseBody) (err error) {
	if body.CaCert == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ca_cert", "body"))
	}
	if body.ClientCert == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("client_cert", "body"))
	}
	if body.ClientKey == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("client_key", "body"))
	}
	if body.ServerCert == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("server_cert", "body"))
	}
	if body.ServerKey == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("server_key", "body"))
	}
	return
}

// ValidateClusterStatusResponseBody runs the validations defined on
// ClusterStatusResponseBody
func ValidateClusterStatusResponseBody(body *ClusterStatusResponseBody) (err error) {
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.State != nil {
		if !(*body.State == "available" || *body.State == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"available", "error"}))
		}
	}
	return
}

// ValidateHostResponseBody runs the validations defined on HostResponseBody
func ValidateHostResponseBody(body *HostResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Orchestrator == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("orchestrator", "body"))
	}
	if body.Hostname == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hostname", "body"))
	}
	if body.Ipv4Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ipv4_address", "body"))
	}
	if body.Cpus == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cpus", "body"))
	}
	if body.Memory == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("memory", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.DefaultPgedgeVersion == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("default_pgedge_version", "body"))
	}
	if body.SupportedPgedgeVersions == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("supported_pgedge_versions", "body"))
	}
	if body.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", *body.ID, goa.FormatUUID))
	}
	if body.Cohort != nil {
		if err2 := ValidateHostCohortResponseBody(body.Cohort); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	if body.Status != nil {
		if err2 := ValidateHostStatusResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.DefaultPgedgeVersion != nil {
		if err2 := ValidatePgEdgeVersionResponseBody(body.DefaultPgedgeVersion); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.SupportedPgedgeVersions {
		if e != nil {
			if err2 := ValidatePgEdgeVersionResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateHostCohortResponseBody runs the validations defined on
// HostCohortResponseBody
func ValidateHostCohortResponseBody(body *HostCohortResponseBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CohortID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cohort_id", "body"))
	}
	if body.MemberID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("member_id", "body"))
	}
	if body.ControlAvailable == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("control_available", "body"))
	}
	return
}

// ValidateHostStatusResponseBody runs the validations defined on
// HostStatusResponseBody
func ValidateHostStatusResponseBody(body *HostStatusResponseBody) (err error) {
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "body"))
	}
	if body.Components == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("components", "body"))
	}
	if body.State != nil {
		if !(*body.State == "healthy" || *body.State == "unreachable" || *body.State == "degraded" || *body.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"healthy", "unreachable", "degraded", "unknown"}))
		}
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	for _, v := range body.Components {
		if v != nil {
			if err2 := ValidateComponentStatusResponseBody(v); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateComponentStatusResponseBody runs the validations defined on
// ComponentStatusResponseBody
func ValidateComponentStatusResponseBody(body *ComponentStatusResponseBody) (err error) {
	if body.Error == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("error", "body"))
	}
	if body.Details == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("details", "body"))
	}
	return
}

// ValidatePgEdgeVersionResponseBody runs the validations defined on
// PgEdgeVersionResponseBody
func ValidatePgEdgeVersionResponseBody(body *PgEdgeVersionResponseBody) (err error) {
	if body.PostgresVersion == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("postgres_version", "body"))
	}
	if body.SpockVersion == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spock_version", "body"))
	}
	return
}

// ValidateHostResponse runs the validations defined on HostResponse
func ValidateHostResponse(body *HostResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Orchestrator == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("orchestrator", "body"))
	}
	if body.Hostname == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hostname", "body"))
	}
	if body.Ipv4Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ipv4_address", "body"))
	}
	if body.Cpus == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cpus", "body"))
	}
	if body.Memory == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("memory", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.DefaultPgedgeVersion == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("default_pgedge_version", "body"))
	}
	if body.SupportedPgedgeVersions == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("supported_pgedge_versions", "body"))
	}
	if body.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", *body.ID, goa.FormatUUID))
	}
	if body.Cohort != nil {
		if err2 := ValidateHostCohortResponse(body.Cohort); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	if body.Status != nil {
		if err2 := ValidateHostStatusResponse(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.DefaultPgedgeVersion != nil {
		if err2 := ValidatePgEdgeVersionResponse(body.DefaultPgedgeVersion); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.SupportedPgedgeVersions {
		if e != nil {
			if err2 := ValidatePgEdgeVersionResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateHostCohortResponse runs the validations defined on HostCohortResponse
func ValidateHostCohortResponse(body *HostCohortResponse) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CohortID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cohort_id", "body"))
	}
	if body.MemberID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("member_id", "body"))
	}
	if body.ControlAvailable == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("control_available", "body"))
	}
	return
}

// ValidateHostStatusResponse runs the validations defined on HostStatusResponse
func ValidateHostStatusResponse(body *HostStatusResponse) (err error) {
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "body"))
	}
	if body.Components == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("components", "body"))
	}
	if body.State != nil {
		if !(*body.State == "healthy" || *body.State == "unreachable" || *body.State == "degraded" || *body.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"healthy", "unreachable", "degraded", "unknown"}))
		}
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	for _, v := range body.Components {
		if v != nil {
			if err2 := ValidateComponentStatusResponse(v); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateComponentStatusResponse runs the validations defined on
// ComponentStatusResponse
func ValidateComponentStatusResponse(body *ComponentStatusResponse) (err error) {
	if body.Error == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("error", "body"))
	}
	if body.Details == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("details", "body"))
	}
	return
}

// ValidatePgEdgeVersionResponse runs the validations defined on
// PgEdgeVersionResponse
func ValidatePgEdgeVersionResponse(body *PgEdgeVersionResponse) (err error) {
	if body.PostgresVersion == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("postgres_version", "body"))
	}
	if body.SpockVersion == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spock_version", "body"))
	}
	return
}

// ValidateDatabaseResponse runs the validations defined on DatabaseResponse
func ValidateDatabaseResponse(body *DatabaseResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "body"))
	}
	if body.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "body"))
	}
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", *body.ID, goa.FormatUUID))
	}
	if body.TenantID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.tenant_id", *body.TenantID, goa.FormatUUID))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	if body.State != nil {
		if !(*body.State == "creating" || *body.State == "modifying" || *body.State == "available" || *body.State == "deleting" || *body.State == "degraded" || *body.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"creating", "modifying", "available", "deleting", "degraded", "unknown"}))
		}
	}
	if body.Instances != nil {
		if err2 := ValidateInstanceCollectionResponse(body.Instances); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecResponse(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateInstanceCollectionResponse runs the validations defined on
// InstanceCollectionResponse
func ValidateInstanceCollectionResponse(body InstanceCollectionResponse) (err error) {
	for _, e := range body {
		if e != nil {
			if err2 := ValidateInstanceResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInstanceResponse runs the validations defined on InstanceResponse
func ValidateInstanceResponse(body *InstanceResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	if body.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "body"))
	}
	if body.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "body"))
	}
	if body.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "body"))
	}
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", *body.ID, goa.FormatUUID))
	}
	if body.HostID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.host_id", *body.HostID, goa.FormatUUID))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.updated_at", *body.UpdatedAt, goa.FormatDateTime))
	}
	if body.State != nil {
		if !(*body.State == "creating" || *body.State == "modifying" || *body.State == "backing_up" || *body.State == "restoring" || *body.State == "deleting" || *body.State == "available" || *body.State == "degraded" || *body.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"creating", "modifying", "backing_up", "restoring", "deleting", "available", "degraded", "unknown"}))
		}
	}
	if body.PatroniState != nil {
		if !(*body.PatroniState == "stopping" || *body.PatroniState == "stopped" || *body.PatroniState == "stop failed" || *body.PatroniState == "crashed" || *body.PatroniState == "running" || *body.PatroniState == "starting" || *body.PatroniState == "start failed" || *body.PatroniState == "restarting" || *body.PatroniState == "restart failed" || *body.PatroniState == "initializing new cluster" || *body.PatroniState == "initdb failed" || *body.PatroniState == "running custom bootstrap script" || *body.PatroniState == "custom bootstrap failed" || *body.PatroniState == "creating replica" || *body.PatroniState == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.patroni_state", *body.PatroniState, []any{"stopping", "stopped", "stop failed", "crashed", "running", "starting", "start failed", "restarting", "restart failed", "initializing new cluster", "initdb failed", "running custom bootstrap script", "custom bootstrap failed", "creating replica", "unknown"}))
		}
	}
	if body.Role != nil {
		if !(*body.Role == "replica" || *body.Role == "primary") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.role", *body.Role, []any{"replica", "primary"}))
		}
	}
	for _, e := range body.Interfaces {
		if e != nil {
			if err2 := ValidateInstanceInterfaceResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInstanceInterfaceResponse runs the validations defined on
// InstanceInterfaceResponse
func ValidateInstanceInterfaceResponse(body *InstanceInterfaceResponse) (err error) {
	if body.NetworkType == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("network_type", "body"))
	}
	if body.Port == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("port", "body"))
	}
	if body.NetworkType != nil {
		if !(*body.NetworkType == "docker" || *body.NetworkType == "host") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.network_type", *body.NetworkType, []any{"docker", "host"}))
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	return
}

// ValidateDatabaseSpecResponse runs the validations defined on
// DatabaseSpecResponse
func ValidateDatabaseSpecResponse(body *DatabaseSpecResponse) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecResponse(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecResponse(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseNodeSpecResponse runs the validations defined on
// DatabaseNodeSpecResponse
func ValidateDatabaseNodeSpecResponse(body *DatabaseNodeSpecResponse) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "body"))
	}
	if body.Name != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.name", *body.Name, "n[0-9]+"))
	}
	if len(body.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids", body.HostIds, len(body.HostIds), 1, true))
	}
	for _, e := range body.HostIds {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.host_ids[*]", e, goa.FormatUUID))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecResponse(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBackupConfigSpecResponse runs the validations defined on
// BackupConfigSpecResponse
func ValidateBackupConfigSpecResponse(body *BackupConfigSpecResponse) (err error) {
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecResponse runs the validations defined on
// BackupRepositorySpecResponse
func ValidateBackupRepositorySpecResponse(body *BackupRepositorySpecResponse) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecResponse runs the validations defined on
// BackupScheduleSpecResponse
func ValidateBackupScheduleSpecResponse(body *BackupScheduleSpecResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	return
}

// ValidateDatabaseUserSpecResponse runs the validations defined on
// DatabaseUserSpecResponse
func ValidateDatabaseUserSpecResponse(body *DatabaseUserSpecResponse) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Password == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("password", "body"))
	}
	return
}

// ValidateRestoreConfigSpecResponse runs the validations defined on
// RestoreConfigSpecResponse
func ValidateRestoreConfigSpecResponse(body *RestoreConfigSpecResponse) (err error) {
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.DatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_id", "body"))
	}
	if body.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "body"))
	}
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	if body.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecResponse(body.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateRestoreRepositorySpecResponse runs the validations defined on
// RestoreRepositorySpecResponse
func ValidateRestoreRepositorySpecResponse(body *RestoreRepositorySpecResponse) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	return
}

// ValidateDatabaseSpecRequestBody runs the validations defined on
// DatabaseSpecRequestBody
func ValidateDatabaseSpecRequestBody(body *DatabaseSpecRequestBody) (err error) {
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecRequestBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBody runs the validations defined on
// DatabaseNodeSpecRequestBody
func ValidateDatabaseNodeSpecRequestBody(body *DatabaseNodeSpecRequestBody) (err error) {
	if body.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "body"))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("body.name", body.Name, "n[0-9]+"))
	if len(body.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids", body.HostIds, len(body.HostIds), 1, true))
	}
	for _, e := range body.HostIds {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.host_ids[*]", e, goa.FormatUUID))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBackupConfigSpecRequestBody runs the validations defined on
// BackupConfigSpecRequestBody
func ValidateBackupConfigSpecRequestBody(body *BackupConfigSpecRequestBody) (err error) {
	if !(body.Provider == "pgbackrest" || body.Provider == "pg_dump") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", body.Provider, []any{"pgbackrest", "pg_dump"}))
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBody runs the validations defined on
// BackupRepositorySpecRequestBody
func ValidateBackupRepositorySpecRequestBody(body *BackupRepositorySpecRequestBody) (err error) {
	if !(body.Type == "s3" || body.Type == "gcs" || body.Type == "azure") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"s3", "gcs", "azure"}))
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBody runs the validations defined on
// BackupScheduleSpecRequestBody
func ValidateBackupScheduleSpecRequestBody(body *BackupScheduleSpecRequestBody) (err error) {
	if !(body.Type == "full" || body.Type == "incr") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"full", "incr"}))
	}
	return
}

// ValidateRestoreConfigSpecRequestBody runs the validations defined on
// RestoreConfigSpecRequestBody
func ValidateRestoreConfigSpecRequestBody(body *RestoreConfigSpecRequestBody) (err error) {
	if body.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "body"))
	}
	if !(body.Provider == "pgbackrest" || body.Provider == "pg_dump") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", body.Provider, []any{"pgbackrest", "pg_dump"}))
	}
	if body.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecRequestBody(body.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateRestoreRepositorySpecRequestBody runs the validations defined on
// RestoreRepositorySpecRequestBody
func ValidateRestoreRepositorySpecRequestBody(body *RestoreRepositorySpecRequestBody) (err error) {
	if !(body.Type == "s3" || body.Type == "gcs" || body.Type == "azure") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"s3", "gcs", "azure"}))
	}
	return
}

// ValidateInstanceResponseBodyAbbreviatedCollection runs the validations
// defined on InstanceResponseBodyAbbreviatedCollection
func ValidateInstanceResponseBodyAbbreviatedCollection(body InstanceResponseBodyAbbreviatedCollection) (err error) {
	for _, e := range body {
		if e != nil {
			if err2 := ValidateInstanceResponseBodyAbbreviated(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInstanceResponseBodyAbbreviated runs the validations defined on
// InstanceResponseBodyAbbreviated
func ValidateInstanceResponseBodyAbbreviated(body *InstanceResponseBodyAbbreviated) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	if body.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "body"))
	}
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", *body.ID, goa.FormatUUID))
	}
	if body.HostID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.host_id", *body.HostID, goa.FormatUUID))
	}
	if body.State != nil {
		if !(*body.State == "creating" || *body.State == "modifying" || *body.State == "backing_up" || *body.State == "restoring" || *body.State == "deleting" || *body.State == "available" || *body.State == "degraded" || *body.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"creating", "modifying", "backing_up", "restoring", "deleting", "available", "degraded", "unknown"}))
		}
	}
	return
}

// ValidateDatabaseSpecResponseBody runs the validations defined on
// DatabaseSpecResponseBody
func ValidateDatabaseSpecResponseBody(body *DatabaseSpecResponseBody) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecResponseBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecResponseBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseNodeSpecResponseBody runs the validations defined on
// DatabaseNodeSpecResponseBody
func ValidateDatabaseNodeSpecResponseBody(body *DatabaseNodeSpecResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "body"))
	}
	if body.Name != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.name", *body.Name, "n[0-9]+"))
	}
	if len(body.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids", body.HostIds, len(body.HostIds), 1, true))
	}
	for _, e := range body.HostIds {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.host_ids[*]", e, goa.FormatUUID))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecResponseBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBackupConfigSpecResponseBody runs the validations defined on
// BackupConfigSpecResponseBody
func ValidateBackupConfigSpecResponseBody(body *BackupConfigSpecResponseBody) (err error) {
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecResponseBody runs the validations defined on
// BackupRepositorySpecResponseBody
func ValidateBackupRepositorySpecResponseBody(body *BackupRepositorySpecResponseBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecResponseBody runs the validations defined on
// BackupScheduleSpecResponseBody
func ValidateBackupScheduleSpecResponseBody(body *BackupScheduleSpecResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	return
}

// ValidateDatabaseUserSpecResponseBody runs the validations defined on
// DatabaseUserSpecResponseBody
func ValidateDatabaseUserSpecResponseBody(body *DatabaseUserSpecResponseBody) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Password == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("password", "body"))
	}
	return
}

// ValidateRestoreConfigSpecResponseBody runs the validations defined on
// RestoreConfigSpecResponseBody
func ValidateRestoreConfigSpecResponseBody(body *RestoreConfigSpecResponseBody) (err error) {
	if body.Provider == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider", "body"))
	}
	if body.DatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_id", "body"))
	}
	if body.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "body"))
	}
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "body"))
	}
	if body.Provider != nil {
		if !(*body.Provider == "pgbackrest" || *body.Provider == "pg_dump") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", *body.Provider, []any{"pgbackrest", "pg_dump"}))
		}
	}
	if body.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecResponseBody(body.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateRestoreRepositorySpecResponseBody runs the validations defined on
// RestoreRepositorySpecResponseBody
func ValidateRestoreRepositorySpecResponseBody(body *RestoreRepositorySpecResponseBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure"}))
		}
	}
	return
}

// ValidateDatabaseSpecRequestBodyRequestBody runs the validations defined on
// DatabaseSpecRequestBodyRequestBody
func ValidateDatabaseSpecRequestBodyRequestBody(body *DatabaseSpecRequestBodyRequestBody) (err error) {
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.SpockVersion != nil {
		if !(*body.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.spock_version", *body.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBodyRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecRequestBodyRequestBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBodyRequestBody runs the validations defined
// on DatabaseNodeSpecRequestBodyRequestBody
func ValidateDatabaseNodeSpecRequestBodyRequestBody(body *DatabaseNodeSpecRequestBodyRequestBody) (err error) {
	if body.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "body"))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("body.name", body.Name, "n[0-9]+"))
	if len(body.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids", body.HostIds, len(body.HostIds), 1, true))
	}
	for _, e := range body.HostIds {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.host_ids[*]", e, goa.FormatUUID))
	}
	if body.PostgresVersion != nil {
		if !(*body.PostgresVersion == "16" || *body.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.postgres_version", *body.PostgresVersion, []any{"16", "17"}))
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBodyRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBackupConfigSpecRequestBodyRequestBody runs the validations defined
// on BackupConfigSpecRequestBodyRequestBody
func ValidateBackupConfigSpecRequestBodyRequestBody(body *BackupConfigSpecRequestBodyRequestBody) (err error) {
	if !(body.Provider == "pgbackrest" || body.Provider == "pg_dump") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", body.Provider, []any{"pgbackrest", "pg_dump"}))
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBodyRequestBody runs the validations
// defined on BackupRepositorySpecRequestBodyRequestBody
func ValidateBackupRepositorySpecRequestBodyRequestBody(body *BackupRepositorySpecRequestBodyRequestBody) (err error) {
	if !(body.Type == "s3" || body.Type == "gcs" || body.Type == "azure") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"s3", "gcs", "azure"}))
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBodyRequestBody runs the validations
// defined on BackupScheduleSpecRequestBodyRequestBody
func ValidateBackupScheduleSpecRequestBodyRequestBody(body *BackupScheduleSpecRequestBodyRequestBody) (err error) {
	if !(body.Type == "full" || body.Type == "incr") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"full", "incr"}))
	}
	return
}

// ValidateRestoreConfigSpecRequestBodyRequestBody runs the validations defined
// on RestoreConfigSpecRequestBodyRequestBody
func ValidateRestoreConfigSpecRequestBodyRequestBody(body *RestoreConfigSpecRequestBodyRequestBody) (err error) {
	if body.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "body"))
	}
	if !(body.Provider == "pgbackrest" || body.Provider == "pg_dump") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.provider", body.Provider, []any{"pgbackrest", "pg_dump"}))
	}
	if body.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecRequestBodyRequestBody(body.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateRestoreRepositorySpecRequestBodyRequestBody runs the validations
// defined on RestoreRepositorySpecRequestBodyRequestBody
func ValidateRestoreRepositorySpecRequestBodyRequestBody(body *RestoreRepositorySpecRequestBodyRequestBody) (err error) {
	if !(body.Type == "s3" || body.Type == "gcs" || body.Type == "azure") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"s3", "gcs", "azure"}))
	}
	return
}

// ValidateTaskResponse runs the validations defined on TaskResponse
func ValidateTaskResponse(body *TaskResponse) (err error) {
	if body.DatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_id", "body"))
	}
	if body.TaskID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task_id", "body"))
	}
	if body.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.CompletedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.completed_at", *body.CompletedAt, goa.FormatDateTime))
	}
	if body.Status != nil {
		if !(*body.Status == "pending" || *body.Status == "running" || *body.Status == "completed" || *body.Status == "failed" || *body.Status == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"pending", "running", "completed", "failed", "unknown"}))
		}
	}
	return
}
