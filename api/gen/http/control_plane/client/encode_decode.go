// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/design

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	controlplane "github.com/pgEdge/control-plane/api/gen/control_plane"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildInspectClusterRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "inspect-cluster" endpoint
func (c *Client) BuildInspectClusterRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: InspectClusterControlPlanePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "inspect-cluster", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeInspectClusterResponse returns a decoder for responses returned by the
// control-plane inspect-cluster endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeInspectClusterResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body InspectClusterResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-cluster", err)
			}
			err = ValidateInspectClusterResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-cluster", err)
			}
			res := NewInspectClusterClusterOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "inspect-cluster", resp.StatusCode, string(body))
		}
	}
}

// BuildListHostsRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "list-hosts" endpoint
func (c *Client) BuildListHostsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListHostsControlPlanePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "list-hosts", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeListHostsResponse returns a decoder for responses returned by the
// control-plane list-hosts endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeListHostsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListHostsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "list-hosts", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateHostResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "list-hosts", err)
			}
			res := NewListHostsHostOK(body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "list-hosts", resp.StatusCode, string(body))
		}
	}
}

// BuildInspectHostRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "inspect-host" endpoint
func (c *Client) BuildInspectHostRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		hostID string
	)
	{
		p, ok := v.(*controlplane.InspectHostPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "inspect-host", "*controlplane.InspectHostPayload", v)
		}
		if p.HostID != nil {
			hostID = *p.HostID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: InspectHostControlPlanePath(hostID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "inspect-host", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeInspectHostResponse returns a decoder for responses returned by the
// control-plane inspect-host endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeInspectHostResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body InspectHostResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-host", err)
			}
			err = ValidateInspectHostResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-host", err)
			}
			res := NewInspectHostHostOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "inspect-host", resp.StatusCode, string(body))
		}
	}
}

// BuildRemoveHostRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "remove-host" endpoint
func (c *Client) BuildRemoveHostRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		hostID string
	)
	{
		p, ok := v.(*controlplane.RemoveHostPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "remove-host", "*controlplane.RemoveHostPayload", v)
		}
		if p.HostID != nil {
			hostID = *p.HostID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RemoveHostControlPlanePath(hostID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "remove-host", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeRemoveHostResponse returns a decoder for responses returned by the
// control-plane remove-host endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeRemoveHostResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "remove-host", resp.StatusCode, string(body))
		}
	}
}

// BuildListDatabasesRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "list-databases" endpoint
func (c *Client) BuildListDatabasesRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListDatabasesControlPlanePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "list-databases", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeListDatabasesResponse returns a decoder for responses returned by the
// control-plane list-databases endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeListDatabasesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListDatabasesResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "list-databases", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateDatabaseResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "list-databases", err)
			}
			res := NewListDatabasesDatabaseOK(body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "list-databases", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateDatabaseRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "create-database" endpoint
func (c *Client) BuildCreateDatabaseRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateDatabaseControlPlanePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "create-database", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateDatabaseRequest returns an encoder for requests sent to the
// control-plane create-database server.
func EncodeCreateDatabaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*controlplane.CreateDatabaseRequest)
		if !ok {
			return goahttp.ErrInvalidType("control-plane", "create-database", "*controlplane.CreateDatabaseRequest", v)
		}
		body := NewCreateDatabaseRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("control-plane", "create-database", err)
		}
		return nil
	}
}

// DecodeCreateDatabaseResponse returns a decoder for responses returned by the
// control-plane create-database endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeCreateDatabaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CreateDatabaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "create-database", err)
			}
			err = ValidateCreateDatabaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "create-database", err)
			}
			res := NewCreateDatabaseDatabaseOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "create-database", resp.StatusCode, string(body))
		}
	}
}

// BuildInspectDatabaseRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "inspect-database" endpoint
func (c *Client) BuildInspectDatabaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		databaseID string
	)
	{
		p, ok := v.(*controlplane.InspectDatabasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "inspect-database", "*controlplane.InspectDatabasePayload", v)
		}
		if p.DatabaseID != nil {
			databaseID = *p.DatabaseID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: InspectDatabaseControlPlanePath(databaseID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "inspect-database", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeInspectDatabaseResponse returns a decoder for responses returned by
// the control-plane inspect-database endpoint. restoreBody controls whether
// the response body should be restored after having been read.
func DecodeInspectDatabaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body InspectDatabaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-database", err)
			}
			err = ValidateInspectDatabaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-database", err)
			}
			res := NewInspectDatabaseDatabaseOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "inspect-database", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateDatabaseRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "update-database" endpoint
func (c *Client) BuildUpdateDatabaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		databaseID string
	)
	{
		p, ok := v.(*controlplane.UpdateDatabasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "update-database", "*controlplane.UpdateDatabasePayload", v)
		}
		if p.DatabaseID != nil {
			databaseID = *p.DatabaseID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateDatabaseControlPlanePath(databaseID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "update-database", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateDatabaseRequest returns an encoder for requests sent to the
// control-plane update-database server.
func EncodeUpdateDatabaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*controlplane.UpdateDatabasePayload)
		if !ok {
			return goahttp.ErrInvalidType("control-plane", "update-database", "*controlplane.UpdateDatabasePayload", v)
		}
		body := NewUpdateDatabaseRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("control-plane", "update-database", err)
		}
		return nil
	}
}

// DecodeUpdateDatabaseResponse returns a decoder for responses returned by the
// control-plane update-database endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeUpdateDatabaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateDatabaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "update-database", err)
			}
			err = ValidateUpdateDatabaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "update-database", err)
			}
			res := NewUpdateDatabaseDatabaseOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "update-database", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteDatabaseRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "delete-database" endpoint
func (c *Client) BuildDeleteDatabaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		databaseID string
	)
	{
		p, ok := v.(*controlplane.DeleteDatabasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "delete-database", "*controlplane.DeleteDatabasePayload", v)
		}
		if p.DatabaseID != nil {
			databaseID = *p.DatabaseID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteDatabaseControlPlanePath(databaseID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "delete-database", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeDeleteDatabaseResponse returns a decoder for responses returned by the
// control-plane delete-database endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeDeleteDatabaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "delete-database", resp.StatusCode, string(body))
		}
	}
}

// unmarshalClusterStatusResponseBodyToControlplaneClusterStatus builds a value
// of type *controlplane.ClusterStatus from a value of type
// *ClusterStatusResponseBody.
func unmarshalClusterStatusResponseBodyToControlplaneClusterStatus(v *ClusterStatusResponseBody) *controlplane.ClusterStatus {
	res := &controlplane.ClusterStatus{
		State: *v.State,
	}

	return res
}

// unmarshalHostResponseBodyToControlplaneHost builds a value of type
// *controlplane.Host from a value of type *HostResponseBody.
func unmarshalHostResponseBodyToControlplaneHost(v *HostResponseBody) *controlplane.Host {
	res := &controlplane.Host{
		ID:          *v.ID,
		Type:        v.Type,
		Cohort:      v.Cohort,
		Hostname:    *v.Hostname,
		Ipv4Address: *v.Ipv4Address,
	}
	if v.Config != nil {
		res.Config = unmarshalHostConfigurationResponseBodyToControlplaneHostConfiguration(v.Config)
	}
	res.Status = unmarshalHostStatusResponseBodyToControlplaneHostStatus(v.Status)

	return res
}

// unmarshalHostConfigurationResponseBodyToControlplaneHostConfiguration builds
// a value of type *controlplane.HostConfiguration from a value of type
// *HostConfigurationResponseBody.
func unmarshalHostConfigurationResponseBodyToControlplaneHostConfiguration(v *HostConfigurationResponseBody) *controlplane.HostConfiguration {
	if v == nil {
		return nil
	}
	res := &controlplane.HostConfiguration{
		VectorEnabled:  v.VectorEnabled,
		TraefikEnabled: v.TraefikEnabled,
	}

	return res
}

// unmarshalHostStatusResponseBodyToControlplaneHostStatus builds a value of
// type *controlplane.HostStatus from a value of type *HostStatusResponseBody.
func unmarshalHostStatusResponseBodyToControlplaneHostStatus(v *HostStatusResponseBody) *controlplane.HostStatus {
	res := &controlplane.HostStatus{
		State: *v.State,
	}

	return res
}

// unmarshalHostResponseToControlplaneHost builds a value of type
// *controlplane.Host from a value of type *HostResponse.
func unmarshalHostResponseToControlplaneHost(v *HostResponse) *controlplane.Host {
	res := &controlplane.Host{
		ID:          *v.ID,
		Type:        v.Type,
		Cohort:      v.Cohort,
		Hostname:    *v.Hostname,
		Ipv4Address: *v.Ipv4Address,
	}
	if v.Config != nil {
		res.Config = unmarshalHostConfigurationResponseToControlplaneHostConfiguration(v.Config)
	}
	res.Status = unmarshalHostStatusResponseToControlplaneHostStatus(v.Status)

	return res
}

// unmarshalHostConfigurationResponseToControlplaneHostConfiguration builds a
// value of type *controlplane.HostConfiguration from a value of type
// *HostConfigurationResponse.
func unmarshalHostConfigurationResponseToControlplaneHostConfiguration(v *HostConfigurationResponse) *controlplane.HostConfiguration {
	if v == nil {
		return nil
	}
	res := &controlplane.HostConfiguration{
		VectorEnabled:  v.VectorEnabled,
		TraefikEnabled: v.TraefikEnabled,
	}

	return res
}

// unmarshalHostStatusResponseToControlplaneHostStatus builds a value of type
// *controlplane.HostStatus from a value of type *HostStatusResponse.
func unmarshalHostStatusResponseToControlplaneHostStatus(v *HostStatusResponse) *controlplane.HostStatus {
	res := &controlplane.HostStatus{
		State: *v.State,
	}

	return res
}

// unmarshalDatabaseResponseToControlplaneDatabase builds a value of type
// *controlplane.Database from a value of type *DatabaseResponse.
func unmarshalDatabaseResponseToControlplaneDatabase(v *DatabaseResponse) *controlplane.Database {
	res := &controlplane.Database{
		ID:        *v.ID,
		TenantID:  v.TenantID,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
	}
	res.Status = unmarshalDatabaseStatusResponseToControlplaneDatabaseStatus(v.Status)
	res.Instances = unmarshalInstanceResponseToControlplaneInstance(v.Instances)
	if v.Spec != nil {
		res.Spec = unmarshalDatabaseSpecResponseToControlplaneDatabaseSpec(v.Spec)
	}

	return res
}

// unmarshalDatabaseStatusResponseToControlplaneDatabaseStatus builds a value
// of type *controlplane.DatabaseStatus from a value of type
// *DatabaseStatusResponse.
func unmarshalDatabaseStatusResponseToControlplaneDatabaseStatus(v *DatabaseStatusResponse) *controlplane.DatabaseStatus {
	res := &controlplane.DatabaseStatus{
		State:     v.State,
		UpdatedAt: v.UpdatedAt,
	}

	return res
}

// unmarshalInstanceResponseToControlplaneInstance builds a value of type
// *controlplane.Instance from a value of type *InstanceResponse.
func unmarshalInstanceResponseToControlplaneInstance(v *InstanceResponse) *controlplane.Instance {
	res := &controlplane.Instance{
		ID:        *v.ID,
		HostID:    v.HostID,
		NodeName:  v.NodeName,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
	}
	res.Status = unmarshalInstanceStatusResponseToControlplaneInstanceStatus(v.Status)
	if v.Interfaces != nil {
		res.Interfaces = make([]*controlplane.InstanceInterface, len(v.Interfaces))
		for i, val := range v.Interfaces {
			res.Interfaces[i] = unmarshalInstanceInterfaceResponseToControlplaneInstanceInterface(val)
		}
	}

	return res
}

// unmarshalInstanceStatusResponseToControlplaneInstanceStatus builds a value
// of type *controlplane.InstanceStatus from a value of type
// *InstanceStatusResponse.
func unmarshalInstanceStatusResponseToControlplaneInstanceStatus(v *InstanceStatusResponse) *controlplane.InstanceStatus {
	res := &controlplane.InstanceStatus{
		State:           *v.State,
		PatroniState:    v.PatroniState,
		Role:            v.Role,
		ReadOnly:        v.ReadOnly,
		PendingRestart:  v.PendingRestart,
		PatroniPaused:   v.PatroniPaused,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		UpdatedAt:       v.UpdatedAt,
	}

	return res
}

// unmarshalInstanceInterfaceResponseToControlplaneInstanceInterface builds a
// value of type *controlplane.InstanceInterface from a value of type
// *InstanceInterfaceResponse.
func unmarshalInstanceInterfaceResponseToControlplaneInstanceInterface(v *InstanceInterfaceResponse) *controlplane.InstanceInterface {
	if v == nil {
		return nil
	}
	res := &controlplane.InstanceInterface{
		NetworkType: v.NetworkType,
		NetworkID:   v.NetworkID,
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// unmarshalDatabaseSpecResponseToControlplaneDatabaseSpec builds a value of
// type *controlplane.DatabaseSpec from a value of type *DatabaseSpecResponse.
func unmarshalDatabaseSpecResponseToControlplaneDatabaseSpec(v *DatabaseSpecResponse) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       *v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
	for i, val := range v.Nodes {
		res.Nodes[i] = unmarshalDatabaseNodeSpecResponseToControlplaneDatabaseNodeSpec(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecResponseToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*controlplane.DatabaseExtensionSpec, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = unmarshalDatabaseExtensionSpecResponseToControlplaneDatabaseExtensionSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*controlplane.BackupConfigSpec, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = unmarshalBackupConfigSpecResponseToControlplaneBackupConfigSpec(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseNodeSpecResponseToControlplaneDatabaseNodeSpec builds a
// value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecResponse.
func unmarshalDatabaseNodeSpecResponseToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecResponse) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            *v.Name,
		InstanceID:      *v.InstanceID,
		HostID:          *v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = unmarshalDatabaseReplicaSpecResponseToControlplaneDatabaseReplicaSpec(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseReplicaSpecResponseToControlplaneDatabaseReplicaSpec builds
// a value of type *controlplane.DatabaseReplicaSpec from a value of type
// *DatabaseReplicaSpecResponse.
func unmarshalDatabaseReplicaSpecResponseToControlplaneDatabaseReplicaSpec(v *DatabaseReplicaSpecResponse) *controlplane.DatabaseReplicaSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseReplicaSpec{
		InstanceID: *v.InstanceID,
		HostID:     *v.HostID,
	}

	return res
}

// unmarshalDatabaseUserSpecResponseToControlplaneDatabaseUserSpec builds a
// value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecResponse.
func unmarshalDatabaseUserSpecResponseToControlplaneDatabaseUserSpec(v *DatabaseUserSpecResponse) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username:  *v.Username,
		Password:  *v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// unmarshalDatabaseExtensionSpecResponseToControlplaneDatabaseExtensionSpec
// builds a value of type *controlplane.DatabaseExtensionSpec from a value of
// type *DatabaseExtensionSpecResponse.
func unmarshalDatabaseExtensionSpecResponseToControlplaneDatabaseExtensionSpec(v *DatabaseExtensionSpecResponse) *controlplane.DatabaseExtensionSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseExtensionSpec{
		Name:    *v.Name,
		Version: v.Version,
	}

	return res
}

// unmarshalBackupConfigSpecResponseToControlplaneBackupConfigSpec builds a
// value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecResponse.
func unmarshalBackupConfigSpecResponseToControlplaneBackupConfigSpec(v *BackupConfigSpecResponse) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{
		ID:       *v.ID,
		Provider: *v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = unmarshalBackupRepositorySpecResponseToControlplaneBackupRepositorySpec(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = unmarshalBackupScheduleSpecResponseToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecResponseToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecResponse.
func unmarshalBackupRepositorySpecResponseToControlplaneBackupRepositorySpec(v *BackupRepositorySpecResponse) *controlplane.BackupRepositorySpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// unmarshalBackupScheduleSpecResponseToControlplaneBackupScheduleSpec builds a
// value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecResponse.
func unmarshalBackupScheduleSpecResponseToControlplaneBackupScheduleSpec(v *BackupScheduleSpecResponse) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// marshalControlplaneDatabaseSpecToDatabaseSpecRequestBody builds a value of
// type *DatabaseSpecRequestBody from a value of type
// *controlplane.DatabaseSpec.
func marshalControlplaneDatabaseSpecToDatabaseSpecRequestBody(v *controlplane.DatabaseSpec) *DatabaseSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecRequestBody{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecRequestBody, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBody(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecRequestBody{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecRequestBody, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBody(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*DatabaseExtensionSpecRequestBody, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecRequestBody(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*BackupConfigSpecRequestBody, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBody(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBody builds a
// value of type *DatabaseNodeSpecRequestBody from a value of type
// *controlplane.DatabaseNodeSpec.
func marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBody(v *controlplane.DatabaseNodeSpec) *DatabaseNodeSpecRequestBody {
	res := &DatabaseNodeSpecRequestBody{
		Name:            v.Name,
		InstanceID:      v.InstanceID,
		HostID:          v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecRequestBody(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecRequestBody
// builds a value of type *DatabaseReplicaSpecRequestBody from a value of type
// *controlplane.DatabaseReplicaSpec.
func marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecRequestBody(v *controlplane.DatabaseReplicaSpec) *DatabaseReplicaSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseReplicaSpecRequestBody{
		InstanceID: v.InstanceID,
		HostID:     v.HostID,
	}

	return res
}

// marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBody builds a
// value of type *DatabaseUserSpecRequestBody from a value of type
// *controlplane.DatabaseUserSpec.
func marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBody(v *controlplane.DatabaseUserSpec) *DatabaseUserSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecRequestBody{
		Username:  v.Username,
		Password:  v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecRequestBody
// builds a value of type *DatabaseExtensionSpecRequestBody from a value of
// type *controlplane.DatabaseExtensionSpec.
func marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecRequestBody(v *controlplane.DatabaseExtensionSpec) *DatabaseExtensionSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseExtensionSpecRequestBody{
		Name:    v.Name,
		Version: v.Version,
	}

	return res
}

// marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBody builds a
// value of type *BackupConfigSpecRequestBody from a value of type
// *controlplane.BackupConfigSpec.
func marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBody(v *controlplane.BackupConfigSpec) *BackupConfigSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecRequestBody{
		ID:       v.ID,
		Provider: v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecRequestBody, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBody(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecRequestBody, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBody(val)
		}
	}

	return res
}

// marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBody
// builds a value of type *BackupRepositorySpecRequestBody from a value of type
// *controlplane.BackupRepositorySpec.
func marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBody(v *controlplane.BackupRepositorySpec) *BackupRepositorySpecRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupRepositorySpecRequestBody{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBody builds
// a value of type *BackupScheduleSpecRequestBody from a value of type
// *controlplane.BackupScheduleSpec.
func marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBody(v *controlplane.BackupScheduleSpec) *BackupScheduleSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecRequestBody{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// marshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec builds a value of
// type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBody.
func marshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBody) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(val)
		}
	} else {
		res.Nodes = []*controlplane.DatabaseNodeSpec{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*controlplane.DatabaseExtensionSpec, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = marshalDatabaseExtensionSpecRequestBodyToControlplaneDatabaseExtensionSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*controlplane.BackupConfigSpec, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = marshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec builds a
// value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBody.
func marshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            v.Name,
		InstanceID:      v.InstanceID,
		HostID:          v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = marshalDatabaseReplicaSpecRequestBodyToControlplaneDatabaseReplicaSpec(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalDatabaseReplicaSpecRequestBodyToControlplaneDatabaseReplicaSpec
// builds a value of type *controlplane.DatabaseReplicaSpec from a value of
// type *DatabaseReplicaSpecRequestBody.
func marshalDatabaseReplicaSpecRequestBodyToControlplaneDatabaseReplicaSpec(v *DatabaseReplicaSpecRequestBody) *controlplane.DatabaseReplicaSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseReplicaSpec{
		InstanceID: v.InstanceID,
		HostID:     v.HostID,
	}

	return res
}

// marshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec builds a
// value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBody.
func marshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username:  v.Username,
		Password:  v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalDatabaseExtensionSpecRequestBodyToControlplaneDatabaseExtensionSpec
// builds a value of type *controlplane.DatabaseExtensionSpec from a value of
// type *DatabaseExtensionSpecRequestBody.
func marshalDatabaseExtensionSpecRequestBodyToControlplaneDatabaseExtensionSpec(v *DatabaseExtensionSpecRequestBody) *controlplane.DatabaseExtensionSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseExtensionSpec{
		Name:    v.Name,
		Version: v.Version,
	}

	return res
}

// marshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec builds a
// value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBody.
func marshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{
		ID:       v.ID,
		Provider: v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// marshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBody.
func marshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBody) *controlplane.BackupRepositorySpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// marshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec builds
// a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBody.
func marshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// unmarshalDatabaseStatusResponseBodyToControlplaneDatabaseStatus builds a
// value of type *controlplane.DatabaseStatus from a value of type
// *DatabaseStatusResponseBody.
func unmarshalDatabaseStatusResponseBodyToControlplaneDatabaseStatus(v *DatabaseStatusResponseBody) *controlplane.DatabaseStatus {
	res := &controlplane.DatabaseStatus{
		State:     v.State,
		UpdatedAt: v.UpdatedAt,
	}

	return res
}

// unmarshalInstanceResponseBodyToControlplaneInstance builds a value of type
// *controlplane.Instance from a value of type *InstanceResponseBody.
func unmarshalInstanceResponseBodyToControlplaneInstance(v *InstanceResponseBody) *controlplane.Instance {
	res := &controlplane.Instance{
		ID:        *v.ID,
		HostID:    v.HostID,
		NodeName:  v.NodeName,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
	}
	res.Status = unmarshalInstanceStatusResponseBodyToControlplaneInstanceStatus(v.Status)
	if v.Interfaces != nil {
		res.Interfaces = make([]*controlplane.InstanceInterface, len(v.Interfaces))
		for i, val := range v.Interfaces {
			res.Interfaces[i] = unmarshalInstanceInterfaceResponseBodyToControlplaneInstanceInterface(val)
		}
	}

	return res
}

// unmarshalInstanceStatusResponseBodyToControlplaneInstanceStatus builds a
// value of type *controlplane.InstanceStatus from a value of type
// *InstanceStatusResponseBody.
func unmarshalInstanceStatusResponseBodyToControlplaneInstanceStatus(v *InstanceStatusResponseBody) *controlplane.InstanceStatus {
	res := &controlplane.InstanceStatus{
		State:           *v.State,
		PatroniState:    v.PatroniState,
		Role:            v.Role,
		ReadOnly:        v.ReadOnly,
		PendingRestart:  v.PendingRestart,
		PatroniPaused:   v.PatroniPaused,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		UpdatedAt:       v.UpdatedAt,
	}

	return res
}

// unmarshalInstanceInterfaceResponseBodyToControlplaneInstanceInterface builds
// a value of type *controlplane.InstanceInterface from a value of type
// *InstanceInterfaceResponseBody.
func unmarshalInstanceInterfaceResponseBodyToControlplaneInstanceInterface(v *InstanceInterfaceResponseBody) *controlplane.InstanceInterface {
	if v == nil {
		return nil
	}
	res := &controlplane.InstanceInterface{
		NetworkType: v.NetworkType,
		NetworkID:   v.NetworkID,
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// unmarshalDatabaseSpecResponseBodyToControlplaneDatabaseSpec builds a value
// of type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecResponseBody.
func unmarshalDatabaseSpecResponseBodyToControlplaneDatabaseSpec(v *DatabaseSpecResponseBody) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       *v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
	for i, val := range v.Nodes {
		res.Nodes[i] = unmarshalDatabaseNodeSpecResponseBodyToControlplaneDatabaseNodeSpec(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecResponseBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*controlplane.DatabaseExtensionSpec, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = unmarshalDatabaseExtensionSpecResponseBodyToControlplaneDatabaseExtensionSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*controlplane.BackupConfigSpec, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = unmarshalBackupConfigSpecResponseBodyToControlplaneBackupConfigSpec(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseNodeSpecResponseBodyToControlplaneDatabaseNodeSpec builds a
// value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecResponseBody.
func unmarshalDatabaseNodeSpecResponseBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecResponseBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            *v.Name,
		InstanceID:      *v.InstanceID,
		HostID:          *v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = unmarshalDatabaseReplicaSpecResponseBodyToControlplaneDatabaseReplicaSpec(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseReplicaSpecResponseBodyToControlplaneDatabaseReplicaSpec
// builds a value of type *controlplane.DatabaseReplicaSpec from a value of
// type *DatabaseReplicaSpecResponseBody.
func unmarshalDatabaseReplicaSpecResponseBodyToControlplaneDatabaseReplicaSpec(v *DatabaseReplicaSpecResponseBody) *controlplane.DatabaseReplicaSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseReplicaSpec{
		InstanceID: *v.InstanceID,
		HostID:     *v.HostID,
	}

	return res
}

// unmarshalDatabaseUserSpecResponseBodyToControlplaneDatabaseUserSpec builds a
// value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecResponseBody.
func unmarshalDatabaseUserSpecResponseBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecResponseBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username:  *v.Username,
		Password:  *v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// unmarshalDatabaseExtensionSpecResponseBodyToControlplaneDatabaseExtensionSpec
// builds a value of type *controlplane.DatabaseExtensionSpec from a value of
// type *DatabaseExtensionSpecResponseBody.
func unmarshalDatabaseExtensionSpecResponseBodyToControlplaneDatabaseExtensionSpec(v *DatabaseExtensionSpecResponseBody) *controlplane.DatabaseExtensionSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseExtensionSpec{
		Name:    *v.Name,
		Version: v.Version,
	}

	return res
}

// unmarshalBackupConfigSpecResponseBodyToControlplaneBackupConfigSpec builds a
// value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecResponseBody.
func unmarshalBackupConfigSpecResponseBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecResponseBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{
		ID:       *v.ID,
		Provider: *v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = unmarshalBackupRepositorySpecResponseBodyToControlplaneBackupRepositorySpec(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = unmarshalBackupScheduleSpecResponseBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecResponseBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecResponseBody.
func unmarshalBackupRepositorySpecResponseBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecResponseBody) *controlplane.BackupRepositorySpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// unmarshalBackupScheduleSpecResponseBodyToControlplaneBackupScheduleSpec
// builds a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecResponseBody.
func unmarshalBackupScheduleSpecResponseBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecResponseBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// marshalControlplaneDatabaseSpecToDatabaseSpecRequestBodyRequestBody builds a
// value of type *DatabaseSpecRequestBodyRequestBody from a value of type
// *controlplane.DatabaseSpec.
func marshalControlplaneDatabaseSpecToDatabaseSpecRequestBodyRequestBody(v *controlplane.DatabaseSpec) *DatabaseSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecRequestBodyRequestBody{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecRequestBodyRequestBody, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBodyRequestBody(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecRequestBodyRequestBody{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecRequestBodyRequestBody, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBodyRequestBody(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*DatabaseExtensionSpecRequestBodyRequestBody, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecRequestBodyRequestBody(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*BackupConfigSpecRequestBodyRequestBody, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBodyRequestBody(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBodyRequestBody
// builds a value of type *DatabaseNodeSpecRequestBodyRequestBody from a value
// of type *controlplane.DatabaseNodeSpec.
func marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBodyRequestBody(v *controlplane.DatabaseNodeSpec) *DatabaseNodeSpecRequestBodyRequestBody {
	res := &DatabaseNodeSpecRequestBodyRequestBody{
		Name:            v.Name,
		InstanceID:      v.InstanceID,
		HostID:          v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecRequestBodyRequestBody(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecRequestBodyRequestBody
// builds a value of type *DatabaseReplicaSpecRequestBodyRequestBody from a
// value of type *controlplane.DatabaseReplicaSpec.
func marshalControlplaneDatabaseReplicaSpecToDatabaseReplicaSpecRequestBodyRequestBody(v *controlplane.DatabaseReplicaSpec) *DatabaseReplicaSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseReplicaSpecRequestBodyRequestBody{
		InstanceID: v.InstanceID,
		HostID:     v.HostID,
	}

	return res
}

// marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBodyRequestBody
// builds a value of type *DatabaseUserSpecRequestBodyRequestBody from a value
// of type *controlplane.DatabaseUserSpec.
func marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBodyRequestBody(v *controlplane.DatabaseUserSpec) *DatabaseUserSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecRequestBodyRequestBody{
		Username:  v.Username,
		Password:  v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecRequestBodyRequestBody
// builds a value of type *DatabaseExtensionSpecRequestBodyRequestBody from a
// value of type *controlplane.DatabaseExtensionSpec.
func marshalControlplaneDatabaseExtensionSpecToDatabaseExtensionSpecRequestBodyRequestBody(v *controlplane.DatabaseExtensionSpec) *DatabaseExtensionSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseExtensionSpecRequestBodyRequestBody{
		Name:    v.Name,
		Version: v.Version,
	}

	return res
}

// marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBodyRequestBody
// builds a value of type *BackupConfigSpecRequestBodyRequestBody from a value
// of type *controlplane.BackupConfigSpec.
func marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBodyRequestBody(v *controlplane.BackupConfigSpec) *BackupConfigSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecRequestBodyRequestBody{
		ID:       v.ID,
		Provider: v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecRequestBodyRequestBody, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBodyRequestBody(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecRequestBodyRequestBody, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBodyRequestBody(val)
		}
	}

	return res
}

// marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBodyRequestBody
// builds a value of type *BackupRepositorySpecRequestBodyRequestBody from a
// value of type *controlplane.BackupRepositorySpec.
func marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBodyRequestBody(v *controlplane.BackupRepositorySpec) *BackupRepositorySpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupRepositorySpecRequestBodyRequestBody{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBodyRequestBody
// builds a value of type *BackupScheduleSpecRequestBodyRequestBody from a
// value of type *controlplane.BackupScheduleSpec.
func marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBodyRequestBody(v *controlplane.BackupScheduleSpec) *BackupScheduleSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecRequestBodyRequestBody{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// marshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec builds a
// value of type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBodyRequestBody.
func marshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBodyRequestBody) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(val)
		}
	} else {
		res.Nodes = []*controlplane.DatabaseNodeSpec{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Extensions != nil {
		res.Extensions = make([]*controlplane.DatabaseExtensionSpec, len(v.Extensions))
		for i, val := range v.Extensions {
			res.Extensions[i] = marshalDatabaseExtensionSpecRequestBodyRequestBodyToControlplaneDatabaseExtensionSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfigs != nil {
		res.BackupConfigs = make([]*controlplane.BackupConfigSpec, len(v.BackupConfigs))
		for i, val := range v.BackupConfigs {
			res.BackupConfigs[i] = marshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(val)
		}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec
// builds a value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBodyRequestBody.
func marshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBodyRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            v.Name,
		InstanceID:      v.InstanceID,
		HostID:          v.HostID,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
	}
	if v.ReadReplicas != nil {
		res.ReadReplicas = marshalDatabaseReplicaSpecRequestBodyRequestBodyToControlplaneDatabaseReplicaSpec(v.ReadReplicas)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalDatabaseReplicaSpecRequestBodyRequestBodyToControlplaneDatabaseReplicaSpec
// builds a value of type *controlplane.DatabaseReplicaSpec from a value of
// type *DatabaseReplicaSpecRequestBodyRequestBody.
func marshalDatabaseReplicaSpecRequestBodyRequestBodyToControlplaneDatabaseReplicaSpec(v *DatabaseReplicaSpecRequestBodyRequestBody) *controlplane.DatabaseReplicaSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseReplicaSpec{
		InstanceID: v.InstanceID,
		HostID:     v.HostID,
	}

	return res
}

// marshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec
// builds a value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBodyRequestBody.
func marshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBodyRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username:  v.Username,
		Password:  v.Password,
		Superuser: v.Superuser,
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalDatabaseExtensionSpecRequestBodyRequestBodyToControlplaneDatabaseExtensionSpec
// builds a value of type *controlplane.DatabaseExtensionSpec from a value of
// type *DatabaseExtensionSpecRequestBodyRequestBody.
func marshalDatabaseExtensionSpecRequestBodyRequestBodyToControlplaneDatabaseExtensionSpec(v *DatabaseExtensionSpecRequestBodyRequestBody) *controlplane.DatabaseExtensionSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseExtensionSpec{
		Name:    v.Name,
		Version: v.Version,
	}

	return res
}

// marshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec
// builds a value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBodyRequestBody.
func marshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBodyRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{
		ID:       v.ID,
		Provider: v.Provider,
	}
	if v.NodeNames != nil {
		res.NodeNames = make([]string, len(v.NodeNames))
		for i, val := range v.NodeNames {
			res.NodeNames[i] = val
		}
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// marshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBodyRequestBody.
func marshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBodyRequestBody) *controlplane.BackupRepositorySpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}

	return res
}

// marshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec
// builds a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBodyRequestBody.
func marshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBodyRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}
