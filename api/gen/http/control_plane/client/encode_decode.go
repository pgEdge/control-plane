// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/design

package client

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"

	controlplane "github.com/pgEdge/control-plane/api/gen/control_plane"
	controlplaneviews "github.com/pgEdge/control-plane/api/gen/control_plane/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildInitClusterRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "init-cluster" endpoint
func (c *Client) BuildInitClusterRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: InitClusterControlPlanePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "init-cluster", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeInitClusterResponse returns a decoder for responses returned by the
// control-plane init-cluster endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeInitClusterResponse may return the following errors:
//   - "cluster_already_initialized" (type *goa.ServiceError): http.StatusConflict
//   - error: internal error
func DecodeInitClusterResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body InitClusterResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "init-cluster", err)
			}
			err = ValidateInitClusterResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "init-cluster", err)
			}
			res := NewInitClusterClusterJoinTokenOK(&body)
			return res, nil
		case http.StatusConflict:
			var (
				body InitClusterClusterAlreadyInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "init-cluster", err)
			}
			err = ValidateInitClusterClusterAlreadyInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "init-cluster", err)
			}
			return nil, NewInitClusterClusterAlreadyInitialized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "init-cluster", resp.StatusCode, string(body))
		}
	}
}

// BuildJoinClusterRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "join-cluster" endpoint
func (c *Client) BuildJoinClusterRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: JoinClusterControlPlanePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "join-cluster", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeJoinClusterRequest returns an encoder for requests sent to the
// control-plane join-cluster server.
func EncodeJoinClusterRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*controlplane.ClusterJoinToken)
		if !ok {
			return goahttp.ErrInvalidType("control-plane", "join-cluster", "*controlplane.ClusterJoinToken", v)
		}
		body := NewJoinClusterRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("control-plane", "join-cluster", err)
		}
		return nil
	}
}

// DecodeJoinClusterResponse returns a decoder for responses returned by the
// control-plane join-cluster endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeJoinClusterResponse may return the following errors:
//   - "cluster_already_initialized" (type *goa.ServiceError): http.StatusConflict
//   - error: internal error
func DecodeJoinClusterResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusConflict:
			var (
				body JoinClusterClusterAlreadyInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "join-cluster", err)
			}
			err = ValidateJoinClusterClusterAlreadyInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "join-cluster", err)
			}
			return nil, NewJoinClusterClusterAlreadyInitialized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "join-cluster", resp.StatusCode, string(body))
		}
	}
}

// BuildGetJoinTokenRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "get-join-token" endpoint
func (c *Client) BuildGetJoinTokenRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetJoinTokenControlPlanePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "get-join-token", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetJoinTokenResponse returns a decoder for responses returned by the
// control-plane get-join-token endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetJoinTokenResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - error: internal error
func DecodeGetJoinTokenResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetJoinTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "get-join-token", err)
			}
			err = ValidateGetJoinTokenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "get-join-token", err)
			}
			res := NewGetJoinTokenClusterJoinTokenOK(&body)
			return res, nil
		case http.StatusConflict:
			var (
				body GetJoinTokenClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "get-join-token", err)
			}
			err = ValidateGetJoinTokenClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "get-join-token", err)
			}
			return nil, NewGetJoinTokenClusterNotInitialized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "get-join-token", resp.StatusCode, string(body))
		}
	}
}

// BuildGetJoinOptionsRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "get-join-options" endpoint
func (c *Client) BuildGetJoinOptionsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetJoinOptionsControlPlanePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "get-join-options", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetJoinOptionsRequest returns an encoder for requests sent to the
// control-plane get-join-options server.
func EncodeGetJoinOptionsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*controlplane.ClusterJoinRequest)
		if !ok {
			return goahttp.ErrInvalidType("control-plane", "get-join-options", "*controlplane.ClusterJoinRequest", v)
		}
		body := NewGetJoinOptionsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("control-plane", "get-join-options", err)
		}
		return nil
	}
}

// DecodeGetJoinOptionsResponse returns a decoder for responses returned by the
// control-plane get-join-options endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetJoinOptionsResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - "invalid_join_token" (type *goa.ServiceError): http.StatusUnauthorized
//   - error: internal error
func DecodeGetJoinOptionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetJoinOptionsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "get-join-options", err)
			}
			err = ValidateGetJoinOptionsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "get-join-options", err)
			}
			res := NewGetJoinOptionsClusterJoinOptionsOK(&body)
			return res, nil
		case http.StatusConflict:
			var (
				body GetJoinOptionsClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "get-join-options", err)
			}
			err = ValidateGetJoinOptionsClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "get-join-options", err)
			}
			return nil, NewGetJoinOptionsClusterNotInitialized(&body)
		case http.StatusUnauthorized:
			var (
				body GetJoinOptionsInvalidJoinTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "get-join-options", err)
			}
			err = ValidateGetJoinOptionsInvalidJoinTokenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "get-join-options", err)
			}
			return nil, NewGetJoinOptionsInvalidJoinToken(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "get-join-options", resp.StatusCode, string(body))
		}
	}
}

// BuildInspectClusterRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "inspect-cluster" endpoint
func (c *Client) BuildInspectClusterRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: InspectClusterControlPlanePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "inspect-cluster", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeInspectClusterResponse returns a decoder for responses returned by the
// control-plane inspect-cluster endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeInspectClusterResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - error: internal error
func DecodeInspectClusterResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body InspectClusterResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-cluster", err)
			}
			err = ValidateInspectClusterResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-cluster", err)
			}
			res := NewInspectClusterClusterOK(&body)
			return res, nil
		case http.StatusConflict:
			var (
				body InspectClusterClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-cluster", err)
			}
			err = ValidateInspectClusterClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-cluster", err)
			}
			return nil, NewInspectClusterClusterNotInitialized(&body)
		case http.StatusNotFound:
			var (
				body InspectClusterNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-cluster", err)
			}
			err = ValidateInspectClusterNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-cluster", err)
			}
			return nil, NewInspectClusterNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "inspect-cluster", resp.StatusCode, string(body))
		}
	}
}

// BuildListHostsRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "list-hosts" endpoint
func (c *Client) BuildListHostsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListHostsControlPlanePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "list-hosts", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeListHostsResponse returns a decoder for responses returned by the
// control-plane list-hosts endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeListHostsResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - error: internal error
func DecodeListHostsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListHostsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "list-hosts", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateHostResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "list-hosts", err)
			}
			res := NewListHostsHostOK(body)
			return res, nil
		case http.StatusConflict:
			var (
				body ListHostsClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "list-hosts", err)
			}
			err = ValidateListHostsClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "list-hosts", err)
			}
			return nil, NewListHostsClusterNotInitialized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "list-hosts", resp.StatusCode, string(body))
		}
	}
}

// BuildInspectHostRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "inspect-host" endpoint
func (c *Client) BuildInspectHostRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		hostID string
	)
	{
		p, ok := v.(*controlplane.InspectHostPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "inspect-host", "*controlplane.InspectHostPayload", v)
		}
		if p.HostID != nil {
			hostID = *p.HostID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: InspectHostControlPlanePath(hostID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "inspect-host", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeInspectHostResponse returns a decoder for responses returned by the
// control-plane inspect-host endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeInspectHostResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - error: internal error
func DecodeInspectHostResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body InspectHostResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-host", err)
			}
			err = ValidateInspectHostResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-host", err)
			}
			res := NewInspectHostHostOK(&body)
			return res, nil
		case http.StatusConflict:
			var (
				body InspectHostClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-host", err)
			}
			err = ValidateInspectHostClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-host", err)
			}
			return nil, NewInspectHostClusterNotInitialized(&body)
		case http.StatusNotFound:
			var (
				body InspectHostNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-host", err)
			}
			err = ValidateInspectHostNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-host", err)
			}
			return nil, NewInspectHostNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "inspect-host", resp.StatusCode, string(body))
		}
	}
}

// BuildRemoveHostRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "remove-host" endpoint
func (c *Client) BuildRemoveHostRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		hostID string
	)
	{
		p, ok := v.(*controlplane.RemoveHostPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "remove-host", "*controlplane.RemoveHostPayload", v)
		}
		if p.HostID != nil {
			hostID = *p.HostID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RemoveHostControlPlanePath(hostID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "remove-host", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeRemoveHostResponse returns a decoder for responses returned by the
// control-plane remove-host endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeRemoveHostResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - error: internal error
func DecodeRemoveHostResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusConflict:
			var (
				body RemoveHostClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "remove-host", err)
			}
			err = ValidateRemoveHostClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "remove-host", err)
			}
			return nil, NewRemoveHostClusterNotInitialized(&body)
		case http.StatusNotFound:
			var (
				body RemoveHostNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "remove-host", err)
			}
			err = ValidateRemoveHostNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "remove-host", err)
			}
			return nil, NewRemoveHostNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "remove-host", resp.StatusCode, string(body))
		}
	}
}

// BuildListDatabasesRequest instantiates a HTTP request object with method and
// path set to call the "control-plane" service "list-databases" endpoint
func (c *Client) BuildListDatabasesRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListDatabasesControlPlanePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "list-databases", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeListDatabasesResponse returns a decoder for responses returned by the
// control-plane list-databases endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeListDatabasesResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - error: internal error
func DecodeListDatabasesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListDatabasesResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "list-databases", err)
			}
			p := NewListDatabasesDatabaseCollectionOK(body)
			view := "abbreviated"
			vres := controlplaneviews.DatabaseCollection{Projected: p, View: view}
			if err = controlplaneviews.ValidateDatabaseCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "list-databases", err)
			}
			res := controlplane.NewDatabaseCollection(vres)
			return res, nil
		case http.StatusConflict:
			var (
				body ListDatabasesClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "list-databases", err)
			}
			err = ValidateListDatabasesClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "list-databases", err)
			}
			return nil, NewListDatabasesClusterNotInitialized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "list-databases", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateDatabaseRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "create-database" endpoint
func (c *Client) BuildCreateDatabaseRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateDatabaseControlPlanePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "create-database", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateDatabaseRequest returns an encoder for requests sent to the
// control-plane create-database server.
func EncodeCreateDatabaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*controlplane.CreateDatabaseRequest)
		if !ok {
			return goahttp.ErrInvalidType("control-plane", "create-database", "*controlplane.CreateDatabaseRequest", v)
		}
		body := NewCreateDatabaseRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("control-plane", "create-database", err)
		}
		return nil
	}
}

// DecodeCreateDatabaseResponse returns a decoder for responses returned by the
// control-plane create-database endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCreateDatabaseResponse may return the following errors:
//   - "database_already_exists" (type *goa.ServiceError): http.StatusConflict
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - "invalid_input" (type *goa.ServiceError): http.StatusBadRequest
//   - error: internal error
func DecodeCreateDatabaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CreateDatabaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "create-database", err)
			}
			p := NewCreateDatabaseDatabaseOK(&body)
			view := "default"
			vres := &controlplaneviews.Database{Projected: p, View: view}
			if err = controlplaneviews.ValidateDatabase(vres); err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "create-database", err)
			}
			res := controlplane.NewDatabase(vres)
			return res, nil
		case http.StatusConflict:
			en := resp.Header.Get("goa-error")
			switch en {
			case "database_already_exists":
				var (
					body CreateDatabaseDatabaseAlreadyExistsResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("control-plane", "create-database", err)
				}
				err = ValidateCreateDatabaseDatabaseAlreadyExistsResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("control-plane", "create-database", err)
				}
				return nil, NewCreateDatabaseDatabaseAlreadyExists(&body)
			case "cluster_not_initialized":
				var (
					body CreateDatabaseClusterNotInitializedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("control-plane", "create-database", err)
				}
				err = ValidateCreateDatabaseClusterNotInitializedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("control-plane", "create-database", err)
				}
				return nil, NewCreateDatabaseClusterNotInitialized(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("control-plane", "create-database", resp.StatusCode, string(body))
			}
		case http.StatusBadRequest:
			var (
				body CreateDatabaseInvalidInputResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "create-database", err)
			}
			err = ValidateCreateDatabaseInvalidInputResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "create-database", err)
			}
			return nil, NewCreateDatabaseInvalidInput(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "create-database", resp.StatusCode, string(body))
		}
	}
}

// BuildInspectDatabaseRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "inspect-database" endpoint
func (c *Client) BuildInspectDatabaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		databaseID string
	)
	{
		p, ok := v.(*controlplane.InspectDatabasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "inspect-database", "*controlplane.InspectDatabasePayload", v)
		}
		if p.DatabaseID != nil {
			databaseID = *p.DatabaseID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: InspectDatabaseControlPlanePath(databaseID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "inspect-database", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeInspectDatabaseResponse returns a decoder for responses returned by
// the control-plane inspect-database endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeInspectDatabaseResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - error: internal error
func DecodeInspectDatabaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body InspectDatabaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-database", err)
			}
			p := NewInspectDatabaseDatabaseOK(&body)
			view := "default"
			vres := &controlplaneviews.Database{Projected: p, View: view}
			if err = controlplaneviews.ValidateDatabase(vres); err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-database", err)
			}
			res := controlplane.NewDatabase(vres)
			return res, nil
		case http.StatusConflict:
			var (
				body InspectDatabaseClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-database", err)
			}
			err = ValidateInspectDatabaseClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-database", err)
			}
			return nil, NewInspectDatabaseClusterNotInitialized(&body)
		case http.StatusNotFound:
			var (
				body InspectDatabaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "inspect-database", err)
			}
			err = ValidateInspectDatabaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "inspect-database", err)
			}
			return nil, NewInspectDatabaseNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "inspect-database", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateDatabaseRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "update-database" endpoint
func (c *Client) BuildUpdateDatabaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		databaseID string
	)
	{
		p, ok := v.(*controlplane.UpdateDatabasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "update-database", "*controlplane.UpdateDatabasePayload", v)
		}
		if p.DatabaseID != nil {
			databaseID = *p.DatabaseID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateDatabaseControlPlanePath(databaseID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "update-database", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateDatabaseRequest returns an encoder for requests sent to the
// control-plane update-database server.
func EncodeUpdateDatabaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*controlplane.UpdateDatabasePayload)
		if !ok {
			return goahttp.ErrInvalidType("control-plane", "update-database", "*controlplane.UpdateDatabasePayload", v)
		}
		values := req.URL.Query()
		if p.ForceUpdate != nil {
			values.Add("force_update", fmt.Sprintf("%v", *p.ForceUpdate))
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateDatabaseRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("control-plane", "update-database", err)
		}
		return nil
	}
}

// DecodeUpdateDatabaseResponse returns a decoder for responses returned by the
// control-plane update-database endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeUpdateDatabaseResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - error: internal error
func DecodeUpdateDatabaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateDatabaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "update-database", err)
			}
			p := NewUpdateDatabaseDatabaseOK(&body)
			view := "default"
			vres := &controlplaneviews.Database{Projected: p, View: view}
			if err = controlplaneviews.ValidateDatabase(vres); err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "update-database", err)
			}
			res := controlplane.NewDatabase(vres)
			return res, nil
		case http.StatusConflict:
			var (
				body UpdateDatabaseClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "update-database", err)
			}
			err = ValidateUpdateDatabaseClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "update-database", err)
			}
			return nil, NewUpdateDatabaseClusterNotInitialized(&body)
		case http.StatusNotFound:
			var (
				body UpdateDatabaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "update-database", err)
			}
			err = ValidateUpdateDatabaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "update-database", err)
			}
			return nil, NewUpdateDatabaseNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "update-database", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteDatabaseRequest instantiates a HTTP request object with method
// and path set to call the "control-plane" service "delete-database" endpoint
func (c *Client) BuildDeleteDatabaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		databaseID string
	)
	{
		p, ok := v.(*controlplane.DeleteDatabasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("control-plane", "delete-database", "*controlplane.DeleteDatabasePayload", v)
		}
		if p.DatabaseID != nil {
			databaseID = *p.DatabaseID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteDatabaseControlPlanePath(databaseID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("control-plane", "delete-database", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeDeleteDatabaseResponse returns a decoder for responses returned by the
// control-plane delete-database endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDeleteDatabaseResponse may return the following errors:
//   - "cluster_not_initialized" (type *goa.ServiceError): http.StatusConflict
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - error: internal error
func DecodeDeleteDatabaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusConflict:
			var (
				body DeleteDatabaseClusterNotInitializedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "delete-database", err)
			}
			err = ValidateDeleteDatabaseClusterNotInitializedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "delete-database", err)
			}
			return nil, NewDeleteDatabaseClusterNotInitialized(&body)
		case http.StatusNotFound:
			var (
				body DeleteDatabaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("control-plane", "delete-database", err)
			}
			err = ValidateDeleteDatabaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("control-plane", "delete-database", err)
			}
			return nil, NewDeleteDatabaseNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("control-plane", "delete-database", resp.StatusCode, string(body))
		}
	}
}

// unmarshalClusterPeerResponseBodyToControlplaneClusterPeer builds a value of
// type *controlplane.ClusterPeer from a value of type *ClusterPeerResponseBody.
func unmarshalClusterPeerResponseBodyToControlplaneClusterPeer(v *ClusterPeerResponseBody) *controlplane.ClusterPeer {
	res := &controlplane.ClusterPeer{
		Name:      *v.Name,
		PeerURL:   *v.PeerURL,
		ClientURL: *v.ClientURL,
	}

	return res
}

// unmarshalClusterCredentialsResponseBodyToControlplaneClusterCredentials
// builds a value of type *controlplane.ClusterCredentials from a value of type
// *ClusterCredentialsResponseBody.
func unmarshalClusterCredentialsResponseBodyToControlplaneClusterCredentials(v *ClusterCredentialsResponseBody) *controlplane.ClusterCredentials {
	if v == nil {
		return nil
	}
	res := &controlplane.ClusterCredentials{
		CaCert:     *v.CaCert,
		ClientCert: *v.ClientCert,
		ClientKey:  *v.ClientKey,
		ServerCert: *v.ServerCert,
		ServerKey:  *v.ServerKey,
	}

	return res
}

// unmarshalClusterStatusResponseBodyToControlplaneClusterStatus builds a value
// of type *controlplane.ClusterStatus from a value of type
// *ClusterStatusResponseBody.
func unmarshalClusterStatusResponseBodyToControlplaneClusterStatus(v *ClusterStatusResponseBody) *controlplane.ClusterStatus {
	res := &controlplane.ClusterStatus{
		State: *v.State,
	}

	return res
}

// unmarshalHostResponseBodyToControlplaneHost builds a value of type
// *controlplane.Host from a value of type *HostResponseBody.
func unmarshalHostResponseBodyToControlplaneHost(v *HostResponseBody) *controlplane.Host {
	res := &controlplane.Host{
		ID:           *v.ID,
		Orchestrator: *v.Orchestrator,
		Hostname:     *v.Hostname,
		Ipv4Address:  *v.Ipv4Address,
		Cpus:         *v.Cpus,
		Memory:       *v.Memory,
	}
	if v.Cohort != nil {
		res.Cohort = unmarshalHostCohortResponseBodyToControlplaneHostCohort(v.Cohort)
	}
	res.Status = unmarshalHostStatusResponseBodyToControlplaneHostStatus(v.Status)
	res.DefaultPgedgeVersion = unmarshalPgEdgeVersionResponseBodyToControlplanePgEdgeVersion(v.DefaultPgedgeVersion)
	res.SupportedPgedgeVersions = make([]*controlplane.PgEdgeVersion, len(v.SupportedPgedgeVersions))
	for i, val := range v.SupportedPgedgeVersions {
		res.SupportedPgedgeVersions[i] = unmarshalPgEdgeVersionResponseBodyToControlplanePgEdgeVersion(val)
	}

	return res
}

// unmarshalHostCohortResponseBodyToControlplaneHostCohort builds a value of
// type *controlplane.HostCohort from a value of type *HostCohortResponseBody.
func unmarshalHostCohortResponseBodyToControlplaneHostCohort(v *HostCohortResponseBody) *controlplane.HostCohort {
	if v == nil {
		return nil
	}
	res := &controlplane.HostCohort{
		Type:             *v.Type,
		CohortID:         *v.CohortID,
		MemberID:         *v.MemberID,
		ControlAvailable: *v.ControlAvailable,
	}

	return res
}

// unmarshalHostStatusResponseBodyToControlplaneHostStatus builds a value of
// type *controlplane.HostStatus from a value of type *HostStatusResponseBody.
func unmarshalHostStatusResponseBodyToControlplaneHostStatus(v *HostStatusResponseBody) *controlplane.HostStatus {
	res := &controlplane.HostStatus{
		State:     *v.State,
		UpdatedAt: *v.UpdatedAt,
	}
	res.Components = make(map[string]*controlplane.ComponentStatus, len(v.Components))
	for key, val := range v.Components {
		tk := key
		if val == nil {
			res.Components[tk] = nil
			continue
		}
		res.Components[tk] = unmarshalComponentStatusResponseBodyToControlplaneComponentStatus(val)
	}

	return res
}

// unmarshalComponentStatusResponseBodyToControlplaneComponentStatus builds a
// value of type *controlplane.ComponentStatus from a value of type
// *ComponentStatusResponseBody.
func unmarshalComponentStatusResponseBodyToControlplaneComponentStatus(v *ComponentStatusResponseBody) *controlplane.ComponentStatus {
	res := &controlplane.ComponentStatus{
		Healthy: v.Healthy,
		Error:   *v.Error,
	}
	res.Details = make(map[string]any, len(v.Details))
	for key, val := range v.Details {
		tk := key
		tv := val
		res.Details[tk] = tv
	}

	return res
}

// unmarshalPgEdgeVersionResponseBodyToControlplanePgEdgeVersion builds a value
// of type *controlplane.PgEdgeVersion from a value of type
// *PgEdgeVersionResponseBody.
func unmarshalPgEdgeVersionResponseBodyToControlplanePgEdgeVersion(v *PgEdgeVersionResponseBody) *controlplane.PgEdgeVersion {
	res := &controlplane.PgEdgeVersion{
		PostgresVersion: *v.PostgresVersion,
		SpockVersion:    *v.SpockVersion,
	}

	return res
}

// unmarshalHostResponseToControlplaneHost builds a value of type
// *controlplane.Host from a value of type *HostResponse.
func unmarshalHostResponseToControlplaneHost(v *HostResponse) *controlplane.Host {
	res := &controlplane.Host{
		ID:           *v.ID,
		Orchestrator: *v.Orchestrator,
		Hostname:     *v.Hostname,
		Ipv4Address:  *v.Ipv4Address,
		Cpus:         *v.Cpus,
		Memory:       *v.Memory,
	}
	if v.Cohort != nil {
		res.Cohort = unmarshalHostCohortResponseToControlplaneHostCohort(v.Cohort)
	}
	res.Status = unmarshalHostStatusResponseToControlplaneHostStatus(v.Status)
	res.DefaultPgedgeVersion = unmarshalPgEdgeVersionResponseToControlplanePgEdgeVersion(v.DefaultPgedgeVersion)
	res.SupportedPgedgeVersions = make([]*controlplane.PgEdgeVersion, len(v.SupportedPgedgeVersions))
	for i, val := range v.SupportedPgedgeVersions {
		res.SupportedPgedgeVersions[i] = unmarshalPgEdgeVersionResponseToControlplanePgEdgeVersion(val)
	}

	return res
}

// unmarshalHostCohortResponseToControlplaneHostCohort builds a value of type
// *controlplane.HostCohort from a value of type *HostCohortResponse.
func unmarshalHostCohortResponseToControlplaneHostCohort(v *HostCohortResponse) *controlplane.HostCohort {
	if v == nil {
		return nil
	}
	res := &controlplane.HostCohort{
		Type:             *v.Type,
		CohortID:         *v.CohortID,
		MemberID:         *v.MemberID,
		ControlAvailable: *v.ControlAvailable,
	}

	return res
}

// unmarshalHostStatusResponseToControlplaneHostStatus builds a value of type
// *controlplane.HostStatus from a value of type *HostStatusResponse.
func unmarshalHostStatusResponseToControlplaneHostStatus(v *HostStatusResponse) *controlplane.HostStatus {
	res := &controlplane.HostStatus{
		State:     *v.State,
		UpdatedAt: *v.UpdatedAt,
	}
	res.Components = make(map[string]*controlplane.ComponentStatus, len(v.Components))
	for key, val := range v.Components {
		tk := key
		if val == nil {
			res.Components[tk] = nil
			continue
		}
		res.Components[tk] = unmarshalComponentStatusResponseToControlplaneComponentStatus(val)
	}

	return res
}

// unmarshalComponentStatusResponseToControlplaneComponentStatus builds a value
// of type *controlplane.ComponentStatus from a value of type
// *ComponentStatusResponse.
func unmarshalComponentStatusResponseToControlplaneComponentStatus(v *ComponentStatusResponse) *controlplane.ComponentStatus {
	res := &controlplane.ComponentStatus{
		Healthy: v.Healthy,
		Error:   *v.Error,
	}
	res.Details = make(map[string]any, len(v.Details))
	for key, val := range v.Details {
		tk := key
		tv := val
		res.Details[tk] = tv
	}

	return res
}

// unmarshalPgEdgeVersionResponseToControlplanePgEdgeVersion builds a value of
// type *controlplane.PgEdgeVersion from a value of type *PgEdgeVersionResponse.
func unmarshalPgEdgeVersionResponseToControlplanePgEdgeVersion(v *PgEdgeVersionResponse) *controlplane.PgEdgeVersion {
	res := &controlplane.PgEdgeVersion{
		PostgresVersion: *v.PostgresVersion,
		SpockVersion:    *v.SpockVersion,
	}

	return res
}

// unmarshalDatabaseResponseToControlplaneviewsDatabaseView builds a value of
// type *controlplaneviews.DatabaseView from a value of type *DatabaseResponse.
func unmarshalDatabaseResponseToControlplaneviewsDatabaseView(v *DatabaseResponse) *controlplaneviews.DatabaseView {
	res := &controlplaneviews.DatabaseView{
		ID:        v.ID,
		TenantID:  v.TenantID,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
		State:     v.State,
	}
	if v.Instances != nil {
		res.Instances = make([]*controlplaneviews.InstanceView, len(v.Instances))
		for i, val := range v.Instances {
			res.Instances[i] = unmarshalInstanceResponseToControlplaneviewsInstanceView(val)
		}
	}
	if v.Spec != nil {
		res.Spec = unmarshalDatabaseSpecResponseToControlplaneviewsDatabaseSpecView(v.Spec)
	}

	return res
}

// unmarshalInstanceResponseToControlplaneviewsInstanceView builds a value of
// type *controlplaneviews.InstanceView from a value of type *InstanceResponse.
func unmarshalInstanceResponseToControlplaneviewsInstanceView(v *InstanceResponse) *controlplaneviews.InstanceView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.InstanceView{
		ID:              v.ID,
		HostID:          v.HostID,
		NodeName:        v.NodeName,
		CreatedAt:       v.CreatedAt,
		UpdatedAt:       v.UpdatedAt,
		State:           v.State,
		PatroniState:    v.PatroniState,
		Role:            v.Role,
		ReadOnly:        v.ReadOnly,
		PendingRestart:  v.PendingRestart,
		PatroniPaused:   v.PatroniPaused,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
	}
	if v.Interfaces != nil {
		res.Interfaces = make([]*controlplaneviews.InstanceInterfaceView, len(v.Interfaces))
		for i, val := range v.Interfaces {
			res.Interfaces[i] = unmarshalInstanceInterfaceResponseToControlplaneviewsInstanceInterfaceView(val)
		}
	}

	return res
}

// unmarshalInstanceInterfaceResponseToControlplaneviewsInstanceInterfaceView
// builds a value of type *controlplaneviews.InstanceInterfaceView from a value
// of type *InstanceInterfaceResponse.
func unmarshalInstanceInterfaceResponseToControlplaneviewsInstanceInterfaceView(v *InstanceInterfaceResponse) *controlplaneviews.InstanceInterfaceView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.InstanceInterfaceView{
		NetworkType: v.NetworkType,
		NetworkID:   v.NetworkID,
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// unmarshalDatabaseSpecResponseToControlplaneviewsDatabaseSpecView builds a
// value of type *controlplaneviews.DatabaseSpecView from a value of type
// *DatabaseSpecResponse.
func unmarshalDatabaseSpecResponseToControlplaneviewsDatabaseSpecView(v *DatabaseSpecResponse) *controlplaneviews.DatabaseSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.DatabaseSpecView{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	res.Nodes = make([]*controlplaneviews.DatabaseNodeSpecView, len(v.Nodes))
	for i, val := range v.Nodes {
		res.Nodes[i] = unmarshalDatabaseNodeSpecResponseToControlplaneviewsDatabaseNodeSpecView(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplaneviews.DatabaseUserSpecView, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecResponseToControlplaneviewsDatabaseUserSpecView(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecResponseToControlplaneviewsBackupConfigSpecView(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecResponseToControlplaneviewsRestoreConfigSpecView(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseNodeSpecResponseToControlplaneviewsDatabaseNodeSpecView
// builds a value of type *controlplaneviews.DatabaseNodeSpecView from a value
// of type *DatabaseNodeSpecResponse.
func unmarshalDatabaseNodeSpecResponseToControlplaneviewsDatabaseNodeSpecView(v *DatabaseNodeSpecResponse) *controlplaneviews.DatabaseNodeSpecView {
	res := &controlplaneviews.DatabaseNodeSpecView{
		Name:            v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	res.HostIds = make([]string, len(v.HostIds))
	for i, val := range v.HostIds {
		res.HostIds[i] = val
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecResponseToControlplaneviewsBackupConfigSpecView(v.BackupConfig)
	}

	return res
}

// unmarshalBackupConfigSpecResponseToControlplaneviewsBackupConfigSpecView
// builds a value of type *controlplaneviews.BackupConfigSpecView from a value
// of type *BackupConfigSpecResponse.
func unmarshalBackupConfigSpecResponseToControlplaneviewsBackupConfigSpecView(v *BackupConfigSpecResponse) *controlplaneviews.BackupConfigSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.BackupConfigSpecView{
		Provider: v.Provider,
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplaneviews.BackupRepositorySpecView, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = unmarshalBackupRepositorySpecResponseToControlplaneviewsBackupRepositorySpecView(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplaneviews.BackupScheduleSpecView, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = unmarshalBackupScheduleSpecResponseToControlplaneviewsBackupScheduleSpecView(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecResponseToControlplaneviewsBackupRepositorySpecView
// builds a value of type *controlplaneviews.BackupRepositorySpecView from a
// value of type *BackupRepositorySpecResponse.
func unmarshalBackupRepositorySpecResponseToControlplaneviewsBackupRepositorySpecView(v *BackupRepositorySpecResponse) *controlplaneviews.BackupRepositorySpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.BackupRepositorySpecView{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalBackupScheduleSpecResponseToControlplaneviewsBackupScheduleSpecView
// builds a value of type *controlplaneviews.BackupScheduleSpecView from a
// value of type *BackupScheduleSpecResponse.
func unmarshalBackupScheduleSpecResponseToControlplaneviewsBackupScheduleSpecView(v *BackupScheduleSpecResponse) *controlplaneviews.BackupScheduleSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.BackupScheduleSpecView{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// unmarshalDatabaseUserSpecResponseToControlplaneviewsDatabaseUserSpecView
// builds a value of type *controlplaneviews.DatabaseUserSpecView from a value
// of type *DatabaseUserSpecResponse.
func unmarshalDatabaseUserSpecResponseToControlplaneviewsDatabaseUserSpecView(v *DatabaseUserSpecResponse) *controlplaneviews.DatabaseUserSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.DatabaseUserSpecView{
		Username: v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// unmarshalRestoreConfigSpecResponseToControlplaneviewsRestoreConfigSpecView
// builds a value of type *controlplaneviews.RestoreConfigSpecView from a value
// of type *RestoreConfigSpecResponse.
func unmarshalRestoreConfigSpecResponseToControlplaneviewsRestoreConfigSpecView(v *RestoreConfigSpecResponse) *controlplaneviews.RestoreConfigSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.RestoreConfigSpecView{
		Provider:     v.Provider,
		DatabaseID:   v.DatabaseID,
		NodeName:     v.NodeName,
		DatabaseName: v.DatabaseName,
	}
	res.Repository = unmarshalRestoreRepositorySpecResponseToControlplaneviewsRestoreRepositorySpecView(v.Repository)

	return res
}

// unmarshalRestoreRepositorySpecResponseToControlplaneviewsRestoreRepositorySpecView
// builds a value of type *controlplaneviews.RestoreRepositorySpecView from a
// value of type *RestoreRepositorySpecResponse.
func unmarshalRestoreRepositorySpecResponseToControlplaneviewsRestoreRepositorySpecView(v *RestoreRepositorySpecResponse) *controlplaneviews.RestoreRepositorySpecView {
	res := &controlplaneviews.RestoreRepositorySpecView{
		ID:             v.ID,
		Type:           v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseSpecToDatabaseSpecRequestBody builds a value of
// type *DatabaseSpecRequestBody from a value of type
// *controlplane.DatabaseSpec.
func marshalControlplaneDatabaseSpecToDatabaseSpecRequestBody(v *controlplane.DatabaseSpec) *DatabaseSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecRequestBody{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecRequestBody, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBody(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecRequestBody{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecRequestBody, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBody(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneRestoreConfigSpecToRestoreConfigSpecRequestBody(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBody builds a
// value of type *DatabaseNodeSpecRequestBody from a value of type
// *controlplane.DatabaseNodeSpec.
func marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBody(v *controlplane.DatabaseNodeSpec) *DatabaseNodeSpecRequestBody {
	res := &DatabaseNodeSpecRequestBody{
		Name:            v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = val
		}
	} else {
		res.HostIds = []string{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBody(v.BackupConfig)
	}

	return res
}

// marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBody builds a
// value of type *BackupConfigSpecRequestBody from a value of type
// *controlplane.BackupConfigSpec.
func marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBody(v *controlplane.BackupConfigSpec) *BackupConfigSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecRequestBody{
		Provider: v.Provider,
	}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecRequestBody, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBody(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecRequestBody, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBody(val)
		}
	}

	return res
}

// marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBody
// builds a value of type *BackupRepositorySpecRequestBody from a value of type
// *controlplane.BackupRepositorySpec.
func marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBody(v *controlplane.BackupRepositorySpec) *BackupRepositorySpecRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupRepositorySpecRequestBody{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBody builds
// a value of type *BackupScheduleSpecRequestBody from a value of type
// *controlplane.BackupScheduleSpec.
func marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBody(v *controlplane.BackupScheduleSpec) *BackupScheduleSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecRequestBody{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBody builds a
// value of type *DatabaseUserSpecRequestBody from a value of type
// *controlplane.DatabaseUserSpec.
func marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBody(v *controlplane.DatabaseUserSpec) *DatabaseUserSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecRequestBody{
		Username: v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneRestoreConfigSpecToRestoreConfigSpecRequestBody builds a
// value of type *RestoreConfigSpecRequestBody from a value of type
// *controlplane.RestoreConfigSpec.
func marshalControlplaneRestoreConfigSpecToRestoreConfigSpecRequestBody(v *controlplane.RestoreConfigSpec) *RestoreConfigSpecRequestBody {
	if v == nil {
		return nil
	}
	res := &RestoreConfigSpecRequestBody{
		Provider:     v.Provider,
		DatabaseID:   v.DatabaseID,
		NodeName:     v.NodeName,
		DatabaseName: v.DatabaseName,
	}
	if v.Repository != nil {
		res.Repository = marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecRequestBody(v.Repository)
	}

	return res
}

// marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecRequestBody
// builds a value of type *RestoreRepositorySpecRequestBody from a value of
// type *controlplane.RestoreRepositorySpec.
func marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecRequestBody(v *controlplane.RestoreRepositorySpec) *RestoreRepositorySpecRequestBody {
	res := &RestoreRepositorySpecRequestBody{
		ID:             v.ID,
		Type:           v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec builds a value of
// type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBody.
func marshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBody) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(val)
		}
	} else {
		res.Nodes = []*controlplane.DatabaseNodeSpec{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec builds a
// value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBody.
func marshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = val
		}
	} else {
		res.HostIds = []string{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}

	return res
}

// marshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec builds a
// value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBody.
func marshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{
		Provider: v.Provider,
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// marshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBody.
func marshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBody) *controlplane.BackupRepositorySpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec builds
// a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBody.
func marshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// marshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec builds a
// value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBody.
func marshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username: v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec builds a
// value of type *controlplane.RestoreConfigSpec from a value of type
// *RestoreConfigSpecRequestBody.
func marshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec(v *RestoreConfigSpecRequestBody) *controlplane.RestoreConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.RestoreConfigSpec{
		Provider:     v.Provider,
		DatabaseID:   v.DatabaseID,
		NodeName:     v.NodeName,
		DatabaseName: v.DatabaseName,
	}
	if v.Repository != nil {
		res.Repository = marshalRestoreRepositorySpecRequestBodyToControlplaneRestoreRepositorySpec(v.Repository)
	}

	return res
}

// marshalRestoreRepositorySpecRequestBodyToControlplaneRestoreRepositorySpec
// builds a value of type *controlplane.RestoreRepositorySpec from a value of
// type *RestoreRepositorySpecRequestBody.
func marshalRestoreRepositorySpecRequestBodyToControlplaneRestoreRepositorySpec(v *RestoreRepositorySpecRequestBody) *controlplane.RestoreRepositorySpec {
	res := &controlplane.RestoreRepositorySpec{
		ID:             v.ID,
		Type:           v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalInstanceResponseBodyAbbreviatedToControlplaneviewsInstanceView
// builds a value of type *controlplaneviews.InstanceView from a value of type
// *InstanceResponseBodyAbbreviated.
func unmarshalInstanceResponseBodyAbbreviatedToControlplaneviewsInstanceView(v *InstanceResponseBodyAbbreviated) *controlplaneviews.InstanceView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.InstanceView{
		ID:       v.ID,
		HostID:   v.HostID,
		NodeName: v.NodeName,
		State:    v.State,
	}

	return res
}

// unmarshalDatabaseSpecResponseBodyToControlplaneviewsDatabaseSpecView builds
// a value of type *controlplaneviews.DatabaseSpecView from a value of type
// *DatabaseSpecResponseBody.
func unmarshalDatabaseSpecResponseBodyToControlplaneviewsDatabaseSpecView(v *DatabaseSpecResponseBody) *controlplaneviews.DatabaseSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.DatabaseSpecView{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	res.Nodes = make([]*controlplaneviews.DatabaseNodeSpecView, len(v.Nodes))
	for i, val := range v.Nodes {
		res.Nodes[i] = unmarshalDatabaseNodeSpecResponseBodyToControlplaneviewsDatabaseNodeSpecView(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplaneviews.DatabaseUserSpecView, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecResponseBodyToControlplaneviewsDatabaseUserSpecView(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecResponseBodyToControlplaneviewsBackupConfigSpecView(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecResponseBodyToControlplaneviewsRestoreConfigSpecView(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseNodeSpecResponseBodyToControlplaneviewsDatabaseNodeSpecView
// builds a value of type *controlplaneviews.DatabaseNodeSpecView from a value
// of type *DatabaseNodeSpecResponseBody.
func unmarshalDatabaseNodeSpecResponseBodyToControlplaneviewsDatabaseNodeSpecView(v *DatabaseNodeSpecResponseBody) *controlplaneviews.DatabaseNodeSpecView {
	res := &controlplaneviews.DatabaseNodeSpecView{
		Name:            v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	res.HostIds = make([]string, len(v.HostIds))
	for i, val := range v.HostIds {
		res.HostIds[i] = val
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecResponseBodyToControlplaneviewsBackupConfigSpecView(v.BackupConfig)
	}

	return res
}

// unmarshalBackupConfigSpecResponseBodyToControlplaneviewsBackupConfigSpecView
// builds a value of type *controlplaneviews.BackupConfigSpecView from a value
// of type *BackupConfigSpecResponseBody.
func unmarshalBackupConfigSpecResponseBodyToControlplaneviewsBackupConfigSpecView(v *BackupConfigSpecResponseBody) *controlplaneviews.BackupConfigSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.BackupConfigSpecView{
		Provider: v.Provider,
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplaneviews.BackupRepositorySpecView, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = unmarshalBackupRepositorySpecResponseBodyToControlplaneviewsBackupRepositorySpecView(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplaneviews.BackupScheduleSpecView, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = unmarshalBackupScheduleSpecResponseBodyToControlplaneviewsBackupScheduleSpecView(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecResponseBodyToControlplaneviewsBackupRepositorySpecView
// builds a value of type *controlplaneviews.BackupRepositorySpecView from a
// value of type *BackupRepositorySpecResponseBody.
func unmarshalBackupRepositorySpecResponseBodyToControlplaneviewsBackupRepositorySpecView(v *BackupRepositorySpecResponseBody) *controlplaneviews.BackupRepositorySpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.BackupRepositorySpecView{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalBackupScheduleSpecResponseBodyToControlplaneviewsBackupScheduleSpecView
// builds a value of type *controlplaneviews.BackupScheduleSpecView from a
// value of type *BackupScheduleSpecResponseBody.
func unmarshalBackupScheduleSpecResponseBodyToControlplaneviewsBackupScheduleSpecView(v *BackupScheduleSpecResponseBody) *controlplaneviews.BackupScheduleSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.BackupScheduleSpecView{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// unmarshalDatabaseUserSpecResponseBodyToControlplaneviewsDatabaseUserSpecView
// builds a value of type *controlplaneviews.DatabaseUserSpecView from a value
// of type *DatabaseUserSpecResponseBody.
func unmarshalDatabaseUserSpecResponseBodyToControlplaneviewsDatabaseUserSpecView(v *DatabaseUserSpecResponseBody) *controlplaneviews.DatabaseUserSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.DatabaseUserSpecView{
		Username: v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// unmarshalRestoreConfigSpecResponseBodyToControlplaneviewsRestoreConfigSpecView
// builds a value of type *controlplaneviews.RestoreConfigSpecView from a value
// of type *RestoreConfigSpecResponseBody.
func unmarshalRestoreConfigSpecResponseBodyToControlplaneviewsRestoreConfigSpecView(v *RestoreConfigSpecResponseBody) *controlplaneviews.RestoreConfigSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.RestoreConfigSpecView{
		Provider:     v.Provider,
		DatabaseID:   v.DatabaseID,
		NodeName:     v.NodeName,
		DatabaseName: v.DatabaseName,
	}
	res.Repository = unmarshalRestoreRepositorySpecResponseBodyToControlplaneviewsRestoreRepositorySpecView(v.Repository)

	return res
}

// unmarshalRestoreRepositorySpecResponseBodyToControlplaneviewsRestoreRepositorySpecView
// builds a value of type *controlplaneviews.RestoreRepositorySpecView from a
// value of type *RestoreRepositorySpecResponseBody.
func unmarshalRestoreRepositorySpecResponseBodyToControlplaneviewsRestoreRepositorySpecView(v *RestoreRepositorySpecResponseBody) *controlplaneviews.RestoreRepositorySpecView {
	res := &controlplaneviews.RestoreRepositorySpecView{
		ID:             v.ID,
		Type:           v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseSpecToDatabaseSpecRequestBodyRequestBody builds a
// value of type *DatabaseSpecRequestBodyRequestBody from a value of type
// *controlplane.DatabaseSpec.
func marshalControlplaneDatabaseSpecToDatabaseSpecRequestBodyRequestBody(v *controlplane.DatabaseSpec) *DatabaseSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecRequestBodyRequestBody{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecRequestBodyRequestBody, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBodyRequestBody(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecRequestBodyRequestBody{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecRequestBodyRequestBody, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBodyRequestBody(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBodyRequestBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneRestoreConfigSpecToRestoreConfigSpecRequestBodyRequestBody(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBodyRequestBody
// builds a value of type *DatabaseNodeSpecRequestBodyRequestBody from a value
// of type *controlplane.DatabaseNodeSpec.
func marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecRequestBodyRequestBody(v *controlplane.DatabaseNodeSpec) *DatabaseNodeSpecRequestBodyRequestBody {
	res := &DatabaseNodeSpecRequestBodyRequestBody{
		Name:            v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = val
		}
	} else {
		res.HostIds = []string{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBodyRequestBody(v.BackupConfig)
	}

	return res
}

// marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBodyRequestBody
// builds a value of type *BackupConfigSpecRequestBodyRequestBody from a value
// of type *controlplane.BackupConfigSpec.
func marshalControlplaneBackupConfigSpecToBackupConfigSpecRequestBodyRequestBody(v *controlplane.BackupConfigSpec) *BackupConfigSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecRequestBodyRequestBody{
		Provider: v.Provider,
	}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecRequestBodyRequestBody, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBodyRequestBody(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecRequestBodyRequestBody, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBodyRequestBody(val)
		}
	}

	return res
}

// marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBodyRequestBody
// builds a value of type *BackupRepositorySpecRequestBodyRequestBody from a
// value of type *controlplane.BackupRepositorySpec.
func marshalControlplaneBackupRepositorySpecToBackupRepositorySpecRequestBodyRequestBody(v *controlplane.BackupRepositorySpec) *BackupRepositorySpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupRepositorySpecRequestBodyRequestBody{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBodyRequestBody
// builds a value of type *BackupScheduleSpecRequestBodyRequestBody from a
// value of type *controlplane.BackupScheduleSpec.
func marshalControlplaneBackupScheduleSpecToBackupScheduleSpecRequestBodyRequestBody(v *controlplane.BackupScheduleSpec) *BackupScheduleSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecRequestBodyRequestBody{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBodyRequestBody
// builds a value of type *DatabaseUserSpecRequestBodyRequestBody from a value
// of type *controlplane.DatabaseUserSpec.
func marshalControlplaneDatabaseUserSpecToDatabaseUserSpecRequestBodyRequestBody(v *controlplane.DatabaseUserSpec) *DatabaseUserSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecRequestBodyRequestBody{
		Username: v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneRestoreConfigSpecToRestoreConfigSpecRequestBodyRequestBody
// builds a value of type *RestoreConfigSpecRequestBodyRequestBody from a value
// of type *controlplane.RestoreConfigSpec.
func marshalControlplaneRestoreConfigSpecToRestoreConfigSpecRequestBodyRequestBody(v *controlplane.RestoreConfigSpec) *RestoreConfigSpecRequestBodyRequestBody {
	if v == nil {
		return nil
	}
	res := &RestoreConfigSpecRequestBodyRequestBody{
		Provider:     v.Provider,
		DatabaseID:   v.DatabaseID,
		NodeName:     v.NodeName,
		DatabaseName: v.DatabaseName,
	}
	if v.Repository != nil {
		res.Repository = marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecRequestBodyRequestBody(v.Repository)
	}

	return res
}

// marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecRequestBodyRequestBody
// builds a value of type *RestoreRepositorySpecRequestBodyRequestBody from a
// value of type *controlplane.RestoreRepositorySpec.
func marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecRequestBodyRequestBody(v *controlplane.RestoreRepositorySpec) *RestoreRepositorySpecRequestBodyRequestBody {
	res := &RestoreRepositorySpecRequestBodyRequestBody{
		ID:             v.ID,
		Type:           v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec builds a
// value of type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBodyRequestBody.
func marshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBodyRequestBody) *controlplane.DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseSpec{
		DatabaseName:       v.DatabaseName,
		PostgresVersion:    v.PostgresVersion,
		SpockVersion:       v.SpockVersion,
		Port:               v.Port,
		DeletionProtection: v.DeletionProtection,
		StorageClass:       v.StorageClass,
		StorageSize:        v.StorageSize,
		Cpus:               v.Cpus,
		Memory:             v.Memory,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = marshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(val)
		}
	} else {
		res.Nodes = []*controlplane.DatabaseNodeSpec{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = marshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Features != nil {
		res.Features = make(map[string]string, len(v.Features))
		for key, val := range v.Features {
			tk := key
			tv := val
			res.Features[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}

	return res
}

// marshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec
// builds a value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBodyRequestBody.
func marshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBodyRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		StorageClass:    v.StorageClass,
		StorageSize:     v.StorageSize,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = val
		}
	} else {
		res.HostIds = []string{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}

	return res
}

// marshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec
// builds a value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBodyRequestBody.
func marshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBodyRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{
		Provider: v.Provider,
	}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = marshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(val)
		}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = marshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// marshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBodyRequestBody.
func marshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBodyRequestBody) *controlplane.BackupRepositorySpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupRepositorySpec{
		ID:                v.ID,
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec
// builds a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBodyRequestBody.
func marshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBodyRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// marshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec
// builds a value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBodyRequestBody.
func marshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBodyRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username: v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec
// builds a value of type *controlplane.RestoreConfigSpec from a value of type
// *RestoreConfigSpecRequestBodyRequestBody.
func marshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec(v *RestoreConfigSpecRequestBodyRequestBody) *controlplane.RestoreConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.RestoreConfigSpec{
		Provider:     v.Provider,
		DatabaseID:   v.DatabaseID,
		NodeName:     v.NodeName,
		DatabaseName: v.DatabaseName,
	}
	if v.Repository != nil {
		res.Repository = marshalRestoreRepositorySpecRequestBodyRequestBodyToControlplaneRestoreRepositorySpec(v.Repository)
	}

	return res
}

// marshalRestoreRepositorySpecRequestBodyRequestBodyToControlplaneRestoreRepositorySpec
// builds a value of type *controlplane.RestoreRepositorySpec from a value of
// type *RestoreRepositorySpecRequestBodyRequestBody.
func marshalRestoreRepositorySpecRequestBodyRequestBodyToControlplaneRestoreRepositorySpec(v *RestoreRepositorySpecRequestBodyRequestBody) *controlplane.RestoreRepositorySpec {
	res := &controlplane.RestoreRepositorySpec{
		ID:             v.ID,
		Type:           v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}
