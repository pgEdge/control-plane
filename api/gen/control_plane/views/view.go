// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane views
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/design

package views

import (
	goa "goa.design/goa/v3/pkg"
)

// DatabaseCollection is the viewed result type that is projected based on a
// view.
type DatabaseCollection struct {
	// Type to project
	Projected DatabaseCollectionView
	// View to render
	View string
}

// Database is the viewed result type that is projected based on a view.
type Database struct {
	// Type to project
	Projected *DatabaseView
	// View to render
	View string
}

// DatabaseCollectionView is a type that runs validations on a projected type.
type DatabaseCollectionView []*DatabaseView

// DatabaseView is a type that runs validations on a projected type.
type DatabaseView struct {
	// Unique identifier for the database.
	ID *string
	// Unique identifier for the databases's owner.
	TenantID *string
	// The time that the database was created.
	CreatedAt *string
	// The time that the database was last updated.
	UpdatedAt *string
	// Current state of the database.
	State *string
	// All of the instances in the database.
	Instances InstanceCollectionView
	// The user-provided specification for the database.
	Spec *DatabaseSpecView
}

// InstanceCollectionView is a type that runs validations on a projected type.
type InstanceCollectionView []*InstanceView

// InstanceView is a type that runs validations on a projected type.
type InstanceView struct {
	// Unique identifier for the instance.
	ID *string
	// The ID of the host this instance is running on.
	HostID *string
	// The Spock node name for this instance.
	NodeName *string
	// The time that the instance was created.
	CreatedAt *string
	// The time that the instance was last updated.
	UpdatedAt    *string
	State        *string
	PatroniState *string
	Role         *string
	// True if this instance is in read-only mode.
	ReadOnly *bool
	// True if this instance is pending to be restarted from a configuration change.
	PendingRestart *bool
	// True if Patroni has been paused for this instance.
	PatroniPaused *bool
	// The version of Postgres for this instance.
	PostgresVersion *string
	// The version of Spock for this instance.
	SpockVersion *string
	// All interfaces that this instance serves on.
	Interfaces []*InstanceInterfaceView
}

// InstanceInterfaceView is a type that runs validations on a projected type.
type InstanceInterfaceView struct {
	// The type of network for this interface.
	NetworkType *string
	// The unique identifier of the network for this interface.
	NetworkID *string
	// The hostname of the instance on this interface.
	Hostname *string
	// The IPv4 address of the instance on this interface.
	Ipv4Address *string
	// The Postgres port for the instance on this interface.
	Port *int
}

// DatabaseSpecView is a type that runs validations on a projected type.
type DatabaseSpecView struct {
	// The name of the Postgres database.
	DatabaseName *string
	// The major version of the Postgres database.
	PostgresVersion *string
	// The major version of the Spock extension.
	SpockVersion *string
	// The port used by the Postgres database.
	Port *int
	// Prevents deletion when true.
	DeletionProtection *bool
	// The storage class to use for the database. The possible values and defaults
	// depend on the orchestrator.
	StorageClass *string
	// The size of the storage in SI or IEC notation. Support for this value
	// depends on the orchestrator and storage class.
	StorageSize *string
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will be
	// enforced depends on the orchestrator.
	Cpus *string
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit will be enforced depends on the orchestrator.
	Memory *string
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecView
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecView
	// The feature flags for this database.
	Features map[string]string
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecView
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecView
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any
	// A list of extra volumes to mount. Each entry defines a host and container
	// path.
	ExternalVolumes []*ExternalVolumeSpecView
}

// DatabaseNodeSpecView is a type that runs validations on a projected type.
type DatabaseNodeSpecView struct {
	// The name of the database node.
	Name *string
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary and the others will be read
	// replicas.
	HostIds []string
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int
	// The storage class to use for the database on this node. The possible values
	// and defaults depend on the orchestrator.
	StorageClass *string
	// The size of the storage for this node in SI or IEC notation. Support for
	// this value depends on the orchestrator and storage class.
	StorageSize *string
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. Defaults to the number of available CPUs on the host. Can
	// include an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will
	// be enforced depends on the orchestrator.
	Cpus *string
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit will be enforced depends on the
	// orchestrator.
	Memory *string
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecView
	// The restore configuration for this node. Overrides the restore configuration
	// set in the DatabaseSpec.
	RestoreConfig *RestoreConfigSpecView
	// Optional list of external volumes to mount for this node only.
	ExternalVolumes []*ExternalVolumeSpecView
}

// BackupConfigSpecView is a type that runs validations on a projected type.
type BackupConfigSpecView struct {
	// The backup provider for this backup configuration.
	Provider *string
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecView
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecView
}

// BackupRepositorySpecView is a type that runs validations on a projected type.
type BackupRepositorySpecView struct {
	// The unique identifier of this repository.
	ID *string
	// The type of this repository.
	Type *string
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int
	// The type of measure used for retention_full.
	RetentionFullType *string
	// The base path within the repository to store backups. Required for type =
	// 'posix'.
	BasePath *string
	// Additional options to apply to this repository.
	CustomOptions map[string]string
}

// BackupScheduleSpecView is a type that runs validations on a projected type.
type BackupScheduleSpecView struct {
	// The unique identifier for this backup schedule.
	ID *string
	// The type of backup to take on this schedule.
	Type *string
	// The cron expression for this schedule.
	CronExpression *string
}

// RestoreConfigSpecView is a type that runs validations on a projected type.
type RestoreConfigSpecView struct {
	// The backup provider for this restore configuration.
	Provider *string
	// The ID of the database to restore this database from.
	SourceDatabaseID *string
	// The name of the node to restore this database from.
	SourceNodeName *string
	// The name of the database in this repository. This database will be renamed
	// to the database_name in the DatabaseSpec.
	SourceDatabaseName *string
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecView
	// Additional options to use when restoring this database. If omitted, the
	// database will be restored to the latest point in the given repository.
	RestoreOptions []string
}

// RestoreRepositorySpecView is a type that runs validations on a projected
// type.
type RestoreRepositorySpecView struct {
	// The unique identifier of this repository.
	ID *string
	// The type of this repository.
	Type *string
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string
	// The base path within the repository where backups are stored.
	BasePath *string
	// Additional options to apply to this repository.
	CustomOptions map[string]string
}

// ExternalVolumeSpecView is a type that runs validations on a projected type.
type ExternalVolumeSpecView struct {
	// The host path for the volume.
	HostPath *string
	// The path inside the container where the volume will be mounted.
	DestinationPath *string
}

// DatabaseUserSpecView is a type that runs validations on a projected type.
type DatabaseUserSpecView struct {
	// The username for this database user.
	Username *string
	// The password for this database user.
	Password *string
	// If true, this user will be granted database ownership.
	DbOwner *bool
	// The attributes to assign to this database user.
	Attributes []string
	// The roles to assign to this database user.
	Roles []string
}

// RestoreDatabaseResponseView is a type that runs validations on a projected
// type.
type RestoreDatabaseResponseView struct {
	// The database being restored.
	Database *DatabaseView
	// The restore tasks that were created to restore this database.
	Tasks []*TaskView
}

// TaskView is a type that runs validations on a projected type.
type TaskView struct {
	// The database ID of the task.
	DatabaseID *string
	// The name of the node that the task is operating on.
	NodeName *string
	// The ID of the instance that the task is operating on.
	InstanceID *string
	// The ID of the host that the task is running on.
	HostID *string
	// The unique ID of the task.
	TaskID *string
	// The time when the task was created.
	CreatedAt *string
	// The time when the task was completed.
	CompletedAt *string
	// The type of the task.
	Type *string
	// The status of the task.
	Status *string
	// The error message if the task failed.
	Error *string
}

var (
	// DatabaseCollectionMap is a map indexing the attribute names of
	// DatabaseCollection by view name.
	DatabaseCollectionMap = map[string][]string{
		"default": {
			"id",
			"tenant_id",
			"created_at",
			"updated_at",
			"state",
			"instances",
			"spec",
		},
		"abbreviated": {
			"id",
			"tenant_id",
			"created_at",
			"updated_at",
			"state",
			"instances",
		},
	}
	// DatabaseMap is a map indexing the attribute names of Database by view name.
	DatabaseMap = map[string][]string{
		"default": {
			"id",
			"tenant_id",
			"created_at",
			"updated_at",
			"state",
			"instances",
			"spec",
		},
		"abbreviated": {
			"id",
			"tenant_id",
			"created_at",
			"updated_at",
			"state",
			"instances",
		},
	}
	// InstanceCollectionMap is a map indexing the attribute names of
	// InstanceCollection by view name.
	InstanceCollectionMap = map[string][]string{
		"default": {
			"id",
			"host_id",
			"node_name",
			"created_at",
			"updated_at",
			"state",
			"patroni_state",
			"role",
			"read_only",
			"pending_restart",
			"patroni_paused",
			"postgres_version",
			"spock_version",
			"interfaces",
		},
		"abbreviated": {
			"id",
			"host_id",
			"node_name",
			"state",
		},
	}
	// InstanceMap is a map indexing the attribute names of Instance by view name.
	InstanceMap = map[string][]string{
		"default": {
			"id",
			"host_id",
			"node_name",
			"created_at",
			"updated_at",
			"state",
			"patroni_state",
			"role",
			"read_only",
			"pending_restart",
			"patroni_paused",
			"postgres_version",
			"spock_version",
			"interfaces",
		},
		"abbreviated": {
			"id",
			"host_id",
			"node_name",
			"state",
		},
	}
)

// ValidateDatabaseCollection runs the validations defined on the viewed result
// type DatabaseCollection.
func ValidateDatabaseCollection(result DatabaseCollection) (err error) {
	switch result.View {
	case "default", "":
		err = ValidateDatabaseCollectionView(result.Projected)
	case "abbreviated":
		err = ValidateDatabaseCollectionViewAbbreviated(result.Projected)
	default:
		err = goa.InvalidEnumValueError("view", result.View, []any{"default", "abbreviated"})
	}
	return
}

// ValidateDatabase runs the validations defined on the viewed result type
// Database.
func ValidateDatabase(result *Database) (err error) {
	switch result.View {
	case "default", "":
		err = ValidateDatabaseView(result.Projected)
	case "abbreviated":
		err = ValidateDatabaseViewAbbreviated(result.Projected)
	default:
		err = goa.InvalidEnumValueError("view", result.View, []any{"default", "abbreviated"})
	}
	return
}

// ValidateDatabaseCollectionView runs the validations defined on
// DatabaseCollectionView using the "default" view.
func ValidateDatabaseCollectionView(result DatabaseCollectionView) (err error) {
	for _, item := range result {
		if err2 := ValidateDatabaseView(item); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseCollectionViewAbbreviated runs the validations defined on
// DatabaseCollectionView using the "abbreviated" view.
func ValidateDatabaseCollectionViewAbbreviated(result DatabaseCollectionView) (err error) {
	for _, item := range result {
		if err2 := ValidateDatabaseViewAbbreviated(item); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseView runs the validations defined on DatabaseView using the
// "default" view.
func ValidateDatabaseView(result *DatabaseView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "result"))
	}
	if result.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "result"))
	}
	if result.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "result"))
	}
	if result.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.id", *result.ID, goa.FormatUUID))
	}
	if result.TenantID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.tenant_id", *result.TenantID, goa.FormatUUID))
	}
	if result.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.created_at", *result.CreatedAt, goa.FormatDateTime))
	}
	if result.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.updated_at", *result.UpdatedAt, goa.FormatDateTime))
	}
	if result.State != nil {
		if !(*result.State == "creating" || *result.State == "modifying" || *result.State == "available" || *result.State == "deleting" || *result.State == "degraded" || *result.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.state", *result.State, []any{"creating", "modifying", "available", "deleting", "degraded", "unknown"}))
		}
	}
	if result.Spec != nil {
		if err2 := ValidateDatabaseSpecView(result.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.Instances != nil {
		if err2 := ValidateInstanceCollectionViewAbbreviated(result.Instances); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseViewAbbreviated runs the validations defined on DatabaseView
// using the "abbreviated" view.
func ValidateDatabaseViewAbbreviated(result *DatabaseView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "result"))
	}
	if result.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "result"))
	}
	if result.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "result"))
	}
	if result.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.id", *result.ID, goa.FormatUUID))
	}
	if result.TenantID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.tenant_id", *result.TenantID, goa.FormatUUID))
	}
	if result.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.created_at", *result.CreatedAt, goa.FormatDateTime))
	}
	if result.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.updated_at", *result.UpdatedAt, goa.FormatDateTime))
	}
	if result.State != nil {
		if !(*result.State == "creating" || *result.State == "modifying" || *result.State == "available" || *result.State == "deleting" || *result.State == "degraded" || *result.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.state", *result.State, []any{"creating", "modifying", "available", "deleting", "degraded", "unknown"}))
		}
	}
	if result.Instances != nil {
		if err2 := ValidateInstanceCollectionViewAbbreviated(result.Instances); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateInstanceCollectionView runs the validations defined on
// InstanceCollectionView using the "default" view.
func ValidateInstanceCollectionView(result InstanceCollectionView) (err error) {
	for _, item := range result {
		if err2 := ValidateInstanceView(item); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateInstanceCollectionViewAbbreviated runs the validations defined on
// InstanceCollectionView using the "abbreviated" view.
func ValidateInstanceCollectionViewAbbreviated(result InstanceCollectionView) (err error) {
	for _, item := range result {
		if err2 := ValidateInstanceViewAbbreviated(item); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateInstanceView runs the validations defined on InstanceView using the
// "default" view.
func ValidateInstanceView(result *InstanceView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "result"))
	}
	if result.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "result"))
	}
	if result.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "result"))
	}
	if result.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "result"))
	}
	if result.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "result"))
	}
	if result.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.id", *result.ID, goa.FormatUUID))
	}
	if result.HostID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.host_id", *result.HostID, goa.FormatUUID))
	}
	if result.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.created_at", *result.CreatedAt, goa.FormatDateTime))
	}
	if result.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.updated_at", *result.UpdatedAt, goa.FormatDateTime))
	}
	if result.State != nil {
		if !(*result.State == "creating" || *result.State == "modifying" || *result.State == "backing_up" || *result.State == "restoring" || *result.State == "deleting" || *result.State == "available" || *result.State == "degraded" || *result.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.state", *result.State, []any{"creating", "modifying", "backing_up", "restoring", "deleting", "available", "degraded", "unknown"}))
		}
	}
	if result.PatroniState != nil {
		if !(*result.PatroniState == "stopping" || *result.PatroniState == "stopped" || *result.PatroniState == "stop failed" || *result.PatroniState == "crashed" || *result.PatroniState == "running" || *result.PatroniState == "starting" || *result.PatroniState == "start failed" || *result.PatroniState == "restarting" || *result.PatroniState == "restart failed" || *result.PatroniState == "initializing new cluster" || *result.PatroniState == "initdb failed" || *result.PatroniState == "running custom bootstrap script" || *result.PatroniState == "custom bootstrap failed" || *result.PatroniState == "creating replica" || *result.PatroniState == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.patroni_state", *result.PatroniState, []any{"stopping", "stopped", "stop failed", "crashed", "running", "starting", "start failed", "restarting", "restart failed", "initializing new cluster", "initdb failed", "running custom bootstrap script", "custom bootstrap failed", "creating replica", "unknown"}))
		}
	}
	if result.Role != nil {
		if !(*result.Role == "replica" || *result.Role == "primary") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.role", *result.Role, []any{"replica", "primary"}))
		}
	}
	for _, e := range result.Interfaces {
		if e != nil {
			if err2 := ValidateInstanceInterfaceView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInstanceViewAbbreviated runs the validations defined on InstanceView
// using the "abbreviated" view.
func ValidateInstanceViewAbbreviated(result *InstanceView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "result"))
	}
	if result.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "result"))
	}
	if result.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "result"))
	}
	if result.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.id", *result.ID, goa.FormatUUID))
	}
	if result.HostID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.host_id", *result.HostID, goa.FormatUUID))
	}
	if result.State != nil {
		if !(*result.State == "creating" || *result.State == "modifying" || *result.State == "backing_up" || *result.State == "restoring" || *result.State == "deleting" || *result.State == "available" || *result.State == "degraded" || *result.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.state", *result.State, []any{"creating", "modifying", "backing_up", "restoring", "deleting", "available", "degraded", "unknown"}))
		}
	}
	return
}

// ValidateInstanceInterfaceView runs the validations defined on
// InstanceInterfaceView.
func ValidateInstanceInterfaceView(result *InstanceInterfaceView) (err error) {
	if result.NetworkType == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("network_type", "result"))
	}
	if result.Port == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("port", "result"))
	}
	if result.NetworkType != nil {
		if !(*result.NetworkType == "docker" || *result.NetworkType == "host") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.network_type", *result.NetworkType, []any{"docker", "host"}))
		}
	}
	if result.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.ipv4_address", *result.Ipv4Address, goa.FormatIPv4))
	}
	return
}

// ValidateDatabaseSpecView runs the validations defined on DatabaseSpecView.
func ValidateDatabaseSpecView(result *DatabaseSpecView) (err error) {
	if result.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "result"))
	}
	if result.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "result"))
	}
	if result.PostgresVersion != nil {
		if !(*result.PostgresVersion == "16" || *result.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.postgres_version", *result.PostgresVersion, []any{"16", "17"}))
		}
	}
	if result.SpockVersion != nil {
		if !(*result.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.spock_version", *result.SpockVersion, []any{"4"}))
		}
	}
	for _, e := range result.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range result.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if result.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecView(result.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecView(result.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range result.ExternalVolumes {
		if e != nil {
			if err2 := ValidateExternalVolumeSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDatabaseNodeSpecView runs the validations defined on
// DatabaseNodeSpecView.
func ValidateDatabaseNodeSpecView(result *DatabaseNodeSpecView) (err error) {
	if result.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "result"))
	}
	if result.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "result"))
	}
	if result.Name != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.name", *result.Name, "n[0-9]+"))
	}
	if len(result.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.host_ids", result.HostIds, len(result.HostIds), 1, true))
	}
	for _, e := range result.HostIds {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.host_ids[*]", e, goa.FormatUUID))
	}
	if result.PostgresVersion != nil {
		if !(*result.PostgresVersion == "16" || *result.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.postgres_version", *result.PostgresVersion, []any{"16", "17"}))
		}
	}
	if result.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecView(result.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecView(result.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range result.ExternalVolumes {
		if e != nil {
			if err2 := ValidateExternalVolumeSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupConfigSpecView runs the validations defined on
// BackupConfigSpecView.
func ValidateBackupConfigSpecView(result *BackupConfigSpecView) (err error) {
	if result.Repositories == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repositories", "result"))
	}
	if result.Provider != nil {
		if !(*result.Provider == "pgbackrest") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.provider", *result.Provider, []any{"pgbackrest"}))
		}
	}
	if len(result.Repositories) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.repositories", result.Repositories, len(result.Repositories), 1, true))
	}
	for _, e := range result.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range result.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecView runs the validations defined on
// BackupRepositorySpecView.
func ValidateBackupRepositorySpecView(result *BackupRepositorySpecView) (err error) {
	if result.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "result"))
	}
	if result.Type != nil {
		if !(*result.Type == "s3" || *result.Type == "gcs" || *result.Type == "azure" || *result.Type == "posix") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.type", *result.Type, []any{"s3", "gcs", "azure", "posix"}))
		}
	}
	if result.RetentionFullType != nil {
		if !(*result.RetentionFullType == "time" || *result.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.retention_full_type", *result.RetentionFullType, []any{"time", "count"}))
		}
	}
	return
}

// ValidateBackupScheduleSpecView runs the validations defined on
// BackupScheduleSpecView.
func ValidateBackupScheduleSpecView(result *BackupScheduleSpecView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "result"))
	}
	if result.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "result"))
	}
	if result.Type != nil {
		if !(*result.Type == "full" || *result.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.type", *result.Type, []any{"full", "incr"}))
		}
	}
	return
}

// ValidateRestoreConfigSpecView runs the validations defined on
// RestoreConfigSpecView.
func ValidateRestoreConfigSpecView(result *RestoreConfigSpecView) (err error) {
	if result.SourceDatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_database_id", "result"))
	}
	if result.SourceNodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_node_name", "result"))
	}
	if result.SourceDatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_database_name", "result"))
	}
	if result.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "result"))
	}
	if result.Provider != nil {
		if !(*result.Provider == "pgbackrest") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.provider", *result.Provider, []any{"pgbackrest"}))
		}
	}
	if result.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecView(result.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateRestoreRepositorySpecView runs the validations defined on
// RestoreRepositorySpecView.
func ValidateRestoreRepositorySpecView(result *RestoreRepositorySpecView) (err error) {
	if result.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "result"))
	}
	if result.Type != nil {
		if !(*result.Type == "s3" || *result.Type == "gcs" || *result.Type == "azure" || *result.Type == "posix") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.type", *result.Type, []any{"s3", "gcs", "azure", "posix"}))
		}
	}
	return
}

// ValidateExternalVolumeSpecView runs the validations defined on
// ExternalVolumeSpecView.
func ValidateExternalVolumeSpecView(result *ExternalVolumeSpecView) (err error) {
	if result.HostPath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_path", "result"))
	}
	if result.DestinationPath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("destination_path", "result"))
	}
	return
}

// ValidateDatabaseUserSpecView runs the validations defined on
// DatabaseUserSpecView.
func ValidateDatabaseUserSpecView(result *DatabaseUserSpecView) (err error) {
	if result.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "result"))
	}
	if result.Password == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("password", "result"))
	}
	return
}

// ValidateRestoreDatabaseResponseView runs the validations defined on
// RestoreDatabaseResponseView.
func ValidateRestoreDatabaseResponseView(result *RestoreDatabaseResponseView) (err error) {
	if result.Database != nil {
		if err2 := ValidateDatabaseView(result.Database); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range result.Tasks {
		if e != nil {
			if err2 := ValidateTaskView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateTaskView runs the validations defined on TaskView.
func ValidateTaskView(result *TaskView) (err error) {
	if result.DatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_id", "result"))
	}
	if result.TaskID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task_id", "result"))
	}
	if result.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "result"))
	}
	if result.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "result"))
	}
	if result.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "result"))
	}
	if result.DatabaseID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.database_id", *result.DatabaseID, goa.FormatUUID))
	}
	if result.InstanceID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.instance_id", *result.InstanceID, goa.FormatUUID))
	}
	if result.HostID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.host_id", *result.HostID, goa.FormatUUID))
	}
	if result.TaskID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.task_id", *result.TaskID, goa.FormatUUID))
	}
	if result.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.created_at", *result.CreatedAt, goa.FormatDateTime))
	}
	if result.CompletedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.completed_at", *result.CompletedAt, goa.FormatDateTime))
	}
	if result.Status != nil {
		if !(*result.Status == "pending" || *result.Status == "running" || *result.Status == "completed" || *result.Status == "failed" || *result.Status == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.status", *result.Status, []any{"pending", "running", "completed", "failed", "unknown"}))
		}
	}
	return
}
