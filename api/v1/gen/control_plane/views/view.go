// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane views
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/v1/design -o v1

package views

import (
	"unicode/utf8"

	goa "goa.design/goa/v3/pkg"
)

// DatabaseCollection is the viewed result type that is projected based on a
// view.
type DatabaseCollection struct {
	// Type to project
	Projected DatabaseCollectionView
	// View to render
	View string
}

// Database is the viewed result type that is projected based on a view.
type Database struct {
	// Type to project
	Projected *DatabaseView
	// View to render
	View string
}

// DatabaseCollectionView is a type that runs validations on a projected type.
type DatabaseCollectionView []*DatabaseView

// DatabaseView is a type that runs validations on a projected type.
type DatabaseView struct {
	// Unique identifier for the database.
	ID *IdentifierView
	// Unique identifier for the databases's owner.
	TenantID *IdentifierView
	// The time that the database was created.
	CreatedAt *string
	// The time that the database was last updated.
	UpdatedAt *string
	// Current state of the database.
	State *string
	// All of the instances in the database.
	Instances InstanceCollectionView
	// The user-provided specification for the database.
	Spec *DatabaseSpecView
}

// IdentifierView is a type that runs validations on a projected type.
type IdentifierView string

// InstanceCollectionView is a type that runs validations on a projected type.
type InstanceCollectionView []*InstanceView

// InstanceView is a type that runs validations on a projected type.
type InstanceView struct {
	// Unique identifier for the instance.
	ID *string
	// The ID of the host this instance is running on.
	HostID *string
	// The Spock node name for this instance.
	NodeName *string
	// The time that the instance was created.
	CreatedAt *string
	// The time that the instance was last modified.
	UpdatedAt *string
	// The time that the instance status information was last updated.
	StatusUpdatedAt *string
	State           *string
	// Connection information for the instance.
	ConnectionInfo *InstanceConnectionInfoView
	// Postgres status information for the instance.
	Postgres *InstancePostgresStatusView
	// Spock status information for the instance.
	Spock *InstanceSpockStatusView
	// An error message if the instance is in an error state.
	Error *string
}

// InstanceConnectionInfoView is a type that runs validations on a projected
// type.
type InstanceConnectionInfoView struct {
	// The hostname of the host that's running this instance.
	Hostname *string
	// The IPv4 address of the host that's running this instance.
	Ipv4Address *string
	// The host port that Postgres is listening on for this instance.
	Port *int
}

// InstancePostgresStatusView is a type that runs validations on a projected
// type.
type InstancePostgresStatusView struct {
	// The version of Postgres for this instance.
	Version      *string
	PatroniState *string
	Role         *string
	// True if this instance is pending to be restarted from a configuration change.
	PendingRestart *bool
	// True if Patroni has been paused for this instance.
	PatroniPaused *bool
}

// InstanceSpockStatusView is a type that runs validations on a projected type.
type InstanceSpockStatusView struct {
	// The current spock.readonly setting.
	ReadOnly *string
	// The version of Spock for this instance.
	Version *string
	// Status information for this instance's Spock subscriptions.
	Subscriptions []*InstanceSubscriptionView
}

// InstanceSubscriptionView is a type that runs validations on a projected type.
type InstanceSubscriptionView struct {
	// The Spock node name of the provider for this subscription.
	ProviderNode *string
	// The name of the subscription.
	Name *string
	// The current status of the subscription.
	Status *string
}

// DatabaseSpecView is a type that runs validations on a projected type.
type DatabaseSpecView struct {
	// The name of the Postgres database.
	DatabaseName *string
	// The major version of the Postgres database.
	PostgresVersion *string
	// The major version of the Spock extension.
	SpockVersion *string
	// The port used by the Postgres database.
	Port *int
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit will be
	// enforced depends on the orchestrator.
	Cpus *string
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit will be enforced depends on the orchestrator.
	Memory *string
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecView
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecView
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecView
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecView
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any
	// A list of extra volumes to mount. Each entry defines a host and container
	// path.
	ExtraVolumes []*ExtraVolumesSpecView
}

// DatabaseNodeSpecView is a type that runs validations on a projected type.
type DatabaseNodeSpecView struct {
	// The name of the database node.
	Name *string
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary and the others will be read
	// replicas.
	HostIds []IdentifierView
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. Can include the SI suffix 'm', e.g. '500m' for 500
	// millicpus. Cannot allocate units smaller than 1m. Defaults to the number of
	// available CPUs on the host if 0 or unspecified. Cannot allocate more CPUs
	// than are available on the host. Whether this limit will be enforced depends
	// on the orchestrator.
	Cpus *string
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit will be enforced depends on the
	// orchestrator.
	Memory *string
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecView
	// The restore configuration for this node. Overrides the restore configuration
	// set in the DatabaseSpec.
	RestoreConfig *RestoreConfigSpecView
	// Optional list of external volumes to mount for this node only.
	ExtraVolumes []*ExtraVolumesSpecView
}

// BackupConfigSpecView is a type that runs validations on a projected type.
type BackupConfigSpecView struct {
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecView
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecView
}

// BackupRepositorySpecView is a type that runs validations on a projected type.
type BackupRepositorySpecView struct {
	// The unique identifier of this repository.
	ID *IdentifierView
	// The type of this repository.
	Type *string
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain. This field will
	// be excluded from the response of all endpoints.
	S3Key *string
	// The corresponding secret for the AWS access key ID in s3_key. This field
	// will be excluded from the response of all endpoints.
	S3KeySecret *string
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile. This field will be
	// excluded from the response of all endpoints.
	GcsKey *string
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string
	// The Azure storage account access key to use for this repository. This field
	// will be excluded from the response of all endpoints.
	AzureKey *string
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int
	// The type of measure used for retention_full.
	RetentionFullType *string
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string
	// Additional options to apply to this repository.
	CustomOptions map[string]string
}

// BackupScheduleSpecView is a type that runs validations on a projected type.
type BackupScheduleSpecView struct {
	// The unique identifier for this backup schedule.
	ID *string
	// The type of backup to take on this schedule.
	Type *string
	// The cron expression for this schedule.
	CronExpression *string
}

// RestoreConfigSpecView is a type that runs validations on a projected type.
type RestoreConfigSpecView struct {
	// The ID of the database to restore this database from.
	SourceDatabaseID *IdentifierView
	// The name of the node to restore this database from.
	SourceNodeName *string
	// The name of the database in this repository. This database will be renamed
	// to the database_name in the DatabaseSpec.
	SourceDatabaseName *string
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecView
	// Additional options to use when restoring this database. If omitted, the
	// database will be restored to the latest point in the given repository.
	RestoreOptions map[string]string
}

// RestoreRepositorySpecView is a type that runs validations on a projected
// type.
type RestoreRepositorySpecView struct {
	// The unique identifier of this repository.
	ID *IdentifierView
	// The type of this repository.
	Type *string
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string
	// Additional options to apply to this repository.
	CustomOptions map[string]string
}

// ExtraVolumesSpecView is a type that runs validations on a projected type.
type ExtraVolumesSpecView struct {
	// The host path for the volume.
	HostPath *string
	// The path inside the container where the volume will be mounted.
	DestinationPath *string
}

// DatabaseUserSpecView is a type that runs validations on a projected type.
type DatabaseUserSpecView struct {
	// The username for this database user.
	Username *string
	// The password for this database user. This field will be excluded from the
	// response of all endpoints.
	Password *string
	// If true, this user will be granted database ownership.
	DbOwner *bool
	// The attributes to assign to this database user.
	Attributes []string
	// The roles to assign to this database user.
	Roles []string
}

// CreateDatabaseResponseView is a type that runs validations on a projected
// type.
type CreateDatabaseResponseView struct {
	// The task that will create this database.
	Task *TaskView
	// The database being created.
	Database *DatabaseView
}

// TaskView is a type that runs validations on a projected type.
type TaskView struct {
	// The parent task ID of the task.
	ParentID *string
	// The database ID of the task.
	DatabaseID *string
	// The name of the node that the task is operating on.
	NodeName *string
	// The ID of the instance that the task is operating on.
	InstanceID *string
	// The ID of the host that the task is running on.
	HostID *string
	// The unique ID of the task.
	TaskID *string
	// The time when the task was created.
	CreatedAt *string
	// The time when the task was completed.
	CompletedAt *string
	// The type of the task.
	Type *string
	// The status of the task.
	Status *string
	// The error message if the task failed.
	Error *string
}

// UpdateDatabaseResponseView is a type that runs validations on a projected
// type.
type UpdateDatabaseResponseView struct {
	// The task that will update this database.
	Task *TaskView
	// The database being updated.
	Database *DatabaseView
}

// RestoreDatabaseResponseView is a type that runs validations on a projected
// type.
type RestoreDatabaseResponseView struct {
	// The task that will restore this database.
	Task *TaskView
	// The tasks that will restore each database node.
	NodeTasks []*TaskView
	// The database being restored.
	Database *DatabaseView
}

var (
	// DatabaseCollectionMap is a map indexing the attribute names of
	// DatabaseCollection by view name.
	DatabaseCollectionMap = map[string][]string{
		"default": {
			"id",
			"tenant_id",
			"created_at",
			"updated_at",
			"state",
			"instances",
			"spec",
		},
		"abbreviated": {
			"id",
			"tenant_id",
			"created_at",
			"updated_at",
			"state",
			"instances",
		},
	}
	// DatabaseMap is a map indexing the attribute names of Database by view name.
	DatabaseMap = map[string][]string{
		"default": {
			"id",
			"tenant_id",
			"created_at",
			"updated_at",
			"state",
			"instances",
			"spec",
		},
		"abbreviated": {
			"id",
			"tenant_id",
			"created_at",
			"updated_at",
			"state",
			"instances",
		},
	}
	// InstanceCollectionMap is a map indexing the attribute names of
	// InstanceCollection by view name.
	InstanceCollectionMap = map[string][]string{
		"default": {
			"id",
			"host_id",
			"node_name",
			"created_at",
			"updated_at",
			"status_updated_at",
			"state",
			"connection_info",
			"postgres",
			"spock",
			"error",
		},
		"abbreviated": {
			"id",
			"host_id",
			"node_name",
			"state",
		},
	}
	// InstanceMap is a map indexing the attribute names of Instance by view name.
	InstanceMap = map[string][]string{
		"default": {
			"id",
			"host_id",
			"node_name",
			"created_at",
			"updated_at",
			"status_updated_at",
			"state",
			"connection_info",
			"postgres",
			"spock",
			"error",
		},
		"abbreviated": {
			"id",
			"host_id",
			"node_name",
			"state",
		},
	}
)

// ValidateDatabaseCollection runs the validations defined on the viewed result
// type DatabaseCollection.
func ValidateDatabaseCollection(result DatabaseCollection) (err error) {
	switch result.View {
	case "default", "":
		err = ValidateDatabaseCollectionView(result.Projected)
	case "abbreviated":
		err = ValidateDatabaseCollectionViewAbbreviated(result.Projected)
	default:
		err = goa.InvalidEnumValueError("view", result.View, []any{"default", "abbreviated"})
	}
	return
}

// ValidateDatabase runs the validations defined on the viewed result type
// Database.
func ValidateDatabase(result *Database) (err error) {
	switch result.View {
	case "default", "":
		err = ValidateDatabaseView(result.Projected)
	case "abbreviated":
		err = ValidateDatabaseViewAbbreviated(result.Projected)
	default:
		err = goa.InvalidEnumValueError("view", result.View, []any{"default", "abbreviated"})
	}
	return
}

// ValidateDatabaseCollectionView runs the validations defined on
// DatabaseCollectionView using the "default" view.
func ValidateDatabaseCollectionView(result DatabaseCollectionView) (err error) {
	for _, item := range result {
		if err2 := ValidateDatabaseView(item); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseCollectionViewAbbreviated runs the validations defined on
// DatabaseCollectionView using the "abbreviated" view.
func ValidateDatabaseCollectionViewAbbreviated(result DatabaseCollectionView) (err error) {
	for _, item := range result {
		if err2 := ValidateDatabaseViewAbbreviated(item); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseView runs the validations defined on DatabaseView using the
// "default" view.
func ValidateDatabaseView(result *DatabaseView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "result"))
	}
	if result.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "result"))
	}
	if result.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "result"))
	}
	if result.ID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.id", string(*result.ID), "^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$"))
	}
	if result.TenantID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.tenant_id", string(*result.TenantID), "^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$"))
	}
	if result.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.created_at", *result.CreatedAt, goa.FormatDateTime))
	}
	if result.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.updated_at", *result.UpdatedAt, goa.FormatDateTime))
	}
	if result.State != nil {
		if !(*result.State == "creating" || *result.State == "modifying" || *result.State == "available" || *result.State == "deleting" || *result.State == "degraded" || *result.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.state", *result.State, []any{"creating", "modifying", "available", "deleting", "degraded", "unknown"}))
		}
	}
	if result.Spec != nil {
		if err2 := ValidateDatabaseSpecView(result.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.Instances != nil {
		if err2 := ValidateInstanceCollectionView(result.Instances); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseViewAbbreviated runs the validations defined on DatabaseView
// using the "abbreviated" view.
func ValidateDatabaseViewAbbreviated(result *DatabaseView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "result"))
	}
	if result.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "result"))
	}
	if result.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "result"))
	}
	if result.ID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.id", string(*result.ID), "^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$"))
	}
	if result.TenantID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.tenant_id", string(*result.TenantID), "^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$"))
	}
	if result.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.created_at", *result.CreatedAt, goa.FormatDateTime))
	}
	if result.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.updated_at", *result.UpdatedAt, goa.FormatDateTime))
	}
	if result.State != nil {
		if !(*result.State == "creating" || *result.State == "modifying" || *result.State == "available" || *result.State == "deleting" || *result.State == "degraded" || *result.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.state", *result.State, []any{"creating", "modifying", "available", "deleting", "degraded", "unknown"}))
		}
	}
	if result.Instances != nil {
		if err2 := ValidateInstanceCollectionViewAbbreviated(result.Instances); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateIdentifierView runs the validations defined on IdentifierView.
func ValidateIdentifierView(result IdentifierView) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("result", string(result), "^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$"))
	return
}

// ValidateInstanceCollectionView runs the validations defined on
// InstanceCollectionView using the "default" view.
func ValidateInstanceCollectionView(result InstanceCollectionView) (err error) {
	for _, item := range result {
		if err2 := ValidateInstanceView(item); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateInstanceCollectionViewAbbreviated runs the validations defined on
// InstanceCollectionView using the "abbreviated" view.
func ValidateInstanceCollectionViewAbbreviated(result InstanceCollectionView) (err error) {
	for _, item := range result {
		if err2 := ValidateInstanceViewAbbreviated(item); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateInstanceView runs the validations defined on InstanceView using the
// "default" view.
func ValidateInstanceView(result *InstanceView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "result"))
	}
	if result.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "result"))
	}
	if result.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "result"))
	}
	if result.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updated_at", "result"))
	}
	if result.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "result"))
	}
	if result.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.created_at", *result.CreatedAt, goa.FormatDateTime))
	}
	if result.UpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.updated_at", *result.UpdatedAt, goa.FormatDateTime))
	}
	if result.StatusUpdatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.status_updated_at", *result.StatusUpdatedAt, goa.FormatDateTime))
	}
	if result.State != nil {
		if !(*result.State == "creating" || *result.State == "modifying" || *result.State == "backing_up" || *result.State == "available" || *result.State == "degraded" || *result.State == "failed" || *result.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.state", *result.State, []any{"creating", "modifying", "backing_up", "available", "degraded", "failed", "unknown"}))
		}
	}
	if result.ConnectionInfo != nil {
		if err2 := ValidateInstanceConnectionInfoView(result.ConnectionInfo); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.Postgres != nil {
		if err2 := ValidateInstancePostgresStatusView(result.Postgres); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.Spock != nil {
		if err2 := ValidateInstanceSpockStatusView(result.Spock); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateInstanceViewAbbreviated runs the validations defined on InstanceView
// using the "abbreviated" view.
func ValidateInstanceViewAbbreviated(result *InstanceView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "result"))
	}
	if result.NodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_name", "result"))
	}
	if result.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "result"))
	}
	if result.State != nil {
		if !(*result.State == "creating" || *result.State == "modifying" || *result.State == "backing_up" || *result.State == "available" || *result.State == "degraded" || *result.State == "failed" || *result.State == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.state", *result.State, []any{"creating", "modifying", "backing_up", "available", "degraded", "failed", "unknown"}))
		}
	}
	return
}

// ValidateInstanceConnectionInfoView runs the validations defined on
// InstanceConnectionInfoView.
func ValidateInstanceConnectionInfoView(result *InstanceConnectionInfoView) (err error) {
	if result.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.ipv4_address", *result.Ipv4Address, goa.FormatIPv4))
	}
	return
}

// ValidateInstancePostgresStatusView runs the validations defined on
// InstancePostgresStatusView.
func ValidateInstancePostgresStatusView(result *InstancePostgresStatusView) (err error) {
	if result.PatroniState != nil {
		if !(*result.PatroniState == "stopping" || *result.PatroniState == "stopped" || *result.PatroniState == "stop failed" || *result.PatroniState == "crashed" || *result.PatroniState == "running" || *result.PatroniState == "starting" || *result.PatroniState == "start failed" || *result.PatroniState == "restarting" || *result.PatroniState == "restart failed" || *result.PatroniState == "initializing new cluster" || *result.PatroniState == "initdb failed" || *result.PatroniState == "running custom bootstrap script" || *result.PatroniState == "custom bootstrap failed" || *result.PatroniState == "creating replica" || *result.PatroniState == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.patroni_state", *result.PatroniState, []any{"stopping", "stopped", "stop failed", "crashed", "running", "starting", "start failed", "restarting", "restart failed", "initializing new cluster", "initdb failed", "running custom bootstrap script", "custom bootstrap failed", "creating replica", "unknown"}))
		}
	}
	if result.Role != nil {
		if !(*result.Role == "replica" || *result.Role == "primary") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.role", *result.Role, []any{"replica", "primary"}))
		}
	}
	return
}

// ValidateInstanceSpockStatusView runs the validations defined on
// InstanceSpockStatusView.
func ValidateInstanceSpockStatusView(result *InstanceSpockStatusView) (err error) {
	for _, e := range result.Subscriptions {
		if e != nil {
			if err2 := ValidateInstanceSubscriptionView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateInstanceSubscriptionView runs the validations defined on
// InstanceSubscriptionView.
func ValidateInstanceSubscriptionView(result *InstanceSubscriptionView) (err error) {
	if result.ProviderNode == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("provider_node", "result"))
	}
	if result.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "result"))
	}
	if result.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "result"))
	}
	if result.ProviderNode != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.provider_node", *result.ProviderNode, "n[0-9]+"))
	}
	return
}

// ValidateDatabaseSpecView runs the validations defined on DatabaseSpecView.
func ValidateDatabaseSpecView(result *DatabaseSpecView) (err error) {
	if result.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "result"))
	}
	if result.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "result"))
	}
	if result.DatabaseName != nil {
		if utf8.RuneCountInString(*result.DatabaseName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.database_name", *result.DatabaseName, utf8.RuneCountInString(*result.DatabaseName), 1, true))
		}
	}
	if result.DatabaseName != nil {
		if utf8.RuneCountInString(*result.DatabaseName) > 31 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.database_name", *result.DatabaseName, utf8.RuneCountInString(*result.DatabaseName), 31, false))
		}
	}
	if result.PostgresVersion != nil {
		if !(*result.PostgresVersion == "15" || *result.PostgresVersion == "16" || *result.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.postgres_version", *result.PostgresVersion, []any{"15", "16", "17"}))
		}
	}
	if result.SpockVersion != nil {
		if !(*result.SpockVersion == "4") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.spock_version", *result.SpockVersion, []any{"4"}))
		}
	}
	if result.Port != nil {
		if *result.Port < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("result.port", *result.Port, 1, true))
		}
	}
	if result.Port != nil {
		if *result.Port > 65535 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("result.port", *result.Port, 65535, false))
		}
	}
	if result.Cpus != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.cpus", *result.Cpus, "^[0-9]+(\\.[0-9]{1,3}|m)?$"))
	}
	if result.Memory != nil {
		if utf8.RuneCountInString(*result.Memory) > 16 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.memory", *result.Memory, utf8.RuneCountInString(*result.Memory), 16, false))
		}
	}
	if len(result.Nodes) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.nodes", result.Nodes, len(result.Nodes), 1, true))
	}
	if len(result.Nodes) > 9 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.nodes", result.Nodes, len(result.Nodes), 9, false))
	}
	for _, e := range result.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if len(result.DatabaseUsers) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.database_users", result.DatabaseUsers, len(result.DatabaseUsers), 16, false))
	}
	for _, e := range result.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if result.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecView(result.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecView(result.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if len(result.PostgresqlConf) > 64 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.postgresql_conf", result.PostgresqlConf, len(result.PostgresqlConf), 64, false))
	}
	if len(result.ExtraVolumes) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.extra_volumes", result.ExtraVolumes, len(result.ExtraVolumes), 16, false))
	}
	for _, e := range result.ExtraVolumes {
		if e != nil {
			if err2 := ValidateExtraVolumesSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDatabaseNodeSpecView runs the validations defined on
// DatabaseNodeSpecView.
func ValidateDatabaseNodeSpecView(result *DatabaseNodeSpecView) (err error) {
	if result.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "result"))
	}
	if result.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "result"))
	}
	if result.Name != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.name", *result.Name, "n[0-9]+"))
	}
	if len(result.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.host_ids", result.HostIds, len(result.HostIds), 1, true))
	}
	for _, e := range result.HostIds {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.host_ids[*]", string(e), "^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$"))
	}
	if result.PostgresVersion != nil {
		if !(*result.PostgresVersion == "15" || *result.PostgresVersion == "16" || *result.PostgresVersion == "17") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.postgres_version", *result.PostgresVersion, []any{"15", "16", "17"}))
		}
	}
	if result.Port != nil {
		if *result.Port < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("result.port", *result.Port, 1, true))
		}
	}
	if result.Port != nil {
		if *result.Port > 65535 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("result.port", *result.Port, 65535, false))
		}
	}
	if result.Cpus != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.cpus", *result.Cpus, "^[0-9]+(\\.[0-9]{1,3}|m)?$"))
	}
	if result.Memory != nil {
		if utf8.RuneCountInString(*result.Memory) > 16 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.memory", *result.Memory, utf8.RuneCountInString(*result.Memory), 16, false))
		}
	}
	if len(result.PostgresqlConf) > 64 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.postgresql_conf", result.PostgresqlConf, len(result.PostgresqlConf), 64, false))
	}
	if result.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecView(result.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecView(result.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if len(result.ExtraVolumes) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.extra_volumes", result.ExtraVolumes, len(result.ExtraVolumes), 16, false))
	}
	for _, e := range result.ExtraVolumes {
		if e != nil {
			if err2 := ValidateExtraVolumesSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupConfigSpecView runs the validations defined on
// BackupConfigSpecView.
func ValidateBackupConfigSpecView(result *BackupConfigSpecView) (err error) {
	if result.Repositories == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repositories", "result"))
	}
	if len(result.Repositories) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.repositories", result.Repositories, len(result.Repositories), 1, true))
	}
	for _, e := range result.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if len(result.Schedules) > 32 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.schedules", result.Schedules, len(result.Schedules), 32, false))
	}
	for _, e := range result.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecView runs the validations defined on
// BackupRepositorySpecView.
func ValidateBackupRepositorySpecView(result *BackupRepositorySpecView) (err error) {
	if result.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "result"))
	}
	if result.ID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.id", string(*result.ID), "^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$"))
	}
	if result.Type != nil {
		if !(*result.Type == "s3" || *result.Type == "gcs" || *result.Type == "azure" || *result.Type == "posix" || *result.Type == "cifs") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.type", *result.Type, []any{"s3", "gcs", "azure", "posix", "cifs"}))
		}
	}
	if result.S3Bucket != nil {
		if utf8.RuneCountInString(*result.S3Bucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_bucket", *result.S3Bucket, utf8.RuneCountInString(*result.S3Bucket), 3, true))
		}
	}
	if result.S3Bucket != nil {
		if utf8.RuneCountInString(*result.S3Bucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_bucket", *result.S3Bucket, utf8.RuneCountInString(*result.S3Bucket), 63, false))
		}
	}
	if result.S3Region != nil {
		if utf8.RuneCountInString(*result.S3Region) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_region", *result.S3Region, utf8.RuneCountInString(*result.S3Region), 1, true))
		}
	}
	if result.S3Region != nil {
		if utf8.RuneCountInString(*result.S3Region) > 32 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_region", *result.S3Region, utf8.RuneCountInString(*result.S3Region), 32, false))
		}
	}
	if result.S3Endpoint != nil {
		if utf8.RuneCountInString(*result.S3Endpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_endpoint", *result.S3Endpoint, utf8.RuneCountInString(*result.S3Endpoint), 3, true))
		}
	}
	if result.S3Endpoint != nil {
		if utf8.RuneCountInString(*result.S3Endpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_endpoint", *result.S3Endpoint, utf8.RuneCountInString(*result.S3Endpoint), 128, false))
		}
	}
	if result.S3Key != nil {
		if utf8.RuneCountInString(*result.S3Key) < 16 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_key", *result.S3Key, utf8.RuneCountInString(*result.S3Key), 16, true))
		}
	}
	if result.S3Key != nil {
		if utf8.RuneCountInString(*result.S3Key) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_key", *result.S3Key, utf8.RuneCountInString(*result.S3Key), 128, false))
		}
	}
	if result.S3KeySecret != nil {
		if utf8.RuneCountInString(*result.S3KeySecret) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_key_secret", *result.S3KeySecret, utf8.RuneCountInString(*result.S3KeySecret), 128, false))
		}
	}
	if result.GcsBucket != nil {
		if utf8.RuneCountInString(*result.GcsBucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_bucket", *result.GcsBucket, utf8.RuneCountInString(*result.GcsBucket), 3, true))
		}
	}
	if result.GcsBucket != nil {
		if utf8.RuneCountInString(*result.GcsBucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_bucket", *result.GcsBucket, utf8.RuneCountInString(*result.GcsBucket), 63, false))
		}
	}
	if result.GcsEndpoint != nil {
		if utf8.RuneCountInString(*result.GcsEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_endpoint", *result.GcsEndpoint, utf8.RuneCountInString(*result.GcsEndpoint), 3, true))
		}
	}
	if result.GcsEndpoint != nil {
		if utf8.RuneCountInString(*result.GcsEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_endpoint", *result.GcsEndpoint, utf8.RuneCountInString(*result.GcsEndpoint), 128, false))
		}
	}
	if result.GcsKey != nil {
		if utf8.RuneCountInString(*result.GcsKey) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_key", *result.GcsKey, utf8.RuneCountInString(*result.GcsKey), 1024, false))
		}
	}
	if result.AzureAccount != nil {
		if utf8.RuneCountInString(*result.AzureAccount) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_account", *result.AzureAccount, utf8.RuneCountInString(*result.AzureAccount), 3, true))
		}
	}
	if result.AzureAccount != nil {
		if utf8.RuneCountInString(*result.AzureAccount) > 24 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_account", *result.AzureAccount, utf8.RuneCountInString(*result.AzureAccount), 24, false))
		}
	}
	if result.AzureContainer != nil {
		if utf8.RuneCountInString(*result.AzureContainer) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_container", *result.AzureContainer, utf8.RuneCountInString(*result.AzureContainer), 3, true))
		}
	}
	if result.AzureContainer != nil {
		if utf8.RuneCountInString(*result.AzureContainer) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_container", *result.AzureContainer, utf8.RuneCountInString(*result.AzureContainer), 63, false))
		}
	}
	if result.AzureEndpoint != nil {
		if utf8.RuneCountInString(*result.AzureEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_endpoint", *result.AzureEndpoint, utf8.RuneCountInString(*result.AzureEndpoint), 3, true))
		}
	}
	if result.AzureEndpoint != nil {
		if utf8.RuneCountInString(*result.AzureEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_endpoint", *result.AzureEndpoint, utf8.RuneCountInString(*result.AzureEndpoint), 128, false))
		}
	}
	if result.AzureKey != nil {
		if utf8.RuneCountInString(*result.AzureKey) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_key", *result.AzureKey, utf8.RuneCountInString(*result.AzureKey), 128, false))
		}
	}
	if result.RetentionFull != nil {
		if *result.RetentionFull < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("result.retention_full", *result.RetentionFull, 1, true))
		}
	}
	if result.RetentionFull != nil {
		if *result.RetentionFull > 9.999999e+06 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("result.retention_full", *result.RetentionFull, 9.999999e+06, false))
		}
	}
	if result.RetentionFullType != nil {
		if !(*result.RetentionFullType == "time" || *result.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.retention_full_type", *result.RetentionFullType, []any{"time", "count"}))
		}
	}
	if result.BasePath != nil {
		if utf8.RuneCountInString(*result.BasePath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.base_path", *result.BasePath, utf8.RuneCountInString(*result.BasePath), 256, false))
		}
	}
	if len(result.CustomOptions) > 32 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.custom_options", result.CustomOptions, len(result.CustomOptions), 32, false))
	}
	return
}

// ValidateBackupScheduleSpecView runs the validations defined on
// BackupScheduleSpecView.
func ValidateBackupScheduleSpecView(result *BackupScheduleSpecView) (err error) {
	if result.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "result"))
	}
	if result.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "result"))
	}
	if result.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "result"))
	}
	if result.ID != nil {
		if utf8.RuneCountInString(*result.ID) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.id", *result.ID, utf8.RuneCountInString(*result.ID), 64, false))
		}
	}
	if result.Type != nil {
		if !(*result.Type == "full" || *result.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.type", *result.Type, []any{"full", "incr"}))
		}
	}
	if result.CronExpression != nil {
		if utf8.RuneCountInString(*result.CronExpression) > 32 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.cron_expression", *result.CronExpression, utf8.RuneCountInString(*result.CronExpression), 32, false))
		}
	}
	return
}

// ValidateRestoreConfigSpecView runs the validations defined on
// RestoreConfigSpecView.
func ValidateRestoreConfigSpecView(result *RestoreConfigSpecView) (err error) {
	if result.SourceDatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_database_id", "result"))
	}
	if result.SourceNodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_node_name", "result"))
	}
	if result.SourceDatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_database_name", "result"))
	}
	if result.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "result"))
	}
	if result.SourceDatabaseID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.source_database_id", string(*result.SourceDatabaseID), "^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$"))
	}
	if result.SourceNodeName != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.source_node_name", *result.SourceNodeName, "n[0-9]+"))
	}
	if result.SourceDatabaseName != nil {
		if utf8.RuneCountInString(*result.SourceDatabaseName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.source_database_name", *result.SourceDatabaseName, utf8.RuneCountInString(*result.SourceDatabaseName), 1, true))
		}
	}
	if result.SourceDatabaseName != nil {
		if utf8.RuneCountInString(*result.SourceDatabaseName) > 31 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.source_database_name", *result.SourceDatabaseName, utf8.RuneCountInString(*result.SourceDatabaseName), 31, false))
		}
	}
	if result.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecView(result.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if len(result.RestoreOptions) > 32 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.restore_options", result.RestoreOptions, len(result.RestoreOptions), 32, false))
	}
	return
}

// ValidateRestoreRepositorySpecView runs the validations defined on
// RestoreRepositorySpecView.
func ValidateRestoreRepositorySpecView(result *RestoreRepositorySpecView) (err error) {
	if result.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "result"))
	}
	if result.ID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("result.id", string(*result.ID), "^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$"))
	}
	if result.Type != nil {
		if !(*result.Type == "s3" || *result.Type == "gcs" || *result.Type == "azure" || *result.Type == "posix" || *result.Type == "cifs") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.type", *result.Type, []any{"s3", "gcs", "azure", "posix", "cifs"}))
		}
	}
	if result.S3Bucket != nil {
		if utf8.RuneCountInString(*result.S3Bucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_bucket", *result.S3Bucket, utf8.RuneCountInString(*result.S3Bucket), 3, true))
		}
	}
	if result.S3Bucket != nil {
		if utf8.RuneCountInString(*result.S3Bucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_bucket", *result.S3Bucket, utf8.RuneCountInString(*result.S3Bucket), 63, false))
		}
	}
	if result.S3Region != nil {
		if utf8.RuneCountInString(*result.S3Region) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_region", *result.S3Region, utf8.RuneCountInString(*result.S3Region), 1, true))
		}
	}
	if result.S3Region != nil {
		if utf8.RuneCountInString(*result.S3Region) > 32 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_region", *result.S3Region, utf8.RuneCountInString(*result.S3Region), 32, false))
		}
	}
	if result.S3Endpoint != nil {
		if utf8.RuneCountInString(*result.S3Endpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_endpoint", *result.S3Endpoint, utf8.RuneCountInString(*result.S3Endpoint), 3, true))
		}
	}
	if result.S3Endpoint != nil {
		if utf8.RuneCountInString(*result.S3Endpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_endpoint", *result.S3Endpoint, utf8.RuneCountInString(*result.S3Endpoint), 128, false))
		}
	}
	if result.S3Key != nil {
		if utf8.RuneCountInString(*result.S3Key) < 16 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_key", *result.S3Key, utf8.RuneCountInString(*result.S3Key), 16, true))
		}
	}
	if result.S3Key != nil {
		if utf8.RuneCountInString(*result.S3Key) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_key", *result.S3Key, utf8.RuneCountInString(*result.S3Key), 128, false))
		}
	}
	if result.S3KeySecret != nil {
		if utf8.RuneCountInString(*result.S3KeySecret) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.s3_key_secret", *result.S3KeySecret, utf8.RuneCountInString(*result.S3KeySecret), 128, false))
		}
	}
	if result.GcsBucket != nil {
		if utf8.RuneCountInString(*result.GcsBucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_bucket", *result.GcsBucket, utf8.RuneCountInString(*result.GcsBucket), 3, true))
		}
	}
	if result.GcsBucket != nil {
		if utf8.RuneCountInString(*result.GcsBucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_bucket", *result.GcsBucket, utf8.RuneCountInString(*result.GcsBucket), 63, false))
		}
	}
	if result.GcsEndpoint != nil {
		if utf8.RuneCountInString(*result.GcsEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_endpoint", *result.GcsEndpoint, utf8.RuneCountInString(*result.GcsEndpoint), 3, true))
		}
	}
	if result.GcsEndpoint != nil {
		if utf8.RuneCountInString(*result.GcsEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_endpoint", *result.GcsEndpoint, utf8.RuneCountInString(*result.GcsEndpoint), 128, false))
		}
	}
	if result.GcsKey != nil {
		if utf8.RuneCountInString(*result.GcsKey) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.gcs_key", *result.GcsKey, utf8.RuneCountInString(*result.GcsKey), 1024, false))
		}
	}
	if result.AzureAccount != nil {
		if utf8.RuneCountInString(*result.AzureAccount) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_account", *result.AzureAccount, utf8.RuneCountInString(*result.AzureAccount), 3, true))
		}
	}
	if result.AzureAccount != nil {
		if utf8.RuneCountInString(*result.AzureAccount) > 24 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_account", *result.AzureAccount, utf8.RuneCountInString(*result.AzureAccount), 24, false))
		}
	}
	if result.AzureContainer != nil {
		if utf8.RuneCountInString(*result.AzureContainer) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_container", *result.AzureContainer, utf8.RuneCountInString(*result.AzureContainer), 3, true))
		}
	}
	if result.AzureContainer != nil {
		if utf8.RuneCountInString(*result.AzureContainer) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_container", *result.AzureContainer, utf8.RuneCountInString(*result.AzureContainer), 63, false))
		}
	}
	if result.AzureEndpoint != nil {
		if utf8.RuneCountInString(*result.AzureEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_endpoint", *result.AzureEndpoint, utf8.RuneCountInString(*result.AzureEndpoint), 3, true))
		}
	}
	if result.AzureEndpoint != nil {
		if utf8.RuneCountInString(*result.AzureEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_endpoint", *result.AzureEndpoint, utf8.RuneCountInString(*result.AzureEndpoint), 128, false))
		}
	}
	if result.AzureKey != nil {
		if utf8.RuneCountInString(*result.AzureKey) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.azure_key", *result.AzureKey, utf8.RuneCountInString(*result.AzureKey), 128, false))
		}
	}
	if result.BasePath != nil {
		if utf8.RuneCountInString(*result.BasePath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.base_path", *result.BasePath, utf8.RuneCountInString(*result.BasePath), 256, false))
		}
	}
	return
}

// ValidateExtraVolumesSpecView runs the validations defined on
// ExtraVolumesSpecView.
func ValidateExtraVolumesSpecView(result *ExtraVolumesSpecView) (err error) {
	if result.HostPath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_path", "result"))
	}
	if result.DestinationPath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("destination_path", "result"))
	}
	if result.HostPath != nil {
		if utf8.RuneCountInString(*result.HostPath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.host_path", *result.HostPath, utf8.RuneCountInString(*result.HostPath), 256, false))
		}
	}
	if result.DestinationPath != nil {
		if utf8.RuneCountInString(*result.DestinationPath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.destination_path", *result.DestinationPath, utf8.RuneCountInString(*result.DestinationPath), 256, false))
		}
	}
	return
}

// ValidateDatabaseUserSpecView runs the validations defined on
// DatabaseUserSpecView.
func ValidateDatabaseUserSpecView(result *DatabaseUserSpecView) (err error) {
	if result.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "result"))
	}
	if result.Username != nil {
		if utf8.RuneCountInString(*result.Username) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.username", *result.Username, utf8.RuneCountInString(*result.Username), 1, true))
		}
	}
	if result.Password != nil {
		if utf8.RuneCountInString(*result.Password) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("result.password", *result.Password, utf8.RuneCountInString(*result.Password), 1, true))
		}
	}
	if len(result.Attributes) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.attributes", result.Attributes, len(result.Attributes), 16, false))
	}
	if len(result.Roles) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("result.roles", result.Roles, len(result.Roles), 16, false))
	}
	return
}

// ValidateCreateDatabaseResponseView runs the validations defined on
// CreateDatabaseResponseView.
func ValidateCreateDatabaseResponseView(result *CreateDatabaseResponseView) (err error) {
	if result.Task == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task", "result"))
	}
	if result.Database == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database", "result"))
	}
	if result.Task != nil {
		if err2 := ValidateTaskView(result.Task); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.Database != nil {
		if err2 := ValidateDatabaseView(result.Database); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateTaskView runs the validations defined on TaskView.
func ValidateTaskView(result *TaskView) (err error) {
	if result.DatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_id", "result"))
	}
	if result.TaskID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task_id", "result"))
	}
	if result.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "result"))
	}
	if result.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "result"))
	}
	if result.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "result"))
	}
	if result.ParentID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.parent_id", *result.ParentID, goa.FormatUUID))
	}
	if result.TaskID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.task_id", *result.TaskID, goa.FormatUUID))
	}
	if result.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.created_at", *result.CreatedAt, goa.FormatDateTime))
	}
	if result.CompletedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("result.completed_at", *result.CompletedAt, goa.FormatDateTime))
	}
	if result.Status != nil {
		if !(*result.Status == "pending" || *result.Status == "running" || *result.Status == "completed" || *result.Status == "failed" || *result.Status == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("result.status", *result.Status, []any{"pending", "running", "completed", "failed", "unknown"}))
		}
	}
	return
}

// ValidateUpdateDatabaseResponseView runs the validations defined on
// UpdateDatabaseResponseView.
func ValidateUpdateDatabaseResponseView(result *UpdateDatabaseResponseView) (err error) {
	if result.Task == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task", "result"))
	}
	if result.Database == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database", "result"))
	}
	if result.Task != nil {
		if err2 := ValidateTaskView(result.Task); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if result.Database != nil {
		if err2 := ValidateDatabaseView(result.Database); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateRestoreDatabaseResponseView runs the validations defined on
// RestoreDatabaseResponseView.
func ValidateRestoreDatabaseResponseView(result *RestoreDatabaseResponseView) (err error) {
	if result.Task == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("task", "result"))
	}
	if result.NodeTasks == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("node_tasks", "result"))
	}
	if result.Database == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database", "result"))
	}
	if result.Task != nil {
		if err2 := ValidateTaskView(result.Task); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range result.NodeTasks {
		if e != nil {
			if err2 := ValidateTaskView(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if result.Database != nil {
		if err2 := ValidateDatabaseView(result.Database); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}
