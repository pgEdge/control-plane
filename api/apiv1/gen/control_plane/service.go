// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane service
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/apiv1/design -o apiv1

package controlplane

import (
	"context"

	controlplaneviews "github.com/pgEdge/control-plane/api/apiv1/gen/control_plane/views"
	goa "goa.design/goa/v3/pkg"
)

// Service is the control-plane service interface.
type Service interface {
	// Initializes a new cluster.
	InitCluster(context.Context) (res *ClusterJoinToken, err error)
	// Joins this host to an existing cluster.
	JoinCluster(context.Context, *ClusterJoinToken) (err error)
	// Gets the join token for this cluster.
	GetJoinToken(context.Context) (res *ClusterJoinToken, err error)
	// Internal endpoint for other cluster members seeking to join this cluster.
	GetJoinOptions(context.Context, *ClusterJoinRequest) (res *ClusterJoinOptions, err error)
	// Returns information about the cluster.
	GetCluster(context.Context) (res *Cluster, err error)
	// Lists all hosts within the cluster.
	ListHosts(context.Context) (res []*Host, err error)
	// Returns information about a particular host in the cluster.
	GetHost(context.Context, *GetHostPayload) (res *Host, err error)
	// Removes a host from the cluster.
	RemoveHost(context.Context, *RemoveHostPayload) (err error)
	// Lists all databases in the cluster.
	ListDatabases(context.Context) (res *ListDatabasesResponse, err error)
	// Creates a new database in the cluster.
	CreateDatabase(context.Context, *CreateDatabaseRequest) (res *CreateDatabaseResponse, err error)
	// Returns information about a particular database in the cluster.
	GetDatabase(context.Context, *GetDatabasePayload) (res *Database, err error)
	// Updates a database with the given specification.
	UpdateDatabase(context.Context, *UpdateDatabasePayload) (res *UpdateDatabaseResponse, err error)
	// Deletes a database from the cluster.
	DeleteDatabase(context.Context, *DeleteDatabasePayload) (res *DeleteDatabaseResponse, err error)
	// Initiates a backup for a database node.
	BackupDatabaseNode(context.Context, *BackupDatabaseNodePayload) (res *BackupDatabaseNodeResponse, err error)
	// Lists all tasks for a database.
	ListDatabaseTasks(context.Context, *ListDatabaseTasksPayload) (res *ListDatabaseTasksResponse, err error)
	// Returns information about a particular task.
	GetDatabaseTask(context.Context, *GetDatabaseTaskPayload) (res *Task, err error)
	// Returns the log of a particular task for a database.
	GetDatabaseTaskLog(context.Context, *GetDatabaseTaskLogPayload) (res *TaskLog, err error)
	// Perform an in-place restore of one or more nodes using the given restore
	// configuration.
	RestoreDatabase(context.Context, *RestoreDatabasePayload) (res *RestoreDatabaseResponse, err error)
	// Returns version information for this Control Plane server.
	GetVersion(context.Context) (res *VersionInfo, err error)
	// Restarts a specific instance within a database. Supports immediate or
	// scheduled restarts.
	RestartInstance(context.Context, *RestartInstancePayload) (res *Task, err error)
	// Stops a specific instance within a database. Supports immediate stops.
	StopInstance(context.Context, *StopInstancePayload) (res *Task, err error)
	// Starts a specific instance within a database. Supports immediate starts
	StartInstance(context.Context, *StartInstancePayload) (res *Task, err error)
	// Cancels a running or pending task for a database.
	CancelDatabaseTask(context.Context, *CancelDatabaseTaskPayload) (res *Task, err error)
}

// APIName is the name of the API as defined in the design.
const APIName = "control-plane"

// APIVersion is the version of the API as defined in the design.
const APIVersion = "v0.3.0"

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "control-plane"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [23]string{"init-cluster", "join-cluster", "get-join-token", "get-join-options", "get-cluster", "list-hosts", "get-host", "remove-host", "list-databases", "create-database", "get-database", "update-database", "delete-database", "backup-database-node", "list-database-tasks", "get-database-task", "get-database-task-log", "restore-database", "get-version", "restart-instance", "stop-instance", "start-instance", "cancel-database-task"}

// A Control Plane API error.
type APIError struct {
	// The name of the error.
	Name string
	// The error message.
	Message string
}

type BackupConfigSpec struct {
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpec
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpec
}

// BackupDatabaseNodePayload is the payload type of the control-plane service
// backup-database-node method.
type BackupDatabaseNodePayload struct {
	// ID of the database to back up.
	DatabaseID Identifier
	// Name of the node to back up.
	NodeName string
	Options  *BackupOptions
	// Forcibly attempt backup even in unmodifiable state
	Force bool
}

// BackupDatabaseNodeResponse is the result type of the control-plane service
// backup-database-node method.
type BackupDatabaseNodeResponse struct {
	// The task that will backup this database node.
	Task *Task
}

type BackupOptions struct {
	// The type of backup.
	Type string
	// Annotations for the backup.
	Annotations map[string]string
	// Options for the backup.
	BackupOptions map[string]string
}

type BackupRepositorySpec struct {
	// The unique identifier of this repository.
	ID *Identifier
	// The type of this repository.
	Type string
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain. This field will
	// be excluded from the response of all endpoints. It can also be omitted from
	// update requests to keep the current value.
	S3Key *string
	// The corresponding secret for the AWS access key ID in s3_key. This field
	// will be excluded from the response of all endpoints. It can also be omitted
	// from update requests to keep the current value.
	S3KeySecret *string
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile. This field will be
	// excluded from the response of all endpoints. It can also be omitted from
	// update requests to keep the current value.
	GcsKey *string
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string
	// The Azure storage account access key to use for this repository. This field
	// will be excluded from the response of all endpoints. It can also be omitted
	// from update requests to keep the current value.
	AzureKey *string
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int
	// The type of measure used for retention_full.
	RetentionFullType *string
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string
	// Additional options to apply to this repository.
	CustomOptions map[string]string
}

type BackupScheduleSpec struct {
	// The unique identifier for this backup schedule.
	ID string
	// The type of backup to take on this schedule.
	Type string
	// The cron expression for this schedule.
	CronExpression string
}

// CancelDatabaseTaskPayload is the payload type of the control-plane service
// cancel-database-task method.
type CancelDatabaseTaskPayload struct {
	// ID of the database that owns the task.
	DatabaseID Identifier
	// ID of the task to cancel.
	TaskID Identifier
}

// Cluster is the result type of the control-plane service get-cluster method.
type Cluster struct {
	// Unique identifier for the cluster.
	ID Identifier
	// Unique identifier for the cluster's owner.
	TenantID Identifier
	// Current status of the cluster.
	Status *ClusterStatus
	// All of the hosts in the cluster.
	Hosts []*Host
}

type ClusterCredentials struct {
	// The base64-encoded CA certificate for the cluster.
	CaCert string
	// The base64-encoded etcd client certificate for the new cluster member.
	ClientCert string
	// The base64-encoded etcd client key for the new cluster member.
	ClientKey string
	// The base64-encoded etcd server certificate for the new cluster member.
	ServerCert string
	// The base64-encoded etcd server key for the new cluster member.
	ServerKey string
}

// ClusterJoinOptions is the result type of the control-plane service
// get-join-options method.
type ClusterJoinOptions struct {
	// Information about this cluster member
	Peer *ClusterPeer
	// Credentials for the new host joining the cluster.
	Credentials *ClusterCredentials
}

// ClusterJoinRequest is the payload type of the control-plane service
// get-join-options method.
type ClusterJoinRequest struct {
	// Token to join the cluster.
	Token string
	// The unique identifier for the host that's joining the cluster.
	HostID Identifier
	// The hostname of the host that's joining the cluster.
	Hostname string
	// The IPv4 address of the host that's joining the cluster.
	Ipv4Address string
}

// ClusterJoinToken is the result type of the control-plane service
// init-cluster method.
type ClusterJoinToken struct {
	// Token to join an existing cluster.
	Token string
	// Existing server to join
	ServerURL string
}

type ClusterPeer struct {
	// The name of the Etcd cluster member.
	Name string
	// The Etcd peer endpoint for this cluster member.
	PeerURL string
	// The Etcd client endpoint for this cluster member.
	ClientURL string
}

type ClusterStatus struct {
	// The current state of the cluster.
	State string
}

type ComponentStatus struct {
	// Indicates if the component is healthy.
	Healthy bool
	// Error message from any errors that occurred during the health check.
	Error *string
	// Additional details about the component.
	Details map[string]any
}

// CreateDatabaseRequest is the payload type of the control-plane service
// create-database method.
type CreateDatabaseRequest struct {
	// Unique identifier for the database.
	ID *Identifier
	// Unique identifier for the databases's owner.
	TenantID *Identifier
	// The specification for the database.
	Spec *DatabaseSpec
}

// CreateDatabaseResponse is the result type of the control-plane service
// create-database method.
type CreateDatabaseResponse struct {
	// The task that will create this database.
	Task *Task
	// The database being created.
	Database *Database
}

// Database is the result type of the control-plane service get-database method.
type Database struct {
	// Unique identifier for the database.
	ID Identifier
	// Unique identifier for the databases's owner.
	TenantID *Identifier
	// The time that the database was created.
	CreatedAt string
	// The time that the database was last updated.
	UpdatedAt string
	// Current state of the database.
	State string
	// All of the instances in the database.
	Instances InstanceCollection
	// The user-provided specification for the database.
	Spec *DatabaseSpec
}

type DatabaseCollection []*Database

type DatabaseNodeSpec struct {
	// The name of the database node.
	Name string
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary, and the others will be read
	// replicas.
	HostIds []Identifier
	// The major version of Postgres for this node. Overrides the Postgres version
	// set in the DatabaseSpec.
	PostgresVersion *string
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. It can include the SI suffix 'm', e.g. '500m' for 500
	// millicpus. Cannot allocate units smaller than 1m. Defaults to the number of
	// available CPUs on the host if 0 or unspecified. Cannot allocate more CPUs
	// than are available on the host. Whether this limit is enforced depends on
	// the orchestrator.
	Cpus *string
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit is enforced depends on the
	// orchestrator.
	Memory *string
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpec
	// The restore configuration for this node. Overrides the restore configuration
	// set in the DatabaseSpec.
	RestoreConfig *RestoreConfigSpec
	// Orchestrator-specific configuration options.
	OrchestratorOpts *OrchestratorOpts
	// The name of the source node to use for sync. This is typically the node
	// (like 'n1') from which the data will be copied to initialize this new node.
	SourceNode *string
	// The failover policy for this database's read replicas. If failover_policy is
	// automatic, a read replica will automatically be promoted when a primary
	// instance fails. If it is disabled, read replicas will not be promoted when a
	// primary instance fails.
	FailoverPolicy *string
}

type DatabaseSpec struct {
	// The name of the Postgres database.
	DatabaseName string
	// The major version of the Postgres database.
	PostgresVersion *string
	// The major version of the Spock extension.
	SpockVersion *string
	// The port used by the Postgres database. If the port is 0, each instance will
	// be assigned a random port. If the port is unspecified, the database will not
	// be exposed on any port, dependent on orchestrator support for that feature.
	Port *int
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit is enforced
	// depends on the orchestrator.
	Cpus *string
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit is enforced depends on the orchestrator.
	Memory *string
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpec
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpec
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpec
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpec
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any
	// Orchestrator-specific configuration options.
	OrchestratorOpts *OrchestratorOpts
	// The failover policy for this database's read replicas. If failover_policy is
	// automatic, a read replica will automatically be promoted when a primary
	// instance fails. If it is disabled, read replicas will not be promoted when a
	// primary instance fails.
	FailoverPolicy *string
}

type DatabaseUserSpec struct {
	// The username for this database user.
	Username string
	// The password for this database user. This field will be excluded from the
	// response of all endpoints. It can also be omitted from update requests to
	// keep the current value.
	Password *string
	// If true, this user will be granted database ownership.
	DbOwner *bool
	// The attributes to assign to this database user.
	Attributes []string
	// The roles to assign to this database user.
	Roles []string
}

// DeleteDatabasePayload is the payload type of the control-plane service
// delete-database method.
type DeleteDatabasePayload struct {
	// ID of the database to delete.
	DatabaseID Identifier
	// Force deletion of a database even in an unmodifiable state
	Force bool
}

// DeleteDatabaseResponse is the result type of the control-plane service
// delete-database method.
type DeleteDatabaseResponse struct {
	// The task that will delete this database.
	Task *Task
}

// Describes an additional Docker network to attach the container to.
type ExtraNetworkSpec struct {
	// The name or ID of the network to connect to.
	ID string
	// Optional network-scoped aliases for the container.
	Aliases []string
	// Optional driver options for the network connection.
	DriverOpts map[string]string
}

// Extra volumes to mount from the host to the database container.
type ExtraVolumesSpec struct {
	// The host path for the volume.
	HostPath string
	// The path inside the container where the volume will be mounted.
	DestinationPath string
}

// GetDatabasePayload is the payload type of the control-plane service
// get-database method.
type GetDatabasePayload struct {
	// ID of the database to get.
	DatabaseID Identifier
}

// GetDatabaseTaskLogPayload is the payload type of the control-plane service
// get-database-task-log method.
type GetDatabaseTaskLogPayload struct {
	// ID of the database to get the task log for.
	DatabaseID Identifier
	// ID of the task to get the log for.
	TaskID string
	// ID of the entry to start from.
	AfterEntryID *string
	// Maximum number of entries to return.
	Limit *int
}

// GetDatabaseTaskPayload is the payload type of the control-plane service
// get-database-task method.
type GetDatabaseTaskPayload struct {
	// ID of the database the task belongs to.
	DatabaseID Identifier
	// ID of the task to get.
	TaskID string
}

// GetHostPayload is the payload type of the control-plane service get-host
// method.
type GetHostPayload struct {
	// ID of the host to get.
	HostID Identifier
}

// Host is the result type of the control-plane service get-host method.
type Host struct {
	// Unique identifier for the host.
	ID Identifier
	// The orchestrator used by this host.
	Orchestrator string
	// The cohort that this host belongs to.
	Cohort *HostCohort
	// The hostname of this host.
	Hostname string
	// The IPv4 address of this host.
	Ipv4Address string
	// The number of CPUs on this host.
	Cpus *int
	// The amount of memory available on this host.
	Memory *string
	// Current status of the host.
	Status *HostStatus
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersion
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersion
}

type HostCohort struct {
	// The type of cohort that the host belongs to.
	Type string
	// The cohort ID that the host belongs to.
	CohortID string
	// The member ID of the host within the cohort.
	MemberID string
	// Indicates if the host is a control node in the cohort.
	ControlAvailable bool
}

type HostStatus struct {
	State string
	// The last time the host status was updated.
	UpdatedAt string
	// The status of each component of the host.
	Components map[string]*ComponentStatus
}

// A user-specified identifier. Must be 1-63 characters, contain only
// lower-cased letters and hyphens, start and end with a letter or number, and
// not contain consecutive hyphens.
type Identifier string

// An instance of pgEdge Postgres running on a host.
type Instance struct {
	// Unique identifier for the instance.
	ID string
	// The ID of the host this instance is running on.
	HostID string
	// The Spock node name for this instance.
	NodeName string
	// The time that the instance was created.
	CreatedAt string
	// The time that the instance was last modified.
	UpdatedAt string
	// The time that the instance status information was last updated.
	StatusUpdatedAt *string
	State           string
	// Connection information for the instance.
	ConnectionInfo *InstanceConnectionInfo
	// Postgres status information for the instance.
	Postgres *InstancePostgresStatus
	// Spock status information for the instance.
	Spock *InstanceSpockStatus
	// An error message if the instance is in an error state.
	Error *string
}

type InstanceCollection []*Instance

// Connection information for a pgEdge instance.
type InstanceConnectionInfo struct {
	// The hostname of the host that's running this instance.
	Hostname *string
	// The IPv4 address of the host that's running this instance.
	Ipv4Address *string
	// The host port that Postgres is listening on for this instance.
	Port *int
}

// Postgres status information for a pgEdge instance.
type InstancePostgresStatus struct {
	// The version of Postgres for this instance.
	Version      *string
	PatroniState *string
	Role         *string
	// True if this instance has a pending restart from a configuration change.
	PendingRestart *bool
	// True if Patroni is paused for this instance.
	PatroniPaused *bool
}

// Spock status information for a pgEdge instance.
type InstanceSpockStatus struct {
	// The current spock.readonly setting.
	ReadOnly *string
	// The version of Spock for this instance.
	Version *string
	// Status information for this instance's Spock subscriptions.
	Subscriptions []*InstanceSubscription
}

// Status information for a Spock subscription.
type InstanceSubscription struct {
	// The Spock node name of the provider for this subscription.
	ProviderNode string
	// The name of the subscription.
	Name string
	// The current status of the subscription.
	Status string
}

// ListDatabaseTasksPayload is the payload type of the control-plane service
// list-database-tasks method.
type ListDatabaseTasksPayload struct {
	// ID of the database to list tasks for.
	DatabaseID Identifier
	// ID of the task to start from.
	AfterTaskID *string
	// Maximum number of tasks to return.
	Limit *int
	// Sort order for the tasks.
	SortOrder *string
}

// ListDatabaseTasksResponse is the result type of the control-plane service
// list-database-tasks method.
type ListDatabaseTasksResponse struct {
	Tasks []*Task
}

// ListDatabasesResponse is the result type of the control-plane service
// list-databases method.
type ListDatabasesResponse struct {
	Databases DatabaseCollection
}

// Options specific to the selected orchestrator.
type OrchestratorOpts struct {
	// Swarm-specific configuration.
	Swarm *SwarmOpts
}

type PgEdgeVersion struct {
	// The Postgres major version.
	PostgresVersion string
	// The Spock major version.
	SpockVersion string
}

// RemoveHostPayload is the payload type of the control-plane service
// remove-host method.
type RemoveHostPayload struct {
	// ID of the host to remove.
	HostID Identifier
}

// RestartInstancePayload is the payload type of the control-plane service
// restart-instance method.
type RestartInstancePayload struct {
	// The ID of the database that owns the instance.
	DatabaseID Identifier
	// The ID of the instance to restart.
	InstanceID     Identifier
	RestartOptions *RestartOptions
}

// Options for restarting a Postgres instance.
type RestartOptions struct {
	// The time at which the restart is scheduled.
	ScheduledAt *string
}

type RestoreConfigSpec struct {
	// The ID of the database to restore this database from.
	SourceDatabaseID Identifier
	// The name of the node to restore this database from.
	SourceNodeName string
	// The name of the database in this repository. The database will be renamed to
	// the database_name in the DatabaseSpec after it's restored.
	SourceDatabaseName string
	// The repository to restore this database from.
	Repository *RestoreRepositorySpec
	// Additional options to use when restoring this database. If omitted, the
	// database will be restored to the latest point in the given repository.
	RestoreOptions map[string]string
}

// RestoreDatabasePayload is the payload type of the control-plane service
// restore-database method.
type RestoreDatabasePayload struct {
	// ID of the database to restore.
	DatabaseID Identifier
	Request    *RestoreDatabaseRequest
	// Force restoration of a database even in an unmodifiable state
	Force bool
}

type RestoreDatabaseRequest struct {
	// Configuration for the restore process.
	RestoreConfig *RestoreConfigSpec
	// The nodes to restore. Defaults to all nodes if empty or unspecified.
	TargetNodes []string
}

// RestoreDatabaseResponse is the result type of the control-plane service
// restore-database method.
type RestoreDatabaseResponse struct {
	// The task that will restore this database.
	Task *Task
	// The tasks that will restore each database node.
	NodeTasks []*Task
	// The database being restored.
	Database *Database
}

type RestoreRepositorySpec struct {
	// The unique identifier of this repository.
	ID *Identifier
	// The type of this repository.
	Type string
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string
	// Additional options to apply to this repository.
	CustomOptions map[string]string
}

// StartInstancePayload is the payload type of the control-plane service
// start-instance method.
type StartInstancePayload struct {
	// The ID of the database that owns the instance.
	DatabaseID Identifier
	// The ID of the instance to start.
	InstanceID Identifier
	// Force starting an instance even if database in an unmodifiable state
	Force bool
}

// StopInstancePayload is the payload type of the control-plane service
// stop-instance method.
type StopInstancePayload struct {
	// The ID of the database that owns the instance.
	DatabaseID Identifier
	// The ID of the instance to stop.
	InstanceID Identifier
	// Force stopping an instance even if database in an unmodifiable state
	Force bool
}

// Docker Swarm-specific options.
type SwarmOpts struct {
	// A list of extra volumes to mount. Each entry defines a host and container
	// path.
	ExtraVolumes []*ExtraVolumesSpec
	// A list of additional Docker Swarm networks to attach containers in this
	// database to.
	ExtraNetworks []*ExtraNetworkSpec
	// Arbitrary labels to apply to the Docker Swarm service
	ExtraLabels map[string]string
}

// Task is the result type of the control-plane service get-database-task
// method.
type Task struct {
	// The parent task ID of the task.
	ParentID *string
	// The database ID of the task.
	DatabaseID string
	// The name of the node that the task is operating on.
	NodeName *string
	// The ID of the instance that the task is operating on.
	InstanceID *string
	// The ID of the host that the task is running on.
	HostID *string
	// The unique ID of the task.
	TaskID string
	// The time when the task was created.
	CreatedAt string
	// The time when the task was completed.
	CompletedAt *string
	// The type of the task.
	Type string
	// The status of the task.
	Status string
	// The error message if the task failed.
	Error *string
}

// TaskLog is the result type of the control-plane service
// get-database-task-log method.
type TaskLog struct {
	// The database ID of the task log.
	DatabaseID string
	// The unique ID of the task log.
	TaskID string
	// The status of the task.
	TaskStatus string
	// The ID of the last entry in the task log.
	LastEntryID *string
	// Entries in the task log.
	Entries []*TaskLogEntry
}

type TaskLogEntry struct {
	// The timestamp of the log entry.
	Timestamp string
	// The log message.
	Message string
	// Additional fields for the log entry.
	Fields map[string]any
}

// UpdateDatabasePayload is the payload type of the control-plane service
// update-database method.
type UpdateDatabasePayload struct {
	// ID of the database to update.
	DatabaseID Identifier
	// Force update the database even if the spec is the same.
	ForceUpdate bool
	Request     *UpdateDatabaseRequest
}

type UpdateDatabaseRequest struct {
	// Unique identifier for the databases's owner.
	TenantID *Identifier
	// The specification for the database.
	Spec *DatabaseSpec
}

// UpdateDatabaseResponse is the result type of the control-plane service
// update-database method.
type UpdateDatabaseResponse struct {
	// The task that will update this database.
	Task *Task
	// The database being updated.
	Database *Database
}

// VersionInfo is the result type of the control-plane service get-version
// method.
type VersionInfo struct {
	// The version of the API server.
	Version string
	// The VCS revision of the API server.
	Revision string
	// The timestamp associated with the revision.
	RevisionTime string
	// The CPU architecture of the API server.
	Arch string
}

// Error returns an error description.
func (e *APIError) Error() string {
	return "A Control Plane API error."
}

// ErrorName returns "APIError".
//
// Deprecated: Use GoaErrorName - https://github.com/goadesign/goa/issues/3105
func (e *APIError) ErrorName() string {
	return e.GoaErrorName()
}

// GoaErrorName returns "APIError".
func (e *APIError) GoaErrorName() string {
	return e.Name
}

// MakeServerError builds a goa.ServiceError from an error.
func MakeServerError(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "server_error", false, false, false)
}

// MakeClusterAlreadyInitialized builds a goa.ServiceError from an error.
func MakeClusterAlreadyInitialized(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "cluster_already_initialized", false, false, false)
}

// MakeInvalidJoinToken builds a goa.ServiceError from an error.
func MakeInvalidJoinToken(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "invalid_join_token", false, false, false)
}

// MakeClusterNotInitialized builds a goa.ServiceError from an error.
func MakeClusterNotInitialized(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "cluster_not_initialized", false, false, false)
}

// MakeInvalidInput builds a goa.ServiceError from an error.
func MakeInvalidInput(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "invalid_input", false, false, false)
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "not_found", false, false, false)
}

// MakeOperationAlreadyInProgress builds a goa.ServiceError from an error.
func MakeOperationAlreadyInProgress(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "operation_already_in_progress", false, false, false)
}

// MakeDatabaseNotModifiable builds a goa.ServiceError from an error.
func MakeDatabaseNotModifiable(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "database_not_modifiable", false, false, false)
}

// MakeRestartFailed builds a goa.ServiceError from an error.
func MakeRestartFailed(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "restart_failed", false, false, false)
}

// MakeStopFailed builds a goa.ServiceError from an error.
func MakeStopFailed(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "stop_failed", false, false, false)
}

// MakeStartFailed builds a goa.ServiceError from an error.
func MakeStartFailed(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "start_failed", false, false, false)
}

// MakeCancelFailed builds a goa.ServiceError from an error.
func MakeCancelFailed(err error) *goa.ServiceError {
	return goa.NewServiceError(err, "cancel_failed", false, false, false)
}

// NewListDatabasesResponse initializes result type ListDatabasesResponse from
// viewed result type ListDatabasesResponse.
func NewListDatabasesResponse(vres *controlplaneviews.ListDatabasesResponse) *ListDatabasesResponse {
	return newListDatabasesResponse(vres.Projected)
}

// NewViewedListDatabasesResponse initializes viewed result type
// ListDatabasesResponse from result type ListDatabasesResponse using the given
// view.
func NewViewedListDatabasesResponse(res *ListDatabasesResponse, view string) *controlplaneviews.ListDatabasesResponse {
	p := newListDatabasesResponseView(res)
	return &controlplaneviews.ListDatabasesResponse{Projected: p, View: "default"}
}

// NewDatabase initializes result type Database from viewed result type
// Database.
func NewDatabase(vres *controlplaneviews.Database) *Database {
	var res *Database
	switch vres.View {
	case "default", "":
		res = newDatabase(vres.Projected)
	case "abbreviated":
		res = newDatabaseAbbreviated(vres.Projected)
	}
	return res
}

// NewViewedDatabase initializes viewed result type Database from result type
// Database using the given view.
func NewViewedDatabase(res *Database, view string) *controlplaneviews.Database {
	var vres *controlplaneviews.Database
	switch view {
	case "default", "":
		p := newDatabaseView(res)
		vres = &controlplaneviews.Database{Projected: p, View: "default"}
	case "abbreviated":
		p := newDatabaseViewAbbreviated(res)
		vres = &controlplaneviews.Database{Projected: p, View: "abbreviated"}
	}
	return vres
}

// newListDatabasesResponse converts projected type ListDatabasesResponse to
// service type ListDatabasesResponse.
func newListDatabasesResponse(vres *controlplaneviews.ListDatabasesResponseView) *ListDatabasesResponse {
	res := &ListDatabasesResponse{}
	if vres.Databases != nil {
		res.Databases = newDatabaseCollectionAbbreviated(vres.Databases)
	}
	return res
}

// newListDatabasesResponseView projects result type ListDatabasesResponse to
// projected type ListDatabasesResponseView using the "default" view.
func newListDatabasesResponseView(res *ListDatabasesResponse) *controlplaneviews.ListDatabasesResponseView {
	vres := &controlplaneviews.ListDatabasesResponseView{}
	if res.Databases != nil {
		vres.Databases = newDatabaseCollectionViewAbbreviated(res.Databases)
	}
	return vres
}

// newDatabaseCollection converts projected type DatabaseCollection to service
// type DatabaseCollection.
func newDatabaseCollection(vres controlplaneviews.DatabaseCollectionView) DatabaseCollection {
	res := make(DatabaseCollection, len(vres))
	for i, n := range vres {
		res[i] = newDatabase(n)
	}
	return res
}

// newDatabaseCollectionAbbreviated converts projected type DatabaseCollection
// to service type DatabaseCollection.
func newDatabaseCollectionAbbreviated(vres controlplaneviews.DatabaseCollectionView) DatabaseCollection {
	res := make(DatabaseCollection, len(vres))
	for i, n := range vres {
		res[i] = newDatabaseAbbreviated(n)
	}
	return res
}

// newDatabaseCollectionView projects result type DatabaseCollection to
// projected type DatabaseCollectionView using the "default" view.
func newDatabaseCollectionView(res DatabaseCollection) controlplaneviews.DatabaseCollectionView {
	vres := make(controlplaneviews.DatabaseCollectionView, len(res))
	for i, n := range res {
		vres[i] = newDatabaseView(n)
	}
	return vres
}

// newDatabaseCollectionViewAbbreviated projects result type DatabaseCollection
// to projected type DatabaseCollectionView using the "abbreviated" view.
func newDatabaseCollectionViewAbbreviated(res DatabaseCollection) controlplaneviews.DatabaseCollectionView {
	vres := make(controlplaneviews.DatabaseCollectionView, len(res))
	for i, n := range res {
		vres[i] = newDatabaseViewAbbreviated(n)
	}
	return vres
}

// newDatabase converts projected type Database to service type Database.
func newDatabase(vres *controlplaneviews.DatabaseView) *Database {
	res := &Database{}
	if vres.ID != nil {
		res.ID = Identifier(*vres.ID)
	}
	if vres.TenantID != nil {
		tenantID := Identifier(*vres.TenantID)
		res.TenantID = &tenantID
	}
	if vres.CreatedAt != nil {
		res.CreatedAt = *vres.CreatedAt
	}
	if vres.UpdatedAt != nil {
		res.UpdatedAt = *vres.UpdatedAt
	}
	if vres.State != nil {
		res.State = *vres.State
	}
	if vres.Spec != nil {
		res.Spec = transformControlplaneviewsDatabaseSpecViewToDatabaseSpec(vres.Spec)
	}
	if vres.Instances != nil {
		res.Instances = newInstanceCollection(vres.Instances)
	}
	return res
}

// newDatabaseAbbreviated converts projected type Database to service type
// Database.
func newDatabaseAbbreviated(vres *controlplaneviews.DatabaseView) *Database {
	res := &Database{}
	if vres.ID != nil {
		res.ID = Identifier(*vres.ID)
	}
	if vres.TenantID != nil {
		tenantID := Identifier(*vres.TenantID)
		res.TenantID = &tenantID
	}
	if vres.CreatedAt != nil {
		res.CreatedAt = *vres.CreatedAt
	}
	if vres.UpdatedAt != nil {
		res.UpdatedAt = *vres.UpdatedAt
	}
	if vres.State != nil {
		res.State = *vres.State
	}
	if vres.Instances != nil {
		res.Instances = newInstanceCollectionAbbreviated(vres.Instances)
	}
	return res
}

// newDatabaseView projects result type Database to projected type DatabaseView
// using the "default" view.
func newDatabaseView(res *Database) *controlplaneviews.DatabaseView {
	vres := &controlplaneviews.DatabaseView{
		CreatedAt: &res.CreatedAt,
		UpdatedAt: &res.UpdatedAt,
		State:     &res.State,
	}
	id := controlplaneviews.IdentifierView(res.ID)
	vres.ID = &id
	if res.TenantID != nil {
		tenantID := controlplaneviews.IdentifierView(*res.TenantID)
		vres.TenantID = &tenantID
	}
	if res.Spec != nil {
		vres.Spec = transformDatabaseSpecToControlplaneviewsDatabaseSpecView(res.Spec)
	}
	if res.Instances != nil {
		vres.Instances = newInstanceCollectionView(res.Instances)
	}
	return vres
}

// newDatabaseViewAbbreviated projects result type Database to projected type
// DatabaseView using the "abbreviated" view.
func newDatabaseViewAbbreviated(res *Database) *controlplaneviews.DatabaseView {
	vres := &controlplaneviews.DatabaseView{
		CreatedAt: &res.CreatedAt,
		UpdatedAt: &res.UpdatedAt,
		State:     &res.State,
	}
	id := controlplaneviews.IdentifierView(res.ID)
	vres.ID = &id
	if res.TenantID != nil {
		tenantID := controlplaneviews.IdentifierView(*res.TenantID)
		vres.TenantID = &tenantID
	}
	if res.Instances != nil {
		vres.Instances = newInstanceCollectionViewAbbreviated(res.Instances)
	}
	return vres
}

// newInstanceCollection converts projected type InstanceCollection to service
// type InstanceCollection.
func newInstanceCollection(vres controlplaneviews.InstanceCollectionView) InstanceCollection {
	res := make(InstanceCollection, len(vres))
	for i, n := range vres {
		res[i] = newInstance(n)
	}
	return res
}

// newInstanceCollectionAbbreviated converts projected type InstanceCollection
// to service type InstanceCollection.
func newInstanceCollectionAbbreviated(vres controlplaneviews.InstanceCollectionView) InstanceCollection {
	res := make(InstanceCollection, len(vres))
	for i, n := range vres {
		res[i] = newInstanceAbbreviated(n)
	}
	return res
}

// newInstanceCollectionView projects result type InstanceCollection to
// projected type InstanceCollectionView using the "default" view.
func newInstanceCollectionView(res InstanceCollection) controlplaneviews.InstanceCollectionView {
	vres := make(controlplaneviews.InstanceCollectionView, len(res))
	for i, n := range res {
		vres[i] = newInstanceView(n)
	}
	return vres
}

// newInstanceCollectionViewAbbreviated projects result type InstanceCollection
// to projected type InstanceCollectionView using the "abbreviated" view.
func newInstanceCollectionViewAbbreviated(res InstanceCollection) controlplaneviews.InstanceCollectionView {
	vres := make(controlplaneviews.InstanceCollectionView, len(res))
	for i, n := range res {
		vres[i] = newInstanceViewAbbreviated(n)
	}
	return vres
}

// newInstance converts projected type Instance to service type Instance.
func newInstance(vres *controlplaneviews.InstanceView) *Instance {
	res := &Instance{
		StatusUpdatedAt: vres.StatusUpdatedAt,
		Error:           vres.Error,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.HostID != nil {
		res.HostID = *vres.HostID
	}
	if vres.NodeName != nil {
		res.NodeName = *vres.NodeName
	}
	if vres.CreatedAt != nil {
		res.CreatedAt = *vres.CreatedAt
	}
	if vres.UpdatedAt != nil {
		res.UpdatedAt = *vres.UpdatedAt
	}
	if vres.State != nil {
		res.State = *vres.State
	}
	if vres.ConnectionInfo != nil {
		res.ConnectionInfo = transformControlplaneviewsInstanceConnectionInfoViewToInstanceConnectionInfo(vres.ConnectionInfo)
	}
	if vres.Postgres != nil {
		res.Postgres = transformControlplaneviewsInstancePostgresStatusViewToInstancePostgresStatus(vres.Postgres)
	}
	if vres.Spock != nil {
		res.Spock = transformControlplaneviewsInstanceSpockStatusViewToInstanceSpockStatus(vres.Spock)
	}
	return res
}

// newInstanceAbbreviated converts projected type Instance to service type
// Instance.
func newInstanceAbbreviated(vres *controlplaneviews.InstanceView) *Instance {
	res := &Instance{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.HostID != nil {
		res.HostID = *vres.HostID
	}
	if vres.NodeName != nil {
		res.NodeName = *vres.NodeName
	}
	if vres.State != nil {
		res.State = *vres.State
	}
	return res
}

// newInstanceView projects result type Instance to projected type InstanceView
// using the "default" view.
func newInstanceView(res *Instance) *controlplaneviews.InstanceView {
	vres := &controlplaneviews.InstanceView{
		ID:              &res.ID,
		HostID:          &res.HostID,
		NodeName:        &res.NodeName,
		CreatedAt:       &res.CreatedAt,
		UpdatedAt:       &res.UpdatedAt,
		StatusUpdatedAt: res.StatusUpdatedAt,
		State:           &res.State,
		Error:           res.Error,
	}
	if res.ConnectionInfo != nil {
		vres.ConnectionInfo = transformInstanceConnectionInfoToControlplaneviewsInstanceConnectionInfoView(res.ConnectionInfo)
	}
	if res.Postgres != nil {
		vres.Postgres = transformInstancePostgresStatusToControlplaneviewsInstancePostgresStatusView(res.Postgres)
	}
	if res.Spock != nil {
		vres.Spock = transformInstanceSpockStatusToControlplaneviewsInstanceSpockStatusView(res.Spock)
	}
	return vres
}

// newInstanceViewAbbreviated projects result type Instance to projected type
// InstanceView using the "abbreviated" view.
func newInstanceViewAbbreviated(res *Instance) *controlplaneviews.InstanceView {
	vres := &controlplaneviews.InstanceView{
		ID:       &res.ID,
		HostID:   &res.HostID,
		NodeName: &res.NodeName,
		State:    &res.State,
	}
	return vres
}

// transformControlplaneviewsDatabaseSpecViewToDatabaseSpec builds a value of
// type *DatabaseSpec from a value of type *controlplaneviews.DatabaseSpecView.
func transformControlplaneviewsDatabaseSpecViewToDatabaseSpec(v *controlplaneviews.DatabaseSpecView) *DatabaseSpec {
	if v == nil {
		return nil
	}
	res := &DatabaseSpec{
		DatabaseName:    *v.DatabaseName,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
		FailoverPolicy:  v.FailoverPolicy,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpec, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = transformControlplaneviewsDatabaseNodeSpecViewToDatabaseNodeSpec(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpec{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = transformControlplaneviewsDatabaseUserSpecViewToDatabaseUserSpec(val)
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = transformControlplaneviewsBackupConfigSpecViewToBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = transformControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpec(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = transformControlplaneviewsOrchestratorOptsViewToOrchestratorOpts(v.OrchestratorOpts)
	}

	return res
}

// transformControlplaneviewsDatabaseNodeSpecViewToDatabaseNodeSpec builds a
// value of type *DatabaseNodeSpec from a value of type
// *controlplaneviews.DatabaseNodeSpecView.
func transformControlplaneviewsDatabaseNodeSpecViewToDatabaseNodeSpec(v *controlplaneviews.DatabaseNodeSpecView) *DatabaseNodeSpec {
	res := &DatabaseNodeSpec{
		Name:            *v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
		SourceNode:      v.SourceNode,
		FailoverPolicy:  v.FailoverPolicy,
	}
	if v.HostIds != nil {
		res.HostIds = make([]Identifier, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = Identifier(val)
		}
	} else {
		res.HostIds = []Identifier{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = transformControlplaneviewsBackupConfigSpecViewToBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = transformControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpec(v.RestoreConfig)
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = transformControlplaneviewsOrchestratorOptsViewToOrchestratorOpts(v.OrchestratorOpts)
	}

	return res
}

// transformControlplaneviewsBackupConfigSpecViewToBackupConfigSpec builds a
// value of type *BackupConfigSpec from a value of type
// *controlplaneviews.BackupConfigSpecView.
func transformControlplaneviewsBackupConfigSpecViewToBackupConfigSpec(v *controlplaneviews.BackupConfigSpecView) *BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpec{}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpec, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = transformControlplaneviewsBackupRepositorySpecViewToBackupRepositorySpec(val)
		}
	} else {
		res.Repositories = []*BackupRepositorySpec{}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = transformControlplaneviewsBackupScheduleSpecViewToBackupScheduleSpec(val)
		}
	}

	return res
}

// transformControlplaneviewsBackupRepositorySpecViewToBackupRepositorySpec
// builds a value of type *BackupRepositorySpec from a value of type
// *controlplaneviews.BackupRepositorySpecView.
func transformControlplaneviewsBackupRepositorySpecViewToBackupRepositorySpec(v *controlplaneviews.BackupRepositorySpecView) *BackupRepositorySpec {
	res := &BackupRepositorySpec{
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.ID != nil {
		id := Identifier(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// transformControlplaneviewsBackupScheduleSpecViewToBackupScheduleSpec builds
// a value of type *BackupScheduleSpec from a value of type
// *controlplaneviews.BackupScheduleSpecView.
func transformControlplaneviewsBackupScheduleSpecViewToBackupScheduleSpec(v *controlplaneviews.BackupScheduleSpecView) *BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpec{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// transformControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpec builds a
// value of type *RestoreConfigSpec from a value of type
// *controlplaneviews.RestoreConfigSpecView.
func transformControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpec(v *controlplaneviews.RestoreConfigSpecView) *RestoreConfigSpec {
	if v == nil {
		return nil
	}
	res := &RestoreConfigSpec{
		SourceDatabaseID:   Identifier(*v.SourceDatabaseID),
		SourceNodeName:     *v.SourceNodeName,
		SourceDatabaseName: *v.SourceDatabaseName,
	}
	if v.Repository != nil {
		res.Repository = transformControlplaneviewsRestoreRepositorySpecViewToRestoreRepositorySpec(v.Repository)
	}
	if v.RestoreOptions != nil {
		res.RestoreOptions = make(map[string]string, len(v.RestoreOptions))
		for key, val := range v.RestoreOptions {
			tk := key
			tv := val
			res.RestoreOptions[tk] = tv
		}
	}

	return res
}

// transformControlplaneviewsRestoreRepositorySpecViewToRestoreRepositorySpec
// builds a value of type *RestoreRepositorySpec from a value of type
// *controlplaneviews.RestoreRepositorySpecView.
func transformControlplaneviewsRestoreRepositorySpecViewToRestoreRepositorySpec(v *controlplaneviews.RestoreRepositorySpecView) *RestoreRepositorySpec {
	res := &RestoreRepositorySpec{
		Type:           *v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.ID != nil {
		id := Identifier(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// transformControlplaneviewsOrchestratorOptsViewToOrchestratorOpts builds a
// value of type *OrchestratorOpts from a value of type
// *controlplaneviews.OrchestratorOptsView.
func transformControlplaneviewsOrchestratorOptsViewToOrchestratorOpts(v *controlplaneviews.OrchestratorOptsView) *OrchestratorOpts {
	if v == nil {
		return nil
	}
	res := &OrchestratorOpts{}
	if v.Swarm != nil {
		res.Swarm = transformControlplaneviewsSwarmOptsViewToSwarmOpts(v.Swarm)
	}

	return res
}

// transformControlplaneviewsSwarmOptsViewToSwarmOpts builds a value of type
// *SwarmOpts from a value of type *controlplaneviews.SwarmOptsView.
func transformControlplaneviewsSwarmOptsViewToSwarmOpts(v *controlplaneviews.SwarmOptsView) *SwarmOpts {
	if v == nil {
		return nil
	}
	res := &SwarmOpts{}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*ExtraVolumesSpec, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = transformControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpec(val)
		}
	}
	if v.ExtraNetworks != nil {
		res.ExtraNetworks = make([]*ExtraNetworkSpec, len(v.ExtraNetworks))
		for i, val := range v.ExtraNetworks {
			res.ExtraNetworks[i] = transformControlplaneviewsExtraNetworkSpecViewToExtraNetworkSpec(val)
		}
	}
	if v.ExtraLabels != nil {
		res.ExtraLabels = make(map[string]string, len(v.ExtraLabels))
		for key, val := range v.ExtraLabels {
			tk := key
			tv := val
			res.ExtraLabels[tk] = tv
		}
	}

	return res
}

// transformControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpec builds a
// value of type *ExtraVolumesSpec from a value of type
// *controlplaneviews.ExtraVolumesSpecView.
func transformControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpec(v *controlplaneviews.ExtraVolumesSpecView) *ExtraVolumesSpec {
	if v == nil {
		return nil
	}
	res := &ExtraVolumesSpec{
		HostPath:        *v.HostPath,
		DestinationPath: *v.DestinationPath,
	}

	return res
}

// transformControlplaneviewsExtraNetworkSpecViewToExtraNetworkSpec builds a
// value of type *ExtraNetworkSpec from a value of type
// *controlplaneviews.ExtraNetworkSpecView.
func transformControlplaneviewsExtraNetworkSpecViewToExtraNetworkSpec(v *controlplaneviews.ExtraNetworkSpecView) *ExtraNetworkSpec {
	if v == nil {
		return nil
	}
	res := &ExtraNetworkSpec{
		ID: *v.ID,
	}
	if v.Aliases != nil {
		res.Aliases = make([]string, len(v.Aliases))
		for i, val := range v.Aliases {
			res.Aliases[i] = val
		}
	}
	if v.DriverOpts != nil {
		res.DriverOpts = make(map[string]string, len(v.DriverOpts))
		for key, val := range v.DriverOpts {
			tk := key
			tv := val
			res.DriverOpts[tk] = tv
		}
	}

	return res
}

// transformControlplaneviewsDatabaseUserSpecViewToDatabaseUserSpec builds a
// value of type *DatabaseUserSpec from a value of type
// *controlplaneviews.DatabaseUserSpecView.
func transformControlplaneviewsDatabaseUserSpecViewToDatabaseUserSpec(v *controlplaneviews.DatabaseUserSpecView) *DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpec{
		Username: *v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// transformDatabaseSpecToControlplaneviewsDatabaseSpecView builds a value of
// type *controlplaneviews.DatabaseSpecView from a value of type *DatabaseSpec.
func transformDatabaseSpecToControlplaneviewsDatabaseSpecView(v *DatabaseSpec) *controlplaneviews.DatabaseSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.DatabaseSpecView{
		DatabaseName:    &v.DatabaseName,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
		FailoverPolicy:  v.FailoverPolicy,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*controlplaneviews.DatabaseNodeSpecView, len(v.Nodes))
		for i, val := range v.Nodes {
			res.Nodes[i] = transformDatabaseNodeSpecToControlplaneviewsDatabaseNodeSpecView(val)
		}
	} else {
		res.Nodes = []*controlplaneviews.DatabaseNodeSpecView{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplaneviews.DatabaseUserSpecView, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			res.DatabaseUsers[i] = transformDatabaseUserSpecToControlplaneviewsDatabaseUserSpecView(val)
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = transformBackupConfigSpecToControlplaneviewsBackupConfigSpecView(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = transformRestoreConfigSpecToControlplaneviewsRestoreConfigSpecView(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = transformOrchestratorOptsToControlplaneviewsOrchestratorOptsView(v.OrchestratorOpts)
	}

	return res
}

// transformDatabaseNodeSpecToControlplaneviewsDatabaseNodeSpecView builds a
// value of type *controlplaneviews.DatabaseNodeSpecView from a value of type
// *DatabaseNodeSpec.
func transformDatabaseNodeSpecToControlplaneviewsDatabaseNodeSpecView(v *DatabaseNodeSpec) *controlplaneviews.DatabaseNodeSpecView {
	res := &controlplaneviews.DatabaseNodeSpecView{
		Name:            &v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
		SourceNode:      v.SourceNode,
		FailoverPolicy:  v.FailoverPolicy,
	}
	if v.HostIds != nil {
		res.HostIds = make([]controlplaneviews.IdentifierView, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = controlplaneviews.IdentifierView(val)
		}
	} else {
		res.HostIds = []controlplaneviews.IdentifierView{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = transformBackupConfigSpecToControlplaneviewsBackupConfigSpecView(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = transformRestoreConfigSpecToControlplaneviewsRestoreConfigSpecView(v.RestoreConfig)
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = transformOrchestratorOptsToControlplaneviewsOrchestratorOptsView(v.OrchestratorOpts)
	}

	return res
}

// transformBackupConfigSpecToControlplaneviewsBackupConfigSpecView builds a
// value of type *controlplaneviews.BackupConfigSpecView from a value of type
// *BackupConfigSpec.
func transformBackupConfigSpecToControlplaneviewsBackupConfigSpecView(v *BackupConfigSpec) *controlplaneviews.BackupConfigSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.BackupConfigSpecView{}
	if v.Repositories != nil {
		res.Repositories = make([]*controlplaneviews.BackupRepositorySpecView, len(v.Repositories))
		for i, val := range v.Repositories {
			res.Repositories[i] = transformBackupRepositorySpecToControlplaneviewsBackupRepositorySpecView(val)
		}
	} else {
		res.Repositories = []*controlplaneviews.BackupRepositorySpecView{}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplaneviews.BackupScheduleSpecView, len(v.Schedules))
		for i, val := range v.Schedules {
			res.Schedules[i] = transformBackupScheduleSpecToControlplaneviewsBackupScheduleSpecView(val)
		}
	}

	return res
}

// transformBackupRepositorySpecToControlplaneviewsBackupRepositorySpecView
// builds a value of type *controlplaneviews.BackupRepositorySpecView from a
// value of type *BackupRepositorySpec.
func transformBackupRepositorySpecToControlplaneviewsBackupRepositorySpecView(v *BackupRepositorySpec) *controlplaneviews.BackupRepositorySpecView {
	res := &controlplaneviews.BackupRepositorySpecView{
		Type:              &v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.ID != nil {
		id := controlplaneviews.IdentifierView(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// transformBackupScheduleSpecToControlplaneviewsBackupScheduleSpecView builds
// a value of type *controlplaneviews.BackupScheduleSpecView from a value of
// type *BackupScheduleSpec.
func transformBackupScheduleSpecToControlplaneviewsBackupScheduleSpecView(v *BackupScheduleSpec) *controlplaneviews.BackupScheduleSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.BackupScheduleSpecView{
		ID:             &v.ID,
		Type:           &v.Type,
		CronExpression: &v.CronExpression,
	}

	return res
}

// transformRestoreConfigSpecToControlplaneviewsRestoreConfigSpecView builds a
// value of type *controlplaneviews.RestoreConfigSpecView from a value of type
// *RestoreConfigSpec.
func transformRestoreConfigSpecToControlplaneviewsRestoreConfigSpecView(v *RestoreConfigSpec) *controlplaneviews.RestoreConfigSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.RestoreConfigSpecView{
		SourceNodeName:     &v.SourceNodeName,
		SourceDatabaseName: &v.SourceDatabaseName,
	}
	sourceDatabaseID := controlplaneviews.IdentifierView(v.SourceDatabaseID)
	res.SourceDatabaseID = &sourceDatabaseID
	if v.Repository != nil {
		res.Repository = transformRestoreRepositorySpecToControlplaneviewsRestoreRepositorySpecView(v.Repository)
	}
	if v.RestoreOptions != nil {
		res.RestoreOptions = make(map[string]string, len(v.RestoreOptions))
		for key, val := range v.RestoreOptions {
			tk := key
			tv := val
			res.RestoreOptions[tk] = tv
		}
	}

	return res
}

// transformRestoreRepositorySpecToControlplaneviewsRestoreRepositorySpecView
// builds a value of type *controlplaneviews.RestoreRepositorySpecView from a
// value of type *RestoreRepositorySpec.
func transformRestoreRepositorySpecToControlplaneviewsRestoreRepositorySpecView(v *RestoreRepositorySpec) *controlplaneviews.RestoreRepositorySpecView {
	res := &controlplaneviews.RestoreRepositorySpecView{
		Type:           &v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.ID != nil {
		id := controlplaneviews.IdentifierView(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// transformOrchestratorOptsToControlplaneviewsOrchestratorOptsView builds a
// value of type *controlplaneviews.OrchestratorOptsView from a value of type
// *OrchestratorOpts.
func transformOrchestratorOptsToControlplaneviewsOrchestratorOptsView(v *OrchestratorOpts) *controlplaneviews.OrchestratorOptsView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.OrchestratorOptsView{}
	if v.Swarm != nil {
		res.Swarm = transformSwarmOptsToControlplaneviewsSwarmOptsView(v.Swarm)
	}

	return res
}

// transformSwarmOptsToControlplaneviewsSwarmOptsView builds a value of type
// *controlplaneviews.SwarmOptsView from a value of type *SwarmOpts.
func transformSwarmOptsToControlplaneviewsSwarmOptsView(v *SwarmOpts) *controlplaneviews.SwarmOptsView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.SwarmOptsView{}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*controlplaneviews.ExtraVolumesSpecView, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			res.ExtraVolumes[i] = transformExtraVolumesSpecToControlplaneviewsExtraVolumesSpecView(val)
		}
	}
	if v.ExtraNetworks != nil {
		res.ExtraNetworks = make([]*controlplaneviews.ExtraNetworkSpecView, len(v.ExtraNetworks))
		for i, val := range v.ExtraNetworks {
			res.ExtraNetworks[i] = transformExtraNetworkSpecToControlplaneviewsExtraNetworkSpecView(val)
		}
	}
	if v.ExtraLabels != nil {
		res.ExtraLabels = make(map[string]string, len(v.ExtraLabels))
		for key, val := range v.ExtraLabels {
			tk := key
			tv := val
			res.ExtraLabels[tk] = tv
		}
	}

	return res
}

// transformExtraVolumesSpecToControlplaneviewsExtraVolumesSpecView builds a
// value of type *controlplaneviews.ExtraVolumesSpecView from a value of type
// *ExtraVolumesSpec.
func transformExtraVolumesSpecToControlplaneviewsExtraVolumesSpecView(v *ExtraVolumesSpec) *controlplaneviews.ExtraVolumesSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.ExtraVolumesSpecView{
		HostPath:        &v.HostPath,
		DestinationPath: &v.DestinationPath,
	}

	return res
}

// transformExtraNetworkSpecToControlplaneviewsExtraNetworkSpecView builds a
// value of type *controlplaneviews.ExtraNetworkSpecView from a value of type
// *ExtraNetworkSpec.
func transformExtraNetworkSpecToControlplaneviewsExtraNetworkSpecView(v *ExtraNetworkSpec) *controlplaneviews.ExtraNetworkSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.ExtraNetworkSpecView{
		ID: &v.ID,
	}
	if v.Aliases != nil {
		res.Aliases = make([]string, len(v.Aliases))
		for i, val := range v.Aliases {
			res.Aliases[i] = val
		}
	}
	if v.DriverOpts != nil {
		res.DriverOpts = make(map[string]string, len(v.DriverOpts))
		for key, val := range v.DriverOpts {
			tk := key
			tv := val
			res.DriverOpts[tk] = tv
		}
	}

	return res
}

// transformDatabaseUserSpecToControlplaneviewsDatabaseUserSpecView builds a
// value of type *controlplaneviews.DatabaseUserSpecView from a value of type
// *DatabaseUserSpec.
func transformDatabaseUserSpecToControlplaneviewsDatabaseUserSpecView(v *DatabaseUserSpec) *controlplaneviews.DatabaseUserSpecView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.DatabaseUserSpecView{
		Username: &v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// transformControlplaneviewsInstanceConnectionInfoViewToInstanceConnectionInfo
// builds a value of type *InstanceConnectionInfo from a value of type
// *controlplaneviews.InstanceConnectionInfoView.
func transformControlplaneviewsInstanceConnectionInfoViewToInstanceConnectionInfo(v *controlplaneviews.InstanceConnectionInfoView) *InstanceConnectionInfo {
	if v == nil {
		return nil
	}
	res := &InstanceConnectionInfo{
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// transformControlplaneviewsInstancePostgresStatusViewToInstancePostgresStatus
// builds a value of type *InstancePostgresStatus from a value of type
// *controlplaneviews.InstancePostgresStatusView.
func transformControlplaneviewsInstancePostgresStatusViewToInstancePostgresStatus(v *controlplaneviews.InstancePostgresStatusView) *InstancePostgresStatus {
	if v == nil {
		return nil
	}
	res := &InstancePostgresStatus{
		Version:        v.Version,
		PatroniState:   v.PatroniState,
		Role:           v.Role,
		PendingRestart: v.PendingRestart,
		PatroniPaused:  v.PatroniPaused,
	}

	return res
}

// transformControlplaneviewsInstanceSpockStatusViewToInstanceSpockStatus
// builds a value of type *InstanceSpockStatus from a value of type
// *controlplaneviews.InstanceSpockStatusView.
func transformControlplaneviewsInstanceSpockStatusViewToInstanceSpockStatus(v *controlplaneviews.InstanceSpockStatusView) *InstanceSpockStatus {
	if v == nil {
		return nil
	}
	res := &InstanceSpockStatus{
		ReadOnly: v.ReadOnly,
		Version:  v.Version,
	}
	if v.Subscriptions != nil {
		res.Subscriptions = make([]*InstanceSubscription, len(v.Subscriptions))
		for i, val := range v.Subscriptions {
			res.Subscriptions[i] = transformControlplaneviewsInstanceSubscriptionViewToInstanceSubscription(val)
		}
	}

	return res
}

// transformControlplaneviewsInstanceSubscriptionViewToInstanceSubscription
// builds a value of type *InstanceSubscription from a value of type
// *controlplaneviews.InstanceSubscriptionView.
func transformControlplaneviewsInstanceSubscriptionViewToInstanceSubscription(v *controlplaneviews.InstanceSubscriptionView) *InstanceSubscription {
	if v == nil {
		return nil
	}
	res := &InstanceSubscription{
		ProviderNode: *v.ProviderNode,
		Name:         *v.Name,
		Status:       *v.Status,
	}

	return res
}

// transformInstanceConnectionInfoToControlplaneviewsInstanceConnectionInfoView
// builds a value of type *controlplaneviews.InstanceConnectionInfoView from a
// value of type *InstanceConnectionInfo.
func transformInstanceConnectionInfoToControlplaneviewsInstanceConnectionInfoView(v *InstanceConnectionInfo) *controlplaneviews.InstanceConnectionInfoView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.InstanceConnectionInfoView{
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// transformInstancePostgresStatusToControlplaneviewsInstancePostgresStatusView
// builds a value of type *controlplaneviews.InstancePostgresStatusView from a
// value of type *InstancePostgresStatus.
func transformInstancePostgresStatusToControlplaneviewsInstancePostgresStatusView(v *InstancePostgresStatus) *controlplaneviews.InstancePostgresStatusView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.InstancePostgresStatusView{
		Version:        v.Version,
		PatroniState:   v.PatroniState,
		Role:           v.Role,
		PendingRestart: v.PendingRestart,
		PatroniPaused:  v.PatroniPaused,
	}

	return res
}

// transformInstanceSpockStatusToControlplaneviewsInstanceSpockStatusView
// builds a value of type *controlplaneviews.InstanceSpockStatusView from a
// value of type *InstanceSpockStatus.
func transformInstanceSpockStatusToControlplaneviewsInstanceSpockStatusView(v *InstanceSpockStatus) *controlplaneviews.InstanceSpockStatusView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.InstanceSpockStatusView{
		ReadOnly: v.ReadOnly,
		Version:  v.Version,
	}
	if v.Subscriptions != nil {
		res.Subscriptions = make([]*controlplaneviews.InstanceSubscriptionView, len(v.Subscriptions))
		for i, val := range v.Subscriptions {
			res.Subscriptions[i] = transformInstanceSubscriptionToControlplaneviewsInstanceSubscriptionView(val)
		}
	}

	return res
}

// transformInstanceSubscriptionToControlplaneviewsInstanceSubscriptionView
// builds a value of type *controlplaneviews.InstanceSubscriptionView from a
// value of type *InstanceSubscription.
func transformInstanceSubscriptionToControlplaneviewsInstanceSubscriptionView(v *InstanceSubscription) *controlplaneviews.InstanceSubscriptionView {
	if v == nil {
		return nil
	}
	res := &controlplaneviews.InstanceSubscriptionView{
		ProviderNode: &v.ProviderNode,
		Name:         &v.Name,
		Status:       &v.Status,
	}

	return res
}
