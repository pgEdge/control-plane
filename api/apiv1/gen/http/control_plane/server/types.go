// Code generated by goa v3.19.1, DO NOT EDIT.
//
// control-plane HTTP server types
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/apiv1/design -o apiv1

package server

import (
	"unicode/utf8"

	controlplane "github.com/pgEdge/control-plane/api/apiv1/gen/control_plane"
	controlplaneviews "github.com/pgEdge/control-plane/api/apiv1/gen/control_plane/views"
	goa "goa.design/goa/v3/pkg"
)

// JoinClusterRequestBody is the type of the "control-plane" service
// "join-cluster" endpoint HTTP request body.
type JoinClusterRequestBody struct {
	// Token to join an existing cluster.
	Token *string `form:"token,omitempty" json:"token,omitempty" xml:"token,omitempty"`
	// Existing server to join
	ServerURL *string `form:"server_url,omitempty" json:"server_url,omitempty" xml:"server_url,omitempty"`
}

// GetJoinOptionsRequestBody is the type of the "control-plane" service
// "get-join-options" endpoint HTTP request body.
type GetJoinOptionsRequestBody struct {
	// Token to join the cluster.
	Token *string `form:"token,omitempty" json:"token,omitempty" xml:"token,omitempty"`
	// The unique identifier for the host that's joining the cluster.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The hostname of the host that's joining the cluster.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of the host that's joining the cluster.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
}

// CreateDatabaseRequestBody is the type of the "control-plane" service
// "create-database" endpoint HTTP request body.
type CreateDatabaseRequestBody struct {
	// Unique identifier for the database.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The specification for the database.
	Spec *DatabaseSpecRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseRequestBody is the type of the "control-plane" service
// "update-database" endpoint HTTP request body.
type UpdateDatabaseRequestBody struct {
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The specification for the database.
	Spec *DatabaseSpecRequestBodyRequestBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// BackupDatabaseNodeRequestBody is the type of the "control-plane" service
// "backup-database-node" endpoint HTTP request body.
type BackupDatabaseNodeRequestBody struct {
	// The type of backup.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Annotations for the backup.
	Annotations map[string]string `form:"annotations,omitempty" json:"annotations,omitempty" xml:"annotations,omitempty"`
	// Options for the backup.
	BackupOptions map[string]string `form:"backup_options,omitempty" json:"backup_options,omitempty" xml:"backup_options,omitempty"`
}

// SwitchoverDatabaseNodeRequestBody is the type of the "control-plane" service
// "switchover-database-node" endpoint HTTP request body.
type SwitchoverDatabaseNodeRequestBody struct {
	// Optional instance_id for the replica candidate.
	CandidateInstanceID *string `form:"candidate_instance_id,omitempty" json:"candidate_instance_id,omitempty" xml:"candidate_instance_id,omitempty"`
	// Optional scheduled time (ISO8601) for the switchover. If absent switchover
	// happens immediately.
	ScheduledAt *string `form:"scheduled_at,omitempty" json:"scheduled_at,omitempty" xml:"scheduled_at,omitempty"`
}

// FailoverDatabaseNodeRequestBody is the type of the "control-plane" service
// "failover-database-node" endpoint HTTP request body.
type FailoverDatabaseNodeRequestBody struct {
	// Optional instance_id of the replica to promote. If omitted, a candidate will
	// be selected.
	CandidateInstanceID *string `form:"candidate_instance_id,omitempty" json:"candidate_instance_id,omitempty" xml:"candidate_instance_id,omitempty"`
	// If true, skip the health validations that prevent running failover on a
	// healthy cluster.
	SkipValidation *bool `form:"skip_validation,omitempty" json:"skip_validation,omitempty" xml:"skip_validation,omitempty"`
}

// RestoreDatabaseRequestBody is the type of the "control-plane" service
// "restore-database" endpoint HTTP request body.
type RestoreDatabaseRequestBody struct {
	// Configuration for the restore process.
	RestoreConfig *RestoreConfigSpecRequestBodyRequestBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// The nodes to restore. Defaults to all nodes if empty or unspecified.
	TargetNodes []string `form:"target_nodes,omitempty" json:"target_nodes,omitempty" xml:"target_nodes,omitempty"`
}

// RestartInstanceRequestBody is the type of the "control-plane" service
// "restart-instance" endpoint HTTP request body.
type RestartInstanceRequestBody struct {
	// The time at which the restart is scheduled.
	ScheduledAt *string `form:"scheduled_at,omitempty" json:"scheduled_at,omitempty" xml:"scheduled_at,omitempty"`
}

// InitClusterResponseBody is the type of the "control-plane" service
// "init-cluster" endpoint HTTP response body.
type InitClusterResponseBody struct {
	// Token to join an existing cluster.
	Token string `form:"token" json:"token" xml:"token"`
	// Existing server to join
	ServerURL string `form:"server_url" json:"server_url" xml:"server_url"`
}

// GetJoinTokenResponseBody is the type of the "control-plane" service
// "get-join-token" endpoint HTTP response body.
type GetJoinTokenResponseBody struct {
	// Token to join an existing cluster.
	Token string `form:"token" json:"token" xml:"token"`
	// Existing server to join
	ServerURL string `form:"server_url" json:"server_url" xml:"server_url"`
}

// GetJoinOptionsResponseBody is the type of the "control-plane" service
// "get-join-options" endpoint HTTP response body.
type GetJoinOptionsResponseBody struct {
	// Information about this cluster member
	Peer *ClusterPeerResponseBody `form:"peer" json:"peer" xml:"peer"`
	// Credentials for the new host joining the cluster.
	Credentials *ClusterCredentialsResponseBody `form:"credentials" json:"credentials" xml:"credentials"`
}

// GetClusterResponseBody is the type of the "control-plane" service
// "get-cluster" endpoint HTTP response body.
type GetClusterResponseBody struct {
	// Unique identifier for the cluster.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the cluster's owner.
	TenantID string `form:"tenant_id" json:"tenant_id" xml:"tenant_id"`
	// Current status of the cluster.
	Status *ClusterStatusResponseBody `form:"status" json:"status" xml:"status"`
	// All of the hosts in the cluster.
	Hosts []*HostResponseBody `form:"hosts" json:"hosts" xml:"hosts"`
}

// ListHostsResponseBody is the type of the "control-plane" service
// "list-hosts" endpoint HTTP response body.
type ListHostsResponseBody []*HostResponse

// GetHostResponseBody is the type of the "control-plane" service "get-host"
// endpoint HTTP response body.
type GetHostResponseBody struct {
	// Unique identifier for the host.
	ID string `form:"id" json:"id" xml:"id"`
	// The orchestrator used by this host.
	Orchestrator string `form:"orchestrator" json:"orchestrator" xml:"orchestrator"`
	// The data directory for the host.
	DataDir string `form:"data_dir" json:"data_dir" xml:"data_dir"`
	// The cohort that this host belongs to.
	Cohort *HostCohortResponseBody `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of this host.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
	// The number of CPUs on this host.
	Cpus *int `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory available on this host.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Current status of the host.
	Status *HostStatusResponseBody `form:"status" json:"status" xml:"status"`
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersionResponseBody `form:"default_pgedge_version,omitempty" json:"default_pgedge_version,omitempty" xml:"default_pgedge_version,omitempty"`
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersionResponseBody `form:"supported_pgedge_versions,omitempty" json:"supported_pgedge_versions,omitempty" xml:"supported_pgedge_versions,omitempty"`
}

// ListDatabasesResponseBody is the type of the "control-plane" service
// "list-databases" endpoint HTTP response body.
type ListDatabasesResponseBody struct {
	Databases DatabaseResponseBodyAbbreviatedCollection `form:"databases,omitempty" json:"databases,omitempty" xml:"databases,omitempty"`
}

// CreateDatabaseResponseBody is the type of the "control-plane" service
// "create-database" endpoint HTTP response body.
type CreateDatabaseResponseBody struct {
	// The task that will create this database.
	Task *TaskResponseBody `form:"task" json:"task" xml:"task"`
	// The database being created.
	Database *DatabaseResponseBody `form:"database" json:"database" xml:"database"`
}

// GetDatabaseResponseBody is the type of the "control-plane" service
// "get-database" endpoint HTTP response body.
type GetDatabaseResponseBody struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the database.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time that the database was last updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// Current state of the database.
	State string `form:"state" json:"state" xml:"state"`
	// All of the instances in the database.
	Instances InstanceResponseBodyCollection `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// UpdateDatabaseResponseBody is the type of the "control-plane" service
// "update-database" endpoint HTTP response body.
type UpdateDatabaseResponseBody struct {
	// The task that will update this database.
	Task *TaskResponseBody `form:"task" json:"task" xml:"task"`
	// The database being updated.
	Database *DatabaseResponseBody `form:"database" json:"database" xml:"database"`
}

// DeleteDatabaseResponseBody is the type of the "control-plane" service
// "delete-database" endpoint HTTP response body.
type DeleteDatabaseResponseBody struct {
	// The task that will delete this database.
	Task *TaskResponseBody `form:"task" json:"task" xml:"task"`
}

// BackupDatabaseNodeResponseBody is the type of the "control-plane" service
// "backup-database-node" endpoint HTTP response body.
type BackupDatabaseNodeResponseBody struct {
	// The task that will backup this database node.
	Task *TaskResponseBody `form:"task" json:"task" xml:"task"`
}

// SwitchoverDatabaseNodeResponseBody is the type of the "control-plane"
// service "switchover-database-node" endpoint HTTP response body.
type SwitchoverDatabaseNodeResponseBody struct {
	// The task that will perform the switchover.
	Task *TaskResponseBody `form:"task" json:"task" xml:"task"`
}

// FailoverDatabaseNodeResponseBody is the type of the "control-plane" service
// "failover-database-node" endpoint HTTP response body.
type FailoverDatabaseNodeResponseBody struct {
	// The task that will perform the failover.
	Task *TaskResponseBody `form:"task" json:"task" xml:"task"`
}

// ListDatabaseTasksResponseBody is the type of the "control-plane" service
// "list-database-tasks" endpoint HTTP response body.
type ListDatabaseTasksResponseBody struct {
	Tasks []*TaskResponseBody `form:"tasks,omitempty" json:"tasks,omitempty" xml:"tasks,omitempty"`
}

// GetDatabaseTaskResponseBody is the type of the "control-plane" service
// "get-database-task" endpoint HTTP response body.
type GetDatabaseTaskResponseBody struct {
	// The parent task ID of the task.
	ParentID *string `form:"parent_id,omitempty" json:"parent_id,omitempty" xml:"parent_id,omitempty"`
	// The database ID of the task.
	DatabaseID string `form:"database_id" json:"database_id" xml:"database_id"`
	// The name of the node that the task is operating on.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The ID of the instance that the task is operating on.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that the task is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The unique ID of the task.
	TaskID string `form:"task_id" json:"task_id" xml:"task_id"`
	// The time when the task was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time when the task was completed.
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
	// The type of the task.
	Type string `form:"type" json:"type" xml:"type"`
	// The status of the task.
	Status string `form:"status" json:"status" xml:"status"`
	// The error message if the task failed.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// GetDatabaseTaskLogResponseBody is the type of the "control-plane" service
// "get-database-task-log" endpoint HTTP response body.
type GetDatabaseTaskLogResponseBody struct {
	// The database ID of the task log.
	DatabaseID string `form:"database_id" json:"database_id" xml:"database_id"`
	// The unique ID of the task log.
	TaskID string `form:"task_id" json:"task_id" xml:"task_id"`
	// The status of the task.
	TaskStatus string `form:"task_status" json:"task_status" xml:"task_status"`
	// The ID of the last entry in the task log.
	LastEntryID *string `form:"last_entry_id,omitempty" json:"last_entry_id,omitempty" xml:"last_entry_id,omitempty"`
	// Entries in the task log.
	Entries []*TaskLogEntryResponseBody `form:"entries" json:"entries" xml:"entries"`
}

// RestoreDatabaseResponseBody is the type of the "control-plane" service
// "restore-database" endpoint HTTP response body.
type RestoreDatabaseResponseBody struct {
	// The task that will restore this database.
	Task *TaskResponseBody `form:"task" json:"task" xml:"task"`
	// The tasks that will restore each database node.
	NodeTasks []*TaskResponseBody `form:"node_tasks" json:"node_tasks" xml:"node_tasks"`
	// The database being restored.
	Database *DatabaseResponseBody `form:"database" json:"database" xml:"database"`
}

// GetVersionResponseBody is the type of the "control-plane" service
// "get-version" endpoint HTTP response body.
type GetVersionResponseBody struct {
	// The version of the API server.
	Version string `form:"version" json:"version" xml:"version"`
	// The VCS revision of the API server.
	Revision string `form:"revision" json:"revision" xml:"revision"`
	// The timestamp associated with the revision.
	RevisionTime string `form:"revision_time" json:"revision_time" xml:"revision_time"`
	// The CPU architecture of the API server.
	Arch string `form:"arch" json:"arch" xml:"arch"`
}

// RestartInstanceResponseBody is the type of the "control-plane" service
// "restart-instance" endpoint HTTP response body.
type RestartInstanceResponseBody struct {
	// The parent task ID of the task.
	ParentID *string `form:"parent_id,omitempty" json:"parent_id,omitempty" xml:"parent_id,omitempty"`
	// The database ID of the task.
	DatabaseID string `form:"database_id" json:"database_id" xml:"database_id"`
	// The name of the node that the task is operating on.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The ID of the instance that the task is operating on.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that the task is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The unique ID of the task.
	TaskID string `form:"task_id" json:"task_id" xml:"task_id"`
	// The time when the task was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time when the task was completed.
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
	// The type of the task.
	Type string `form:"type" json:"type" xml:"type"`
	// The status of the task.
	Status string `form:"status" json:"status" xml:"status"`
	// The error message if the task failed.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// StopInstanceResponseBody is the type of the "control-plane" service
// "stop-instance" endpoint HTTP response body.
type StopInstanceResponseBody struct {
	// The parent task ID of the task.
	ParentID *string `form:"parent_id,omitempty" json:"parent_id,omitempty" xml:"parent_id,omitempty"`
	// The database ID of the task.
	DatabaseID string `form:"database_id" json:"database_id" xml:"database_id"`
	// The name of the node that the task is operating on.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The ID of the instance that the task is operating on.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that the task is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The unique ID of the task.
	TaskID string `form:"task_id" json:"task_id" xml:"task_id"`
	// The time when the task was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time when the task was completed.
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
	// The type of the task.
	Type string `form:"type" json:"type" xml:"type"`
	// The status of the task.
	Status string `form:"status" json:"status" xml:"status"`
	// The error message if the task failed.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// StartInstanceResponseBody is the type of the "control-plane" service
// "start-instance" endpoint HTTP response body.
type StartInstanceResponseBody struct {
	// The parent task ID of the task.
	ParentID *string `form:"parent_id,omitempty" json:"parent_id,omitempty" xml:"parent_id,omitempty"`
	// The database ID of the task.
	DatabaseID string `form:"database_id" json:"database_id" xml:"database_id"`
	// The name of the node that the task is operating on.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The ID of the instance that the task is operating on.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that the task is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The unique ID of the task.
	TaskID string `form:"task_id" json:"task_id" xml:"task_id"`
	// The time when the task was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time when the task was completed.
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
	// The type of the task.
	Type string `form:"type" json:"type" xml:"type"`
	// The status of the task.
	Status string `form:"status" json:"status" xml:"status"`
	// The error message if the task failed.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// CancelDatabaseTaskResponseBody is the type of the "control-plane" service
// "cancel-database-task" endpoint HTTP response body.
type CancelDatabaseTaskResponseBody struct {
	// The parent task ID of the task.
	ParentID *string `form:"parent_id,omitempty" json:"parent_id,omitempty" xml:"parent_id,omitempty"`
	// The database ID of the task.
	DatabaseID string `form:"database_id" json:"database_id" xml:"database_id"`
	// The name of the node that the task is operating on.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The ID of the instance that the task is operating on.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that the task is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The unique ID of the task.
	TaskID string `form:"task_id" json:"task_id" xml:"task_id"`
	// The time when the task was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time when the task was completed.
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
	// The type of the task.
	Type string `form:"type" json:"type" xml:"type"`
	// The status of the task.
	Status string `form:"status" json:"status" xml:"status"`
	// The error message if the task failed.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// InitClusterClusterAlreadyInitializedResponseBody is the type of the
// "control-plane" service "init-cluster" endpoint HTTP response body for the
// "cluster_already_initialized" error.
type InitClusterClusterAlreadyInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// InitClusterServerErrorResponseBody is the type of the "control-plane"
// service "init-cluster" endpoint HTTP response body for the "server_error"
// error.
type InitClusterServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// JoinClusterClusterAlreadyInitializedResponseBody is the type of the
// "control-plane" service "join-cluster" endpoint HTTP response body for the
// "cluster_already_initialized" error.
type JoinClusterClusterAlreadyInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// JoinClusterInvalidJoinTokenResponseBody is the type of the "control-plane"
// service "join-cluster" endpoint HTTP response body for the
// "invalid_join_token" error.
type JoinClusterInvalidJoinTokenResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// JoinClusterServerErrorResponseBody is the type of the "control-plane"
// service "join-cluster" endpoint HTTP response body for the "server_error"
// error.
type JoinClusterServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetJoinTokenClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-join-token" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type GetJoinTokenClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetJoinTokenServerErrorResponseBody is the type of the "control-plane"
// service "get-join-token" endpoint HTTP response body for the "server_error"
// error.
type GetJoinTokenServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetJoinOptionsClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-join-options" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type GetJoinOptionsClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetJoinOptionsInvalidJoinTokenResponseBody is the type of the
// "control-plane" service "get-join-options" endpoint HTTP response body for
// the "invalid_join_token" error.
type GetJoinOptionsInvalidJoinTokenResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetJoinOptionsServerErrorResponseBody is the type of the "control-plane"
// service "get-join-options" endpoint HTTP response body for the
// "server_error" error.
type GetJoinOptionsServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetClusterClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-cluster" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type GetClusterClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetClusterServerErrorResponseBody is the type of the "control-plane" service
// "get-cluster" endpoint HTTP response body for the "server_error" error.
type GetClusterServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// ListHostsClusterNotInitializedResponseBody is the type of the
// "control-plane" service "list-hosts" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type ListHostsClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// ListHostsServerErrorResponseBody is the type of the "control-plane" service
// "list-hosts" endpoint HTTP response body for the "server_error" error.
type ListHostsServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetHostClusterNotInitializedResponseBody is the type of the "control-plane"
// service "get-host" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type GetHostClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetHostInvalidInputResponseBody is the type of the "control-plane" service
// "get-host" endpoint HTTP response body for the "invalid_input" error.
type GetHostInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetHostNotFoundResponseBody is the type of the "control-plane" service
// "get-host" endpoint HTTP response body for the "not_found" error.
type GetHostNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetHostServerErrorResponseBody is the type of the "control-plane" service
// "get-host" endpoint HTTP response body for the "server_error" error.
type GetHostServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RemoveHostClusterNotInitializedResponseBody is the type of the
// "control-plane" service "remove-host" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type RemoveHostClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RemoveHostInvalidInputResponseBody is the type of the "control-plane"
// service "remove-host" endpoint HTTP response body for the "invalid_input"
// error.
type RemoveHostInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RemoveHostNotFoundResponseBody is the type of the "control-plane" service
// "remove-host" endpoint HTTP response body for the "not_found" error.
type RemoveHostNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RemoveHostServerErrorResponseBody is the type of the "control-plane" service
// "remove-host" endpoint HTTP response body for the "server_error" error.
type RemoveHostServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// ListDatabasesClusterNotInitializedResponseBody is the type of the
// "control-plane" service "list-databases" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type ListDatabasesClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// ListDatabasesServerErrorResponseBody is the type of the "control-plane"
// service "list-databases" endpoint HTTP response body for the "server_error"
// error.
type ListDatabasesServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateDatabaseDatabaseAlreadyExistsResponseBody is the type of the
// "control-plane" service "create-database" endpoint HTTP response body for
// the "database_already_exists" error.
type CreateDatabaseDatabaseAlreadyExistsResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "create-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type CreateDatabaseClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateDatabaseOperationAlreadyInProgressResponseBody is the type of the
// "control-plane" service "create-database" endpoint HTTP response body for
// the "operation_already_in_progress" error.
type CreateDatabaseOperationAlreadyInProgressResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateDatabaseInvalidInputResponseBody is the type of the "control-plane"
// service "create-database" endpoint HTTP response body for the
// "invalid_input" error.
type CreateDatabaseInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateDatabaseServerErrorResponseBody is the type of the "control-plane"
// service "create-database" endpoint HTTP response body for the "server_error"
// error.
type CreateDatabaseServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-database" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type GetDatabaseClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseInvalidInputResponseBody is the type of the "control-plane"
// service "get-database" endpoint HTTP response body for the "invalid_input"
// error.
type GetDatabaseInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseNotFoundResponseBody is the type of the "control-plane" service
// "get-database" endpoint HTTP response body for the "not_found" error.
type GetDatabaseNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseServerErrorResponseBody is the type of the "control-plane"
// service "get-database" endpoint HTTP response body for the "server_error"
// error.
type GetDatabaseServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "update-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type UpdateDatabaseClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateDatabaseDatabaseNotModifiableResponseBody is the type of the
// "control-plane" service "update-database" endpoint HTTP response body for
// the "database_not_modifiable" error.
type UpdateDatabaseDatabaseNotModifiableResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateDatabaseOperationAlreadyInProgressResponseBody is the type of the
// "control-plane" service "update-database" endpoint HTTP response body for
// the "operation_already_in_progress" error.
type UpdateDatabaseOperationAlreadyInProgressResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateDatabaseInvalidInputResponseBody is the type of the "control-plane"
// service "update-database" endpoint HTTP response body for the
// "invalid_input" error.
type UpdateDatabaseInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateDatabaseNotFoundResponseBody is the type of the "control-plane"
// service "update-database" endpoint HTTP response body for the "not_found"
// error.
type UpdateDatabaseNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateDatabaseServerErrorResponseBody is the type of the "control-plane"
// service "update-database" endpoint HTTP response body for the "server_error"
// error.
type UpdateDatabaseServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "delete-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type DeleteDatabaseClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteDatabaseDatabaseNotModifiableResponseBody is the type of the
// "control-plane" service "delete-database" endpoint HTTP response body for
// the "database_not_modifiable" error.
type DeleteDatabaseDatabaseNotModifiableResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteDatabaseOperationAlreadyInProgressResponseBody is the type of the
// "control-plane" service "delete-database" endpoint HTTP response body for
// the "operation_already_in_progress" error.
type DeleteDatabaseOperationAlreadyInProgressResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteDatabaseInvalidInputResponseBody is the type of the "control-plane"
// service "delete-database" endpoint HTTP response body for the
// "invalid_input" error.
type DeleteDatabaseInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteDatabaseNotFoundResponseBody is the type of the "control-plane"
// service "delete-database" endpoint HTTP response body for the "not_found"
// error.
type DeleteDatabaseNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteDatabaseServerErrorResponseBody is the type of the "control-plane"
// service "delete-database" endpoint HTTP response body for the "server_error"
// error.
type DeleteDatabaseServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// BackupDatabaseNodeClusterNotInitializedResponseBody is the type of the
// "control-plane" service "backup-database-node" endpoint HTTP response body
// for the "cluster_not_initialized" error.
type BackupDatabaseNodeClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// BackupDatabaseNodeDatabaseNotModifiableResponseBody is the type of the
// "control-plane" service "backup-database-node" endpoint HTTP response body
// for the "database_not_modifiable" error.
type BackupDatabaseNodeDatabaseNotModifiableResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// BackupDatabaseNodeOperationAlreadyInProgressResponseBody is the type of the
// "control-plane" service "backup-database-node" endpoint HTTP response body
// for the "operation_already_in_progress" error.
type BackupDatabaseNodeOperationAlreadyInProgressResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// BackupDatabaseNodeInvalidInputResponseBody is the type of the
// "control-plane" service "backup-database-node" endpoint HTTP response body
// for the "invalid_input" error.
type BackupDatabaseNodeInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// BackupDatabaseNodeNotFoundResponseBody is the type of the "control-plane"
// service "backup-database-node" endpoint HTTP response body for the
// "not_found" error.
type BackupDatabaseNodeNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// BackupDatabaseNodeServerErrorResponseBody is the type of the "control-plane"
// service "backup-database-node" endpoint HTTP response body for the
// "server_error" error.
type BackupDatabaseNodeServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// SwitchoverDatabaseNodeClusterNotInitializedResponseBody is the type of the
// "control-plane" service "switchover-database-node" endpoint HTTP response
// body for the "cluster_not_initialized" error.
type SwitchoverDatabaseNodeClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// SwitchoverDatabaseNodeDatabaseNotModifiableResponseBody is the type of the
// "control-plane" service "switchover-database-node" endpoint HTTP response
// body for the "database_not_modifiable" error.
type SwitchoverDatabaseNodeDatabaseNotModifiableResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// SwitchoverDatabaseNodeOperationAlreadyInProgressResponseBody is the type of
// the "control-plane" service "switchover-database-node" endpoint HTTP
// response body for the "operation_already_in_progress" error.
type SwitchoverDatabaseNodeOperationAlreadyInProgressResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// SwitchoverDatabaseNodeInvalidInputResponseBody is the type of the
// "control-plane" service "switchover-database-node" endpoint HTTP response
// body for the "invalid_input" error.
type SwitchoverDatabaseNodeInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// SwitchoverDatabaseNodeNotFoundResponseBody is the type of the
// "control-plane" service "switchover-database-node" endpoint HTTP response
// body for the "not_found" error.
type SwitchoverDatabaseNodeNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// SwitchoverDatabaseNodeServerErrorResponseBody is the type of the
// "control-plane" service "switchover-database-node" endpoint HTTP response
// body for the "server_error" error.
type SwitchoverDatabaseNodeServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// FailoverDatabaseNodeClusterNotInitializedResponseBody is the type of the
// "control-plane" service "failover-database-node" endpoint HTTP response body
// for the "cluster_not_initialized" error.
type FailoverDatabaseNodeClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// FailoverDatabaseNodeDatabaseNotModifiableResponseBody is the type of the
// "control-plane" service "failover-database-node" endpoint HTTP response body
// for the "database_not_modifiable" error.
type FailoverDatabaseNodeDatabaseNotModifiableResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// FailoverDatabaseNodeOperationAlreadyInProgressResponseBody is the type of
// the "control-plane" service "failover-database-node" endpoint HTTP response
// body for the "operation_already_in_progress" error.
type FailoverDatabaseNodeOperationAlreadyInProgressResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// FailoverDatabaseNodeInvalidInputResponseBody is the type of the
// "control-plane" service "failover-database-node" endpoint HTTP response body
// for the "invalid_input" error.
type FailoverDatabaseNodeInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// FailoverDatabaseNodeNotFoundResponseBody is the type of the "control-plane"
// service "failover-database-node" endpoint HTTP response body for the
// "not_found" error.
type FailoverDatabaseNodeNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// FailoverDatabaseNodeServerErrorResponseBody is the type of the
// "control-plane" service "failover-database-node" endpoint HTTP response body
// for the "server_error" error.
type FailoverDatabaseNodeServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// ListDatabaseTasksClusterNotInitializedResponseBody is the type of the
// "control-plane" service "list-database-tasks" endpoint HTTP response body
// for the "cluster_not_initialized" error.
type ListDatabaseTasksClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// ListDatabaseTasksInvalidInputResponseBody is the type of the "control-plane"
// service "list-database-tasks" endpoint HTTP response body for the
// "invalid_input" error.
type ListDatabaseTasksInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// ListDatabaseTasksNotFoundResponseBody is the type of the "control-plane"
// service "list-database-tasks" endpoint HTTP response body for the
// "not_found" error.
type ListDatabaseTasksNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// ListDatabaseTasksServerErrorResponseBody is the type of the "control-plane"
// service "list-database-tasks" endpoint HTTP response body for the
// "server_error" error.
type ListDatabaseTasksServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseTaskClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-database-task" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type GetDatabaseTaskClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseTaskInvalidInputResponseBody is the type of the "control-plane"
// service "get-database-task" endpoint HTTP response body for the
// "invalid_input" error.
type GetDatabaseTaskInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseTaskNotFoundResponseBody is the type of the "control-plane"
// service "get-database-task" endpoint HTTP response body for the "not_found"
// error.
type GetDatabaseTaskNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseTaskServerErrorResponseBody is the type of the "control-plane"
// service "get-database-task" endpoint HTTP response body for the
// "server_error" error.
type GetDatabaseTaskServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseTaskLogClusterNotInitializedResponseBody is the type of the
// "control-plane" service "get-database-task-log" endpoint HTTP response body
// for the "cluster_not_initialized" error.
type GetDatabaseTaskLogClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseTaskLogInvalidInputResponseBody is the type of the
// "control-plane" service "get-database-task-log" endpoint HTTP response body
// for the "invalid_input" error.
type GetDatabaseTaskLogInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseTaskLogNotFoundResponseBody is the type of the "control-plane"
// service "get-database-task-log" endpoint HTTP response body for the
// "not_found" error.
type GetDatabaseTaskLogNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetDatabaseTaskLogServerErrorResponseBody is the type of the "control-plane"
// service "get-database-task-log" endpoint HTTP response body for the
// "server_error" error.
type GetDatabaseTaskLogServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestoreDatabaseClusterNotInitializedResponseBody is the type of the
// "control-plane" service "restore-database" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type RestoreDatabaseClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestoreDatabaseDatabaseNotModifiableResponseBody is the type of the
// "control-plane" service "restore-database" endpoint HTTP response body for
// the "database_not_modifiable" error.
type RestoreDatabaseDatabaseNotModifiableResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestoreDatabaseOperationAlreadyInProgressResponseBody is the type of the
// "control-plane" service "restore-database" endpoint HTTP response body for
// the "operation_already_in_progress" error.
type RestoreDatabaseOperationAlreadyInProgressResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestoreDatabaseInvalidInputResponseBody is the type of the "control-plane"
// service "restore-database" endpoint HTTP response body for the
// "invalid_input" error.
type RestoreDatabaseInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestoreDatabaseNotFoundResponseBody is the type of the "control-plane"
// service "restore-database" endpoint HTTP response body for the "not_found"
// error.
type RestoreDatabaseNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestoreDatabaseServerErrorResponseBody is the type of the "control-plane"
// service "restore-database" endpoint HTTP response body for the
// "server_error" error.
type RestoreDatabaseServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// GetVersionServerErrorResponseBody is the type of the "control-plane" service
// "get-version" endpoint HTTP response body for the "server_error" error.
type GetVersionServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestartInstanceClusterNotInitializedResponseBody is the type of the
// "control-plane" service "restart-instance" endpoint HTTP response body for
// the "cluster_not_initialized" error.
type RestartInstanceClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestartInstanceInvalidInputResponseBody is the type of the "control-plane"
// service "restart-instance" endpoint HTTP response body for the
// "invalid_input" error.
type RestartInstanceInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestartInstanceNotFoundResponseBody is the type of the "control-plane"
// service "restart-instance" endpoint HTTP response body for the "not_found"
// error.
type RestartInstanceNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// RestartInstanceServerErrorResponseBody is the type of the "control-plane"
// service "restart-instance" endpoint HTTP response body for the
// "server_error" error.
type RestartInstanceServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// StopInstanceClusterNotInitializedResponseBody is the type of the
// "control-plane" service "stop-instance" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type StopInstanceClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// StopInstanceInvalidInputResponseBody is the type of the "control-plane"
// service "stop-instance" endpoint HTTP response body for the "invalid_input"
// error.
type StopInstanceInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// StopInstanceNotFoundResponseBody is the type of the "control-plane" service
// "stop-instance" endpoint HTTP response body for the "not_found" error.
type StopInstanceNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// StopInstanceServerErrorResponseBody is the type of the "control-plane"
// service "stop-instance" endpoint HTTP response body for the "server_error"
// error.
type StopInstanceServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// StartInstanceClusterNotInitializedResponseBody is the type of the
// "control-plane" service "start-instance" endpoint HTTP response body for the
// "cluster_not_initialized" error.
type StartInstanceClusterNotInitializedResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// StartInstanceInvalidInputResponseBody is the type of the "control-plane"
// service "start-instance" endpoint HTTP response body for the "invalid_input"
// error.
type StartInstanceInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// StartInstanceNotFoundResponseBody is the type of the "control-plane" service
// "start-instance" endpoint HTTP response body for the "not_found" error.
type StartInstanceNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// StartInstanceServerErrorResponseBody is the type of the "control-plane"
// service "start-instance" endpoint HTTP response body for the "server_error"
// error.
type StartInstanceServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// CancelDatabaseTaskNotFoundResponseBody is the type of the "control-plane"
// service "cancel-database-task" endpoint HTTP response body for the
// "not_found" error.
type CancelDatabaseTaskNotFoundResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// CancelDatabaseTaskInvalidInputResponseBody is the type of the
// "control-plane" service "cancel-database-task" endpoint HTTP response body
// for the "invalid_input" error.
type CancelDatabaseTaskInvalidInputResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// CancelDatabaseTaskServerErrorResponseBody is the type of the "control-plane"
// service "cancel-database-task" endpoint HTTP response body for the
// "server_error" error.
type CancelDatabaseTaskServerErrorResponseBody struct {
	// The name of the error.
	Name string `form:"name" json:"name" xml:"name"`
	// The error message.
	Message string `form:"message" json:"message" xml:"message"`
}

// ClusterPeerResponseBody is used to define fields on response body types.
type ClusterPeerResponseBody struct {
	// The name of the Etcd cluster member.
	Name string `form:"name" json:"name" xml:"name"`
	// The Etcd peer endpoint for this cluster member.
	PeerURL string `form:"peer_url" json:"peer_url" xml:"peer_url"`
	// The Etcd client endpoint for this cluster member.
	ClientURL string `form:"client_url" json:"client_url" xml:"client_url"`
}

// ClusterCredentialsResponseBody is used to define fields on response body
// types.
type ClusterCredentialsResponseBody struct {
	// The base64-encoded CA certificate for the cluster.
	CaCert string `form:"ca_cert" json:"ca_cert" xml:"ca_cert"`
	// The base64-encoded etcd client certificate for the new cluster member.
	ClientCert string `form:"client_cert" json:"client_cert" xml:"client_cert"`
	// The base64-encoded etcd client key for the new cluster member.
	ClientKey string `form:"client_key" json:"client_key" xml:"client_key"`
	// The base64-encoded etcd server certificate for the new cluster member.
	ServerCert string `form:"server_cert" json:"server_cert" xml:"server_cert"`
	// The base64-encoded etcd server key for the new cluster member.
	ServerKey string `form:"server_key" json:"server_key" xml:"server_key"`
}

// ClusterStatusResponseBody is used to define fields on response body types.
type ClusterStatusResponseBody struct {
	// The current state of the cluster.
	State string `form:"state" json:"state" xml:"state"`
}

// HostResponseBody is used to define fields on response body types.
type HostResponseBody struct {
	// Unique identifier for the host.
	ID string `form:"id" json:"id" xml:"id"`
	// The orchestrator used by this host.
	Orchestrator string `form:"orchestrator" json:"orchestrator" xml:"orchestrator"`
	// The data directory for the host.
	DataDir string `form:"data_dir" json:"data_dir" xml:"data_dir"`
	// The cohort that this host belongs to.
	Cohort *HostCohortResponseBody `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of this host.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
	// The number of CPUs on this host.
	Cpus *int `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory available on this host.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Current status of the host.
	Status *HostStatusResponseBody `form:"status" json:"status" xml:"status"`
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersionResponseBody `form:"default_pgedge_version,omitempty" json:"default_pgedge_version,omitempty" xml:"default_pgedge_version,omitempty"`
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersionResponseBody `form:"supported_pgedge_versions,omitempty" json:"supported_pgedge_versions,omitempty" xml:"supported_pgedge_versions,omitempty"`
}

// HostCohortResponseBody is used to define fields on response body types.
type HostCohortResponseBody struct {
	// The type of cohort that the host belongs to.
	Type string `form:"type" json:"type" xml:"type"`
	// The cohort ID that the host belongs to.
	CohortID string `form:"cohort_id" json:"cohort_id" xml:"cohort_id"`
	// The member ID of the host within the cohort.
	MemberID string `form:"member_id" json:"member_id" xml:"member_id"`
	// Indicates if the host is a control node in the cohort.
	ControlAvailable bool `form:"control_available" json:"control_available" xml:"control_available"`
}

// HostStatusResponseBody is used to define fields on response body types.
type HostStatusResponseBody struct {
	State string `form:"state" json:"state" xml:"state"`
	// The last time the host status was updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// The status of each component of the host.
	Components map[string]*ComponentStatusResponseBody `form:"components" json:"components" xml:"components"`
}

// ComponentStatusResponseBody is used to define fields on response body types.
type ComponentStatusResponseBody struct {
	// Indicates if the component is healthy.
	Healthy bool `form:"healthy" json:"healthy" xml:"healthy"`
	// Error message from any errors that occurred during the health check.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
	// Additional details about the component.
	Details map[string]any `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
}

// PgEdgeVersionResponseBody is used to define fields on response body types.
type PgEdgeVersionResponseBody struct {
	// The Postgres major and minor version.
	PostgresVersion string `form:"postgres_version" json:"postgres_version" xml:"postgres_version"`
	// The Spock major version.
	SpockVersion string `form:"spock_version" json:"spock_version" xml:"spock_version"`
}

// HostResponse is used to define fields on response body types.
type HostResponse struct {
	// Unique identifier for the host.
	ID string `form:"id" json:"id" xml:"id"`
	// The orchestrator used by this host.
	Orchestrator string `form:"orchestrator" json:"orchestrator" xml:"orchestrator"`
	// The data directory for the host.
	DataDir string `form:"data_dir" json:"data_dir" xml:"data_dir"`
	// The cohort that this host belongs to.
	Cohort *HostCohortResponse `form:"cohort,omitempty" json:"cohort,omitempty" xml:"cohort,omitempty"`
	// The hostname of this host.
	Hostname string `form:"hostname" json:"hostname" xml:"hostname"`
	// The IPv4 address of this host.
	Ipv4Address string `form:"ipv4_address" json:"ipv4_address" xml:"ipv4_address"`
	// The number of CPUs on this host.
	Cpus *int `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory available on this host.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Current status of the host.
	Status *HostStatusResponse `form:"status" json:"status" xml:"status"`
	// The default PgEdge version for this host.
	DefaultPgedgeVersion *PgEdgeVersionResponse `form:"default_pgedge_version,omitempty" json:"default_pgedge_version,omitempty" xml:"default_pgedge_version,omitempty"`
	// The PgEdge versions supported by this host.
	SupportedPgedgeVersions []*PgEdgeVersionResponse `form:"supported_pgedge_versions,omitempty" json:"supported_pgedge_versions,omitempty" xml:"supported_pgedge_versions,omitempty"`
}

// HostCohortResponse is used to define fields on response body types.
type HostCohortResponse struct {
	// The type of cohort that the host belongs to.
	Type string `form:"type" json:"type" xml:"type"`
	// The cohort ID that the host belongs to.
	CohortID string `form:"cohort_id" json:"cohort_id" xml:"cohort_id"`
	// The member ID of the host within the cohort.
	MemberID string `form:"member_id" json:"member_id" xml:"member_id"`
	// Indicates if the host is a control node in the cohort.
	ControlAvailable bool `form:"control_available" json:"control_available" xml:"control_available"`
}

// HostStatusResponse is used to define fields on response body types.
type HostStatusResponse struct {
	State string `form:"state" json:"state" xml:"state"`
	// The last time the host status was updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// The status of each component of the host.
	Components map[string]*ComponentStatusResponse `form:"components" json:"components" xml:"components"`
}

// ComponentStatusResponse is used to define fields on response body types.
type ComponentStatusResponse struct {
	// Indicates if the component is healthy.
	Healthy bool `form:"healthy" json:"healthy" xml:"healthy"`
	// Error message from any errors that occurred during the health check.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
	// Additional details about the component.
	Details map[string]any `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
}

// PgEdgeVersionResponse is used to define fields on response body types.
type PgEdgeVersionResponse struct {
	// The Postgres major and minor version.
	PostgresVersion string `form:"postgres_version" json:"postgres_version" xml:"postgres_version"`
	// The Spock major version.
	SpockVersion string `form:"spock_version" json:"spock_version" xml:"spock_version"`
}

// DatabaseResponseBodyAbbreviatedCollection is used to define fields on
// response body types.
type DatabaseResponseBodyAbbreviatedCollection []*DatabaseResponseBodyAbbreviated

// DatabaseResponseBodyAbbreviated is used to define fields on response body
// types.
type DatabaseResponseBodyAbbreviated struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time that the database was last updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// Current state of the database.
	State string `form:"state" json:"state" xml:"state"`
	// All of the instances in the database.
	Instances InstanceResponseBodyAbbreviatedCollection `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
}

// InstanceResponseBodyAbbreviatedCollection is used to define fields on
// response body types.
type InstanceResponseBodyAbbreviatedCollection []*InstanceResponseBodyAbbreviated

// InstanceResponseBodyAbbreviated is used to define fields on response body
// types.
type InstanceResponseBodyAbbreviated struct {
	// Unique identifier for the instance.
	ID string `form:"id" json:"id" xml:"id"`
	// The ID of the host this instance is running on.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
	// The Spock node name for this instance.
	NodeName string `form:"node_name" json:"node_name" xml:"node_name"`
	State    string `form:"state" json:"state" xml:"state"`
}

// TaskResponseBody is used to define fields on response body types.
type TaskResponseBody struct {
	// The parent task ID of the task.
	ParentID *string `form:"parent_id,omitempty" json:"parent_id,omitempty" xml:"parent_id,omitempty"`
	// The database ID of the task.
	DatabaseID string `form:"database_id" json:"database_id" xml:"database_id"`
	// The name of the node that the task is operating on.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty" xml:"node_name,omitempty"`
	// The ID of the instance that the task is operating on.
	InstanceID *string `form:"instance_id,omitempty" json:"instance_id,omitempty" xml:"instance_id,omitempty"`
	// The ID of the host that the task is running on.
	HostID *string `form:"host_id,omitempty" json:"host_id,omitempty" xml:"host_id,omitempty"`
	// The unique ID of the task.
	TaskID string `form:"task_id" json:"task_id" xml:"task_id"`
	// The time when the task was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time when the task was completed.
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
	// The type of the task.
	Type string `form:"type" json:"type" xml:"type"`
	// The status of the task.
	Status string `form:"status" json:"status" xml:"status"`
	// The error message if the task failed.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// DatabaseResponseBody is used to define fields on response body types.
type DatabaseResponseBody struct {
	// Unique identifier for the database.
	ID string `form:"id" json:"id" xml:"id"`
	// Unique identifier for the databases's owner.
	TenantID *string `form:"tenant_id,omitempty" json:"tenant_id,omitempty" xml:"tenant_id,omitempty"`
	// The time that the database was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time that the database was last updated.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// Current state of the database.
	State string `form:"state" json:"state" xml:"state"`
	// All of the instances in the database.
	Instances InstanceCollectionResponseBody `form:"instances,omitempty" json:"instances,omitempty" xml:"instances,omitempty"`
	// The user-provided specification for the database.
	Spec *DatabaseSpecResponseBody `form:"spec,omitempty" json:"spec,omitempty" xml:"spec,omitempty"`
}

// InstanceCollectionResponseBody is used to define fields on response body
// types.
type InstanceCollectionResponseBody []*InstanceResponseBody

// InstanceResponseBody is used to define fields on response body types.
type InstanceResponseBody struct {
	// Unique identifier for the instance.
	ID string `form:"id" json:"id" xml:"id"`
	// The ID of the host this instance is running on.
	HostID string `form:"host_id" json:"host_id" xml:"host_id"`
	// The Spock node name for this instance.
	NodeName string `form:"node_name" json:"node_name" xml:"node_name"`
	// The time that the instance was created.
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The time that the instance was last modified.
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// The time that the instance status information was last updated.
	StatusUpdatedAt *string `form:"status_updated_at,omitempty" json:"status_updated_at,omitempty" xml:"status_updated_at,omitempty"`
	State           string  `form:"state" json:"state" xml:"state"`
	// Connection information for the instance.
	ConnectionInfo *InstanceConnectionInfoResponseBody `form:"connection_info,omitempty" json:"connection_info,omitempty" xml:"connection_info,omitempty"`
	// Postgres status information for the instance.
	Postgres *InstancePostgresStatusResponseBody `form:"postgres,omitempty" json:"postgres,omitempty" xml:"postgres,omitempty"`
	// Spock status information for the instance.
	Spock *InstanceSpockStatusResponseBody `form:"spock,omitempty" json:"spock,omitempty" xml:"spock,omitempty"`
	// An error message if the instance is in an error state.
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// InstanceConnectionInfoResponseBody is used to define fields on response body
// types.
type InstanceConnectionInfoResponseBody struct {
	// The hostname of the host that's running this instance.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty" xml:"hostname,omitempty"`
	// The IPv4 address of the host that's running this instance.
	Ipv4Address *string `form:"ipv4_address,omitempty" json:"ipv4_address,omitempty" xml:"ipv4_address,omitempty"`
	// The host port that Postgres is listening on for this instance.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
}

// InstancePostgresStatusResponseBody is used to define fields on response body
// types.
type InstancePostgresStatusResponseBody struct {
	// The version of Postgres for this instance.
	Version      *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
	PatroniState *string `form:"patroni_state,omitempty" json:"patroni_state,omitempty" xml:"patroni_state,omitempty"`
	Role         *string `form:"role,omitempty" json:"role,omitempty" xml:"role,omitempty"`
	// True if this instance has a pending restart from a configuration change.
	PendingRestart *bool `form:"pending_restart,omitempty" json:"pending_restart,omitempty" xml:"pending_restart,omitempty"`
	// True if Patroni is paused for this instance.
	PatroniPaused *bool `form:"patroni_paused,omitempty" json:"patroni_paused,omitempty" xml:"patroni_paused,omitempty"`
}

// InstanceSpockStatusResponseBody is used to define fields on response body
// types.
type InstanceSpockStatusResponseBody struct {
	// The current spock.readonly setting.
	ReadOnly *string `form:"read_only,omitempty" json:"read_only,omitempty" xml:"read_only,omitempty"`
	// The version of Spock for this instance.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
	// Status information for this instance's Spock subscriptions.
	Subscriptions []*InstanceSubscriptionResponseBody `form:"subscriptions,omitempty" json:"subscriptions,omitempty" xml:"subscriptions,omitempty"`
}

// InstanceSubscriptionResponseBody is used to define fields on response body
// types.
type InstanceSubscriptionResponseBody struct {
	// The Spock node name of the provider for this subscription.
	ProviderNode string `form:"provider_node" json:"provider_node" xml:"provider_node"`
	// The name of the subscription.
	Name string `form:"name" json:"name" xml:"name"`
	// The current status of the subscription.
	Status string `form:"status" json:"status" xml:"status"`
}

// DatabaseSpecResponseBody is used to define fields on response body types.
type DatabaseSpecResponseBody struct {
	// The name of the Postgres database.
	DatabaseName string `form:"database_name" json:"database_name" xml:"database_name"`
	// The Postgres version in 'major.minor' format.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database. If the port is 0, each instance will
	// be assigned a random port. If the port is unspecified, the database will not
	// be exposed on any port, dependent on orchestrator support for that feature.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit is enforced
	// depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit is enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecResponseBody `form:"nodes" json:"nodes" xml:"nodes"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecResponseBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecResponseBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecResponseBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// Orchestrator-specific configuration options.
	OrchestratorOpts *OrchestratorOptsResponseBody `form:"orchestrator_opts,omitempty" json:"orchestrator_opts,omitempty" xml:"orchestrator_opts,omitempty"`
}

// DatabaseNodeSpecResponseBody is used to define fields on response body types.
type DatabaseNodeSpecResponseBody struct {
	// The name of the database node.
	Name string `form:"name" json:"name" xml:"name"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary, and the others will be read
	// replicas.
	HostIds []string `form:"host_ids" json:"host_ids" xml:"host_ids"`
	// The Postgres version for this node in 'major.minor' format. Overrides the
	// Postgres version set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. It can include the SI suffix 'm', e.g. '500m' for 500
	// millicpus. Cannot allocate units smaller than 1m. Defaults to the number of
	// available CPUs on the host if 0 or unspecified. Cannot allocate more CPUs
	// than are available on the host. Whether this limit is enforced depends on
	// the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit is enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecResponseBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this node. Overrides the restore configuration
	// set in the DatabaseSpec.
	RestoreConfig *RestoreConfigSpecResponseBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Orchestrator-specific configuration options.
	OrchestratorOpts *OrchestratorOptsResponseBody `form:"orchestrator_opts,omitempty" json:"orchestrator_opts,omitempty" xml:"orchestrator_opts,omitempty"`
	// The name of the source node to use for sync. This is typically the node
	// (like 'n1') from which the data will be copied to initialize this new node.
	SourceNode *string `form:"source_node,omitempty" json:"source_node,omitempty" xml:"source_node,omitempty"`
}

// BackupConfigSpecResponseBody is used to define fields on response body types.
type BackupConfigSpecResponseBody struct {
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecResponseBody `form:"repositories" json:"repositories" xml:"repositories"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecResponseBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecResponseBody is used to define fields on response body
// types.
type BackupRepositorySpecResponseBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain. This field will
	// be excluded from the response of all endpoints. It can also be omitted from
	// update requests to keep the current value.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key. This field
	// will be excluded from the response of all endpoints. It can also be omitted
	// from update requests to keep the current value.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile. This field will be
	// excluded from the response of all endpoints. It can also be omitted from
	// update requests to keep the current value.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The Azure storage account access key to use for this repository. This field
	// will be excluded from the response of all endpoints. It can also be omitted
	// from update requests to keep the current value.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecResponseBody is used to define fields on response body
// types.
type BackupScheduleSpecResponseBody struct {
	// The unique identifier for this backup schedule.
	ID string `form:"id" json:"id" xml:"id"`
	// The type of backup to take on this schedule.
	Type string `form:"type" json:"type" xml:"type"`
	// The cron expression for this schedule.
	CronExpression string `form:"cron_expression" json:"cron_expression" xml:"cron_expression"`
}

// RestoreConfigSpecResponseBody is used to define fields on response body
// types.
type RestoreConfigSpecResponseBody struct {
	// The ID of the database to restore this database from.
	SourceDatabaseID string `form:"source_database_id" json:"source_database_id" xml:"source_database_id"`
	// The name of the node to restore this database from.
	SourceNodeName string `form:"source_node_name" json:"source_node_name" xml:"source_node_name"`
	// The name of the database in this repository. The database will be renamed to
	// the database_name in the DatabaseSpec after it's restored.
	SourceDatabaseName string `form:"source_database_name" json:"source_database_name" xml:"source_database_name"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecResponseBody `form:"repository" json:"repository" xml:"repository"`
	// Additional options to use when restoring this database. If omitted, the
	// database will be restored to the latest point in the given repository.
	RestoreOptions map[string]string `form:"restore_options,omitempty" json:"restore_options,omitempty" xml:"restore_options,omitempty"`
}

// RestoreRepositorySpecResponseBody is used to define fields on response body
// types.
type RestoreRepositorySpecResponseBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type string `form:"type" json:"type" xml:"type"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// OrchestratorOptsResponseBody is used to define fields on response body types.
type OrchestratorOptsResponseBody struct {
	// Swarm-specific configuration.
	Swarm *SwarmOptsResponseBody `form:"swarm,omitempty" json:"swarm,omitempty" xml:"swarm,omitempty"`
}

// SwarmOptsResponseBody is used to define fields on response body types.
type SwarmOptsResponseBody struct {
	// A list of extra volumes to mount. Each entry defines a host and container
	// path.
	ExtraVolumes []*ExtraVolumesSpecResponseBody `form:"extra_volumes,omitempty" json:"extra_volumes,omitempty" xml:"extra_volumes,omitempty"`
	// A list of additional Docker Swarm networks to attach containers in this
	// database to.
	ExtraNetworks []*ExtraNetworkSpecResponseBody `form:"extra_networks,omitempty" json:"extra_networks,omitempty" xml:"extra_networks,omitempty"`
	// Arbitrary labels to apply to the Docker Swarm service
	ExtraLabels map[string]string `form:"extra_labels,omitempty" json:"extra_labels,omitempty" xml:"extra_labels,omitempty"`
}

// ExtraVolumesSpecResponseBody is used to define fields on response body types.
type ExtraVolumesSpecResponseBody struct {
	// The host path for the volume.
	HostPath string `form:"host_path" json:"host_path" xml:"host_path"`
	// The path inside the container where the volume will be mounted.
	DestinationPath string `form:"destination_path" json:"destination_path" xml:"destination_path"`
}

// ExtraNetworkSpecResponseBody is used to define fields on response body types.
type ExtraNetworkSpecResponseBody struct {
	// The name or ID of the network to connect to.
	ID string `form:"id" json:"id" xml:"id"`
	// Optional network-scoped aliases for the container.
	Aliases []string `form:"aliases,omitempty" json:"aliases,omitempty" xml:"aliases,omitempty"`
	// Optional driver options for the network connection.
	DriverOpts map[string]string `form:"driver_opts,omitempty" json:"driver_opts,omitempty" xml:"driver_opts,omitempty"`
}

// DatabaseUserSpecResponseBody is used to define fields on response body types.
type DatabaseUserSpecResponseBody struct {
	// The username for this database user.
	Username string `form:"username" json:"username" xml:"username"`
	// The password for this database user. This field will be excluded from the
	// response of all endpoints. It can also be omitted from update requests to
	// keep the current value.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// InstanceResponseBodyCollection is used to define fields on response body
// types.
type InstanceResponseBodyCollection []*InstanceResponseBody

// TaskLogEntryResponseBody is used to define fields on response body types.
type TaskLogEntryResponseBody struct {
	// The timestamp of the log entry.
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
	// The log message.
	Message string `form:"message" json:"message" xml:"message"`
	// Additional fields for the log entry.
	Fields map[string]any `form:"fields,omitempty" json:"fields,omitempty" xml:"fields,omitempty"`
}

// DatabaseSpecRequestBody is used to define fields on request body types.
type DatabaseSpecRequestBody struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The Postgres version in 'major.minor' format.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database. If the port is 0, each instance will
	// be assigned a random port. If the port is unspecified, the database will not
	// be exposed on any port, dependent on orchestrator support for that feature.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit is enforced
	// depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit is enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecRequestBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// Orchestrator-specific configuration options.
	OrchestratorOpts *OrchestratorOptsRequestBody `form:"orchestrator_opts,omitempty" json:"orchestrator_opts,omitempty" xml:"orchestrator_opts,omitempty"`
}

// DatabaseNodeSpecRequestBody is used to define fields on request body types.
type DatabaseNodeSpecRequestBody struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary, and the others will be read
	// replicas.
	HostIds []string `form:"host_ids,omitempty" json:"host_ids,omitempty" xml:"host_ids,omitempty"`
	// The Postgres version for this node in 'major.minor' format. Overrides the
	// Postgres version set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. It can include the SI suffix 'm', e.g. '500m' for 500
	// millicpus. Cannot allocate units smaller than 1m. Defaults to the number of
	// available CPUs on the host if 0 or unspecified. Cannot allocate more CPUs
	// than are available on the host. Whether this limit is enforced depends on
	// the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit is enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this node. Overrides the restore configuration
	// set in the DatabaseSpec.
	RestoreConfig *RestoreConfigSpecRequestBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Orchestrator-specific configuration options.
	OrchestratorOpts *OrchestratorOptsRequestBody `form:"orchestrator_opts,omitempty" json:"orchestrator_opts,omitempty" xml:"orchestrator_opts,omitempty"`
	// The name of the source node to use for sync. This is typically the node
	// (like 'n1') from which the data will be copied to initialize this new node.
	SourceNode *string `form:"source_node,omitempty" json:"source_node,omitempty" xml:"source_node,omitempty"`
}

// BackupConfigSpecRequestBody is used to define fields on request body types.
type BackupConfigSpecRequestBody struct {
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBody is used to define fields on request body
// types.
type BackupRepositorySpecRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain. This field will
	// be excluded from the response of all endpoints. It can also be omitted from
	// update requests to keep the current value.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key. This field
	// will be excluded from the response of all endpoints. It can also be omitted
	// from update requests to keep the current value.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile. This field will be
	// excluded from the response of all endpoints. It can also be omitted from
	// update requests to keep the current value.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The Azure storage account access key to use for this repository. This field
	// will be excluded from the response of all endpoints. It can also be omitted
	// from update requests to keep the current value.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecRequestBody is used to define fields on request body types.
type BackupScheduleSpecRequestBody struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// RestoreConfigSpecRequestBody is used to define fields on request body types.
type RestoreConfigSpecRequestBody struct {
	// The ID of the database to restore this database from.
	SourceDatabaseID *string `form:"source_database_id,omitempty" json:"source_database_id,omitempty" xml:"source_database_id,omitempty"`
	// The name of the node to restore this database from.
	SourceNodeName *string `form:"source_node_name,omitempty" json:"source_node_name,omitempty" xml:"source_node_name,omitempty"`
	// The name of the database in this repository. The database will be renamed to
	// the database_name in the DatabaseSpec after it's restored.
	SourceDatabaseName *string `form:"source_database_name,omitempty" json:"source_database_name,omitempty" xml:"source_database_name,omitempty"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecRequestBody `form:"repository,omitempty" json:"repository,omitempty" xml:"repository,omitempty"`
	// Additional options to use when restoring this database. If omitted, the
	// database will be restored to the latest point in the given repository.
	RestoreOptions map[string]string `form:"restore_options,omitempty" json:"restore_options,omitempty" xml:"restore_options,omitempty"`
}

// RestoreRepositorySpecRequestBody is used to define fields on request body
// types.
type RestoreRepositorySpecRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// OrchestratorOptsRequestBody is used to define fields on request body types.
type OrchestratorOptsRequestBody struct {
	// Swarm-specific configuration.
	Swarm *SwarmOptsRequestBody `form:"swarm,omitempty" json:"swarm,omitempty" xml:"swarm,omitempty"`
}

// SwarmOptsRequestBody is used to define fields on request body types.
type SwarmOptsRequestBody struct {
	// A list of extra volumes to mount. Each entry defines a host and container
	// path.
	ExtraVolumes []*ExtraVolumesSpecRequestBody `form:"extra_volumes,omitempty" json:"extra_volumes,omitempty" xml:"extra_volumes,omitempty"`
	// A list of additional Docker Swarm networks to attach containers in this
	// database to.
	ExtraNetworks []*ExtraNetworkSpecRequestBody `form:"extra_networks,omitempty" json:"extra_networks,omitempty" xml:"extra_networks,omitempty"`
	// Arbitrary labels to apply to the Docker Swarm service
	ExtraLabels map[string]string `form:"extra_labels,omitempty" json:"extra_labels,omitempty" xml:"extra_labels,omitempty"`
}

// ExtraVolumesSpecRequestBody is used to define fields on request body types.
type ExtraVolumesSpecRequestBody struct {
	// The host path for the volume.
	HostPath *string `form:"host_path,omitempty" json:"host_path,omitempty" xml:"host_path,omitempty"`
	// The path inside the container where the volume will be mounted.
	DestinationPath *string `form:"destination_path,omitempty" json:"destination_path,omitempty" xml:"destination_path,omitempty"`
}

// ExtraNetworkSpecRequestBody is used to define fields on request body types.
type ExtraNetworkSpecRequestBody struct {
	// The name or ID of the network to connect to.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Optional network-scoped aliases for the container.
	Aliases []string `form:"aliases,omitempty" json:"aliases,omitempty" xml:"aliases,omitempty"`
	// Optional driver options for the network connection.
	DriverOpts map[string]string `form:"driver_opts,omitempty" json:"driver_opts,omitempty" xml:"driver_opts,omitempty"`
}

// DatabaseUserSpecRequestBody is used to define fields on request body types.
type DatabaseUserSpecRequestBody struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user. This field will be excluded from the
	// response of all endpoints. It can also be omitted from update requests to
	// keep the current value.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// DatabaseSpecRequestBodyRequestBody is used to define fields on request body
// types.
type DatabaseSpecRequestBodyRequestBody struct {
	// The name of the Postgres database.
	DatabaseName *string `form:"database_name,omitempty" json:"database_name,omitempty" xml:"database_name,omitempty"`
	// The Postgres version in 'major.minor' format.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The major version of the Spock extension.
	SpockVersion *string `form:"spock_version,omitempty" json:"spock_version,omitempty" xml:"spock_version,omitempty"`
	// The port used by the Postgres database. If the port is 0, each instance will
	// be assigned a random port. If the port is unspecified, the database will not
	// be exposed on any port, dependent on orchestrator support for that feature.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The number of CPUs to allocate for the database and to use for tuning
	// Postgres. Defaults to the number of available CPUs on the host. Can include
	// an SI suffix, e.g. '500m' for 500 millicpus. Whether this limit is enforced
	// depends on the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database and
	// to use for tuning Postgres. Defaults to the total available memory on the
	// host. Whether this limit is enforced depends on the orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// The Spock nodes for this database.
	Nodes []*DatabaseNodeSpecRequestBodyRequestBody `form:"nodes,omitempty" json:"nodes,omitempty" xml:"nodes,omitempty"`
	// The users to create for this database.
	DatabaseUsers []*DatabaseUserSpecRequestBodyRequestBody `form:"database_users,omitempty" json:"database_users,omitempty" xml:"database_users,omitempty"`
	// The backup configuration for this database.
	BackupConfig *BackupConfigSpecRequestBodyRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this database.
	RestoreConfig *RestoreConfigSpecRequestBodyRequestBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Additional postgresql.conf settings. Will be merged with the settings
	// provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// Orchestrator-specific configuration options.
	OrchestratorOpts *OrchestratorOptsRequestBodyRequestBody `form:"orchestrator_opts,omitempty" json:"orchestrator_opts,omitempty" xml:"orchestrator_opts,omitempty"`
}

// DatabaseNodeSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseNodeSpecRequestBodyRequestBody struct {
	// The name of the database node.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The IDs of the hosts that should run this node. When multiple hosts are
	// specified, one host will chosen as a primary, and the others will be read
	// replicas.
	HostIds []string `form:"host_ids,omitempty" json:"host_ids,omitempty" xml:"host_ids,omitempty"`
	// The Postgres version for this node in 'major.minor' format. Overrides the
	// Postgres version set in the DatabaseSpec.
	PostgresVersion *string `form:"postgres_version,omitempty" json:"postgres_version,omitempty" xml:"postgres_version,omitempty"`
	// The port used by the Postgres database for this node. Overrides the Postgres
	// port set in the DatabaseSpec.
	Port *int `form:"port,omitempty" json:"port,omitempty" xml:"port,omitempty"`
	// The number of CPUs to allocate for the database on this node and to use for
	// tuning Postgres. It can include the SI suffix 'm', e.g. '500m' for 500
	// millicpus. Cannot allocate units smaller than 1m. Defaults to the number of
	// available CPUs on the host if 0 or unspecified. Cannot allocate more CPUs
	// than are available on the host. Whether this limit is enforced depends on
	// the orchestrator.
	Cpus *string `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// The amount of memory in SI or IEC notation to allocate for the database on
	// this node and to use for tuning Postgres. Defaults to the total available
	// memory on the host. Whether this limit is enforced depends on the
	// orchestrator.
	Memory *string `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Additional postgresql.conf settings for this particular node. Will be merged
	// with the settings provided by control-plane.
	PostgresqlConf map[string]any `form:"postgresql_conf,omitempty" json:"postgresql_conf,omitempty" xml:"postgresql_conf,omitempty"`
	// The backup configuration for this node. Overrides the backup configuration
	// set in the DatabaseSpec.
	BackupConfig *BackupConfigSpecRequestBodyRequestBody `form:"backup_config,omitempty" json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	// The restore configuration for this node. Overrides the restore configuration
	// set in the DatabaseSpec.
	RestoreConfig *RestoreConfigSpecRequestBodyRequestBody `form:"restore_config,omitempty" json:"restore_config,omitempty" xml:"restore_config,omitempty"`
	// Orchestrator-specific configuration options.
	OrchestratorOpts *OrchestratorOptsRequestBodyRequestBody `form:"orchestrator_opts,omitempty" json:"orchestrator_opts,omitempty" xml:"orchestrator_opts,omitempty"`
	// The name of the source node to use for sync. This is typically the node
	// (like 'n1') from which the data will be copied to initialize this new node.
	SourceNode *string `form:"source_node,omitempty" json:"source_node,omitempty" xml:"source_node,omitempty"`
}

// BackupConfigSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupConfigSpecRequestBodyRequestBody struct {
	// The repositories for this backup configuration.
	Repositories []*BackupRepositorySpecRequestBodyRequestBody `form:"repositories,omitempty" json:"repositories,omitempty" xml:"repositories,omitempty"`
	// The schedules for this backup configuration.
	Schedules []*BackupScheduleSpecRequestBodyRequestBody `form:"schedules,omitempty" json:"schedules,omitempty" xml:"schedules,omitempty"`
}

// BackupRepositorySpecRequestBodyRequestBody is used to define fields on
// request body types.
type BackupRepositorySpecRequestBodyRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain. This field will
	// be excluded from the response of all endpoints. It can also be omitted from
	// update requests to keep the current value.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key. This field
	// will be excluded from the response of all endpoints. It can also be omitted
	// from update requests to keep the current value.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile. This field will be
	// excluded from the response of all endpoints. It can also be omitted from
	// update requests to keep the current value.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// The Azure storage account access key to use for this repository. This field
	// will be excluded from the response of all endpoints. It can also be omitted
	// from update requests to keep the current value.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The count of full backups to retain or the time to retain full backups.
	RetentionFull *int `form:"retention_full,omitempty" json:"retention_full,omitempty" xml:"retention_full,omitempty"`
	// The type of measure used for retention_full.
	RetentionFullType *string `form:"retention_full_type,omitempty" json:"retention_full_type,omitempty" xml:"retention_full_type,omitempty"`
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// BackupScheduleSpecRequestBodyRequestBody is used to define fields on request
// body types.
type BackupScheduleSpecRequestBodyRequestBody struct {
	// The unique identifier for this backup schedule.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of backup to take on this schedule.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The cron expression for this schedule.
	CronExpression *string `form:"cron_expression,omitempty" json:"cron_expression,omitempty" xml:"cron_expression,omitempty"`
}

// RestoreConfigSpecRequestBodyRequestBody is used to define fields on request
// body types.
type RestoreConfigSpecRequestBodyRequestBody struct {
	// The ID of the database to restore this database from.
	SourceDatabaseID *string `form:"source_database_id,omitempty" json:"source_database_id,omitempty" xml:"source_database_id,omitempty"`
	// The name of the node to restore this database from.
	SourceNodeName *string `form:"source_node_name,omitempty" json:"source_node_name,omitempty" xml:"source_node_name,omitempty"`
	// The name of the database in this repository. The database will be renamed to
	// the database_name in the DatabaseSpec after it's restored.
	SourceDatabaseName *string `form:"source_database_name,omitempty" json:"source_database_name,omitempty" xml:"source_database_name,omitempty"`
	// The repository to restore this database from.
	Repository *RestoreRepositorySpecRequestBodyRequestBody `form:"repository,omitempty" json:"repository,omitempty" xml:"repository,omitempty"`
	// Additional options to use when restoring this database. If omitted, the
	// database will be restored to the latest point in the given repository.
	RestoreOptions map[string]string `form:"restore_options,omitempty" json:"restore_options,omitempty" xml:"restore_options,omitempty"`
}

// RestoreRepositorySpecRequestBodyRequestBody is used to define fields on
// request body types.
type RestoreRepositorySpecRequestBodyRequestBody struct {
	// The unique identifier of this repository.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of this repository.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The S3 bucket name for this repository. Only applies when type = 's3'.
	S3Bucket *string `form:"s3_bucket,omitempty" json:"s3_bucket,omitempty" xml:"s3_bucket,omitempty"`
	// The region of the S3 bucket for this repository. Only applies when type =
	// 's3'.
	S3Region *string `form:"s3_region,omitempty" json:"s3_region,omitempty" xml:"s3_region,omitempty"`
	// The optional S3 endpoint for this repository. Only applies when type = 's3'.
	S3Endpoint *string `form:"s3_endpoint,omitempty" json:"s3_endpoint,omitempty" xml:"s3_endpoint,omitempty"`
	// An optional AWS access key ID to use for this repository. If not provided,
	// pgbackrest will use the default credential provider chain.
	S3Key *string `form:"s3_key,omitempty" json:"s3_key,omitempty" xml:"s3_key,omitempty"`
	// The corresponding secret for the AWS access key ID in s3_key.
	S3KeySecret *string `form:"s3_key_secret,omitempty" json:"s3_key_secret,omitempty" xml:"s3_key_secret,omitempty"`
	// The GCS bucket name for this repository. Only applies when type = 'gcs'.
	GcsBucket *string `form:"gcs_bucket,omitempty" json:"gcs_bucket,omitempty" xml:"gcs_bucket,omitempty"`
	// The optional GCS endpoint for this repository. Only applies when type =
	// 'gcs'.
	GcsEndpoint *string `form:"gcs_endpoint,omitempty" json:"gcs_endpoint,omitempty" xml:"gcs_endpoint,omitempty"`
	// Optional base64-encoded private key data. If omitted, pgbackrest will use
	// the service account attached to the instance profile.
	GcsKey *string `form:"gcs_key,omitempty" json:"gcs_key,omitempty" xml:"gcs_key,omitempty"`
	// The Azure account name for this repository. Only applies when type = 'azure'.
	AzureAccount *string `form:"azure_account,omitempty" json:"azure_account,omitempty" xml:"azure_account,omitempty"`
	// The Azure container name for this repository. Only applies when type =
	// 'azure'.
	AzureContainer *string `form:"azure_container,omitempty" json:"azure_container,omitempty" xml:"azure_container,omitempty"`
	// The optional Azure endpoint for this repository. Only applies when type =
	// 'azure'.
	AzureEndpoint *string `form:"azure_endpoint,omitempty" json:"azure_endpoint,omitempty" xml:"azure_endpoint,omitempty"`
	// An optional Azure storage account access key to use for this repository. If
	// not provided, pgbackrest will use the VM's managed identity.
	AzureKey *string `form:"azure_key,omitempty" json:"azure_key,omitempty" xml:"azure_key,omitempty"`
	// The base path within the repository to store backups. Required for type =
	// 'posix' and 'cifs'.
	BasePath *string `form:"base_path,omitempty" json:"base_path,omitempty" xml:"base_path,omitempty"`
	// Additional options to apply to this repository.
	CustomOptions map[string]string `form:"custom_options,omitempty" json:"custom_options,omitempty" xml:"custom_options,omitempty"`
}

// OrchestratorOptsRequestBodyRequestBody is used to define fields on request
// body types.
type OrchestratorOptsRequestBodyRequestBody struct {
	// Swarm-specific configuration.
	Swarm *SwarmOptsRequestBodyRequestBody `form:"swarm,omitempty" json:"swarm,omitempty" xml:"swarm,omitempty"`
}

// SwarmOptsRequestBodyRequestBody is used to define fields on request body
// types.
type SwarmOptsRequestBodyRequestBody struct {
	// A list of extra volumes to mount. Each entry defines a host and container
	// path.
	ExtraVolumes []*ExtraVolumesSpecRequestBodyRequestBody `form:"extra_volumes,omitempty" json:"extra_volumes,omitempty" xml:"extra_volumes,omitempty"`
	// A list of additional Docker Swarm networks to attach containers in this
	// database to.
	ExtraNetworks []*ExtraNetworkSpecRequestBodyRequestBody `form:"extra_networks,omitempty" json:"extra_networks,omitempty" xml:"extra_networks,omitempty"`
	// Arbitrary labels to apply to the Docker Swarm service
	ExtraLabels map[string]string `form:"extra_labels,omitempty" json:"extra_labels,omitempty" xml:"extra_labels,omitempty"`
}

// ExtraVolumesSpecRequestBodyRequestBody is used to define fields on request
// body types.
type ExtraVolumesSpecRequestBodyRequestBody struct {
	// The host path for the volume.
	HostPath *string `form:"host_path,omitempty" json:"host_path,omitempty" xml:"host_path,omitempty"`
	// The path inside the container where the volume will be mounted.
	DestinationPath *string `form:"destination_path,omitempty" json:"destination_path,omitempty" xml:"destination_path,omitempty"`
}

// ExtraNetworkSpecRequestBodyRequestBody is used to define fields on request
// body types.
type ExtraNetworkSpecRequestBodyRequestBody struct {
	// The name or ID of the network to connect to.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Optional network-scoped aliases for the container.
	Aliases []string `form:"aliases,omitempty" json:"aliases,omitempty" xml:"aliases,omitempty"`
	// Optional driver options for the network connection.
	DriverOpts map[string]string `form:"driver_opts,omitempty" json:"driver_opts,omitempty" xml:"driver_opts,omitempty"`
}

// DatabaseUserSpecRequestBodyRequestBody is used to define fields on request
// body types.
type DatabaseUserSpecRequestBodyRequestBody struct {
	// The username for this database user.
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The password for this database user. This field will be excluded from the
	// response of all endpoints. It can also be omitted from update requests to
	// keep the current value.
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	// If true, this user will be granted database ownership.
	DbOwner *bool `form:"db_owner,omitempty" json:"db_owner,omitempty" xml:"db_owner,omitempty"`
	// The attributes to assign to this database user.
	Attributes []string `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The roles to assign to this database user.
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// NewInitClusterResponseBody builds the HTTP response body from the result of
// the "init-cluster" endpoint of the "control-plane" service.
func NewInitClusterResponseBody(res *controlplane.ClusterJoinToken) *InitClusterResponseBody {
	body := &InitClusterResponseBody{
		Token:     res.Token,
		ServerURL: res.ServerURL,
	}
	return body
}

// NewGetJoinTokenResponseBody builds the HTTP response body from the result of
// the "get-join-token" endpoint of the "control-plane" service.
func NewGetJoinTokenResponseBody(res *controlplane.ClusterJoinToken) *GetJoinTokenResponseBody {
	body := &GetJoinTokenResponseBody{
		Token:     res.Token,
		ServerURL: res.ServerURL,
	}
	return body
}

// NewGetJoinOptionsResponseBody builds the HTTP response body from the result
// of the "get-join-options" endpoint of the "control-plane" service.
func NewGetJoinOptionsResponseBody(res *controlplane.ClusterJoinOptions) *GetJoinOptionsResponseBody {
	body := &GetJoinOptionsResponseBody{}
	if res.Peer != nil {
		body.Peer = marshalControlplaneClusterPeerToClusterPeerResponseBody(res.Peer)
	}
	if res.Credentials != nil {
		body.Credentials = marshalControlplaneClusterCredentialsToClusterCredentialsResponseBody(res.Credentials)
	}
	return body
}

// NewGetClusterResponseBody builds the HTTP response body from the result of
// the "get-cluster" endpoint of the "control-plane" service.
func NewGetClusterResponseBody(res *controlplane.Cluster) *GetClusterResponseBody {
	body := &GetClusterResponseBody{
		ID:       string(res.ID),
		TenantID: string(res.TenantID),
	}
	if res.Status != nil {
		body.Status = marshalControlplaneClusterStatusToClusterStatusResponseBody(res.Status)
	}
	if res.Hosts != nil {
		body.Hosts = make([]*HostResponseBody, len(res.Hosts))
		for i, val := range res.Hosts {
			body.Hosts[i] = marshalControlplaneHostToHostResponseBody(val)
		}
	} else {
		body.Hosts = []*HostResponseBody{}
	}
	return body
}

// NewListHostsResponseBody builds the HTTP response body from the result of
// the "list-hosts" endpoint of the "control-plane" service.
func NewListHostsResponseBody(res []*controlplane.Host) ListHostsResponseBody {
	body := make([]*HostResponse, len(res))
	for i, val := range res {
		body[i] = marshalControlplaneHostToHostResponse(val)
	}
	return body
}

// NewGetHostResponseBody builds the HTTP response body from the result of the
// "get-host" endpoint of the "control-plane" service.
func NewGetHostResponseBody(res *controlplane.Host) *GetHostResponseBody {
	body := &GetHostResponseBody{
		ID:           string(res.ID),
		Orchestrator: res.Orchestrator,
		DataDir:      res.DataDir,
		Hostname:     res.Hostname,
		Ipv4Address:  res.Ipv4Address,
		Cpus:         res.Cpus,
		Memory:       res.Memory,
	}
	if res.Cohort != nil {
		body.Cohort = marshalControlplaneHostCohortToHostCohortResponseBody(res.Cohort)
	}
	if res.Status != nil {
		body.Status = marshalControlplaneHostStatusToHostStatusResponseBody(res.Status)
	}
	if res.DefaultPgedgeVersion != nil {
		body.DefaultPgedgeVersion = marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(res.DefaultPgedgeVersion)
	}
	if res.SupportedPgedgeVersions != nil {
		body.SupportedPgedgeVersions = make([]*PgEdgeVersionResponseBody, len(res.SupportedPgedgeVersions))
		for i, val := range res.SupportedPgedgeVersions {
			body.SupportedPgedgeVersions[i] = marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(val)
		}
	}
	return body
}

// NewListDatabasesResponseBody builds the HTTP response body from the result
// of the "list-databases" endpoint of the "control-plane" service.
func NewListDatabasesResponseBody(res *controlplaneviews.ListDatabasesResponseView) *ListDatabasesResponseBody {
	body := &ListDatabasesResponseBody{}
	if res.Databases != nil {
		body.Databases = make([]*DatabaseResponseBodyAbbreviated, len(res.Databases))
		for i, val := range res.Databases {
			body.Databases[i] = marshalControlplaneviewsDatabaseViewToDatabaseResponseBodyAbbreviated(val)
		}
	}
	return body
}

// NewCreateDatabaseResponseBody builds the HTTP response body from the result
// of the "create-database" endpoint of the "control-plane" service.
func NewCreateDatabaseResponseBody(res *controlplane.CreateDatabaseResponse) *CreateDatabaseResponseBody {
	body := &CreateDatabaseResponseBody{}
	if res.Task != nil {
		body.Task = marshalControlplaneTaskToTaskResponseBody(res.Task)
	}
	if res.Database != nil {
		body.Database = marshalControlplaneDatabaseToDatabaseResponseBody(res.Database)
	}
	return body
}

// NewGetDatabaseResponseBody builds the HTTP response body from the result of
// the "get-database" endpoint of the "control-plane" service.
func NewGetDatabaseResponseBody(res *controlplaneviews.DatabaseView) *GetDatabaseResponseBody {
	body := &GetDatabaseResponseBody{
		ID:        string(*res.ID),
		CreatedAt: *res.CreatedAt,
		UpdatedAt: *res.UpdatedAt,
		State:     *res.State,
	}
	if res.TenantID != nil {
		tenantID := string(*res.TenantID)
		body.TenantID = &tenantID
	}
	if res.Instances != nil {
		body.Instances = make([]*InstanceResponseBody, len(res.Instances))
		for i, val := range res.Instances {
			body.Instances[i] = marshalControlplaneviewsInstanceViewToInstanceResponseBody(val)
		}
	}
	if res.Spec != nil {
		body.Spec = marshalControlplaneviewsDatabaseSpecViewToDatabaseSpecResponseBody(res.Spec)
	}
	return body
}

// NewUpdateDatabaseResponseBody builds the HTTP response body from the result
// of the "update-database" endpoint of the "control-plane" service.
func NewUpdateDatabaseResponseBody(res *controlplane.UpdateDatabaseResponse) *UpdateDatabaseResponseBody {
	body := &UpdateDatabaseResponseBody{}
	if res.Task != nil {
		body.Task = marshalControlplaneTaskToTaskResponseBody(res.Task)
	}
	if res.Database != nil {
		body.Database = marshalControlplaneDatabaseToDatabaseResponseBody(res.Database)
	}
	return body
}

// NewDeleteDatabaseResponseBody builds the HTTP response body from the result
// of the "delete-database" endpoint of the "control-plane" service.
func NewDeleteDatabaseResponseBody(res *controlplane.DeleteDatabaseResponse) *DeleteDatabaseResponseBody {
	body := &DeleteDatabaseResponseBody{}
	if res.Task != nil {
		body.Task = marshalControlplaneTaskToTaskResponseBody(res.Task)
	}
	return body
}

// NewBackupDatabaseNodeResponseBody builds the HTTP response body from the
// result of the "backup-database-node" endpoint of the "control-plane" service.
func NewBackupDatabaseNodeResponseBody(res *controlplane.BackupDatabaseNodeResponse) *BackupDatabaseNodeResponseBody {
	body := &BackupDatabaseNodeResponseBody{}
	if res.Task != nil {
		body.Task = marshalControlplaneTaskToTaskResponseBody(res.Task)
	}
	return body
}

// NewSwitchoverDatabaseNodeResponseBody builds the HTTP response body from the
// result of the "switchover-database-node" endpoint of the "control-plane"
// service.
func NewSwitchoverDatabaseNodeResponseBody(res *controlplane.SwitchoverDatabaseNodeResponse) *SwitchoverDatabaseNodeResponseBody {
	body := &SwitchoverDatabaseNodeResponseBody{}
	if res.Task != nil {
		body.Task = marshalControlplaneTaskToTaskResponseBody(res.Task)
	}
	return body
}

// NewFailoverDatabaseNodeResponseBody builds the HTTP response body from the
// result of the "failover-database-node" endpoint of the "control-plane"
// service.
func NewFailoverDatabaseNodeResponseBody(res *controlplane.FailoverDatabaseNodeResponse) *FailoverDatabaseNodeResponseBody {
	body := &FailoverDatabaseNodeResponseBody{}
	if res.Task != nil {
		body.Task = marshalControlplaneTaskToTaskResponseBody(res.Task)
	}
	return body
}

// NewListDatabaseTasksResponseBody builds the HTTP response body from the
// result of the "list-database-tasks" endpoint of the "control-plane" service.
func NewListDatabaseTasksResponseBody(res *controlplane.ListDatabaseTasksResponse) *ListDatabaseTasksResponseBody {
	body := &ListDatabaseTasksResponseBody{}
	if res.Tasks != nil {
		body.Tasks = make([]*TaskResponseBody, len(res.Tasks))
		for i, val := range res.Tasks {
			body.Tasks[i] = marshalControlplaneTaskToTaskResponseBody(val)
		}
	}
	return body
}

// NewGetDatabaseTaskResponseBody builds the HTTP response body from the result
// of the "get-database-task" endpoint of the "control-plane" service.
func NewGetDatabaseTaskResponseBody(res *controlplane.Task) *GetDatabaseTaskResponseBody {
	body := &GetDatabaseTaskResponseBody{
		ParentID:    res.ParentID,
		DatabaseID:  res.DatabaseID,
		NodeName:    res.NodeName,
		InstanceID:  res.InstanceID,
		HostID:      res.HostID,
		TaskID:      res.TaskID,
		CreatedAt:   res.CreatedAt,
		CompletedAt: res.CompletedAt,
		Type:        res.Type,
		Status:      res.Status,
		Error:       res.Error,
	}
	return body
}

// NewGetDatabaseTaskLogResponseBody builds the HTTP response body from the
// result of the "get-database-task-log" endpoint of the "control-plane"
// service.
func NewGetDatabaseTaskLogResponseBody(res *controlplane.TaskLog) *GetDatabaseTaskLogResponseBody {
	body := &GetDatabaseTaskLogResponseBody{
		DatabaseID:  res.DatabaseID,
		TaskID:      res.TaskID,
		TaskStatus:  res.TaskStatus,
		LastEntryID: res.LastEntryID,
	}
	if res.Entries != nil {
		body.Entries = make([]*TaskLogEntryResponseBody, len(res.Entries))
		for i, val := range res.Entries {
			body.Entries[i] = marshalControlplaneTaskLogEntryToTaskLogEntryResponseBody(val)
		}
	} else {
		body.Entries = []*TaskLogEntryResponseBody{}
	}
	return body
}

// NewRestoreDatabaseResponseBody builds the HTTP response body from the result
// of the "restore-database" endpoint of the "control-plane" service.
func NewRestoreDatabaseResponseBody(res *controlplane.RestoreDatabaseResponse) *RestoreDatabaseResponseBody {
	body := &RestoreDatabaseResponseBody{}
	if res.Task != nil {
		body.Task = marshalControlplaneTaskToTaskResponseBody(res.Task)
	}
	if res.NodeTasks != nil {
		body.NodeTasks = make([]*TaskResponseBody, len(res.NodeTasks))
		for i, val := range res.NodeTasks {
			body.NodeTasks[i] = marshalControlplaneTaskToTaskResponseBody(val)
		}
	} else {
		body.NodeTasks = []*TaskResponseBody{}
	}
	if res.Database != nil {
		body.Database = marshalControlplaneDatabaseToDatabaseResponseBody(res.Database)
	}
	return body
}

// NewGetVersionResponseBody builds the HTTP response body from the result of
// the "get-version" endpoint of the "control-plane" service.
func NewGetVersionResponseBody(res *controlplane.VersionInfo) *GetVersionResponseBody {
	body := &GetVersionResponseBody{
		Version:      res.Version,
		Revision:     res.Revision,
		RevisionTime: res.RevisionTime,
		Arch:         res.Arch,
	}
	return body
}

// NewRestartInstanceResponseBody builds the HTTP response body from the result
// of the "restart-instance" endpoint of the "control-plane" service.
func NewRestartInstanceResponseBody(res *controlplane.Task) *RestartInstanceResponseBody {
	body := &RestartInstanceResponseBody{
		ParentID:    res.ParentID,
		DatabaseID:  res.DatabaseID,
		NodeName:    res.NodeName,
		InstanceID:  res.InstanceID,
		HostID:      res.HostID,
		TaskID:      res.TaskID,
		CreatedAt:   res.CreatedAt,
		CompletedAt: res.CompletedAt,
		Type:        res.Type,
		Status:      res.Status,
		Error:       res.Error,
	}
	return body
}

// NewStopInstanceResponseBody builds the HTTP response body from the result of
// the "stop-instance" endpoint of the "control-plane" service.
func NewStopInstanceResponseBody(res *controlplane.Task) *StopInstanceResponseBody {
	body := &StopInstanceResponseBody{
		ParentID:    res.ParentID,
		DatabaseID:  res.DatabaseID,
		NodeName:    res.NodeName,
		InstanceID:  res.InstanceID,
		HostID:      res.HostID,
		TaskID:      res.TaskID,
		CreatedAt:   res.CreatedAt,
		CompletedAt: res.CompletedAt,
		Type:        res.Type,
		Status:      res.Status,
		Error:       res.Error,
	}
	return body
}

// NewStartInstanceResponseBody builds the HTTP response body from the result
// of the "start-instance" endpoint of the "control-plane" service.
func NewStartInstanceResponseBody(res *controlplane.Task) *StartInstanceResponseBody {
	body := &StartInstanceResponseBody{
		ParentID:    res.ParentID,
		DatabaseID:  res.DatabaseID,
		NodeName:    res.NodeName,
		InstanceID:  res.InstanceID,
		HostID:      res.HostID,
		TaskID:      res.TaskID,
		CreatedAt:   res.CreatedAt,
		CompletedAt: res.CompletedAt,
		Type:        res.Type,
		Status:      res.Status,
		Error:       res.Error,
	}
	return body
}

// NewCancelDatabaseTaskResponseBody builds the HTTP response body from the
// result of the "cancel-database-task" endpoint of the "control-plane" service.
func NewCancelDatabaseTaskResponseBody(res *controlplane.Task) *CancelDatabaseTaskResponseBody {
	body := &CancelDatabaseTaskResponseBody{
		ParentID:    res.ParentID,
		DatabaseID:  res.DatabaseID,
		NodeName:    res.NodeName,
		InstanceID:  res.InstanceID,
		HostID:      res.HostID,
		TaskID:      res.TaskID,
		CreatedAt:   res.CreatedAt,
		CompletedAt: res.CompletedAt,
		Type:        res.Type,
		Status:      res.Status,
		Error:       res.Error,
	}
	return body
}

// NewInitClusterClusterAlreadyInitializedResponseBody builds the HTTP response
// body from the result of the "init-cluster" endpoint of the "control-plane"
// service.
func NewInitClusterClusterAlreadyInitializedResponseBody(res *controlplane.APIError) *InitClusterClusterAlreadyInitializedResponseBody {
	body := &InitClusterClusterAlreadyInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewInitClusterServerErrorResponseBody builds the HTTP response body from the
// result of the "init-cluster" endpoint of the "control-plane" service.
func NewInitClusterServerErrorResponseBody(res *controlplane.APIError) *InitClusterServerErrorResponseBody {
	body := &InitClusterServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewJoinClusterClusterAlreadyInitializedResponseBody builds the HTTP response
// body from the result of the "join-cluster" endpoint of the "control-plane"
// service.
func NewJoinClusterClusterAlreadyInitializedResponseBody(res *controlplane.APIError) *JoinClusterClusterAlreadyInitializedResponseBody {
	body := &JoinClusterClusterAlreadyInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewJoinClusterInvalidJoinTokenResponseBody builds the HTTP response body
// from the result of the "join-cluster" endpoint of the "control-plane"
// service.
func NewJoinClusterInvalidJoinTokenResponseBody(res *controlplane.APIError) *JoinClusterInvalidJoinTokenResponseBody {
	body := &JoinClusterInvalidJoinTokenResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewJoinClusterServerErrorResponseBody builds the HTTP response body from the
// result of the "join-cluster" endpoint of the "control-plane" service.
func NewJoinClusterServerErrorResponseBody(res *controlplane.APIError) *JoinClusterServerErrorResponseBody {
	body := &JoinClusterServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetJoinTokenClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "get-join-token" endpoint of the "control-plane"
// service.
func NewGetJoinTokenClusterNotInitializedResponseBody(res *controlplane.APIError) *GetJoinTokenClusterNotInitializedResponseBody {
	body := &GetJoinTokenClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetJoinTokenServerErrorResponseBody builds the HTTP response body from
// the result of the "get-join-token" endpoint of the "control-plane" service.
func NewGetJoinTokenServerErrorResponseBody(res *controlplane.APIError) *GetJoinTokenServerErrorResponseBody {
	body := &GetJoinTokenServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetJoinOptionsClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "get-join-options" endpoint of the
// "control-plane" service.
func NewGetJoinOptionsClusterNotInitializedResponseBody(res *controlplane.APIError) *GetJoinOptionsClusterNotInitializedResponseBody {
	body := &GetJoinOptionsClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetJoinOptionsInvalidJoinTokenResponseBody builds the HTTP response body
// from the result of the "get-join-options" endpoint of the "control-plane"
// service.
func NewGetJoinOptionsInvalidJoinTokenResponseBody(res *controlplane.APIError) *GetJoinOptionsInvalidJoinTokenResponseBody {
	body := &GetJoinOptionsInvalidJoinTokenResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetJoinOptionsServerErrorResponseBody builds the HTTP response body from
// the result of the "get-join-options" endpoint of the "control-plane" service.
func NewGetJoinOptionsServerErrorResponseBody(res *controlplane.APIError) *GetJoinOptionsServerErrorResponseBody {
	body := &GetJoinOptionsServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetClusterClusterNotInitializedResponseBody builds the HTTP response body
// from the result of the "get-cluster" endpoint of the "control-plane" service.
func NewGetClusterClusterNotInitializedResponseBody(res *controlplane.APIError) *GetClusterClusterNotInitializedResponseBody {
	body := &GetClusterClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetClusterServerErrorResponseBody builds the HTTP response body from the
// result of the "get-cluster" endpoint of the "control-plane" service.
func NewGetClusterServerErrorResponseBody(res *controlplane.APIError) *GetClusterServerErrorResponseBody {
	body := &GetClusterServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewListHostsClusterNotInitializedResponseBody builds the HTTP response body
// from the result of the "list-hosts" endpoint of the "control-plane" service.
func NewListHostsClusterNotInitializedResponseBody(res *controlplane.APIError) *ListHostsClusterNotInitializedResponseBody {
	body := &ListHostsClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewListHostsServerErrorResponseBody builds the HTTP response body from the
// result of the "list-hosts" endpoint of the "control-plane" service.
func NewListHostsServerErrorResponseBody(res *controlplane.APIError) *ListHostsServerErrorResponseBody {
	body := &ListHostsServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetHostClusterNotInitializedResponseBody builds the HTTP response body
// from the result of the "get-host" endpoint of the "control-plane" service.
func NewGetHostClusterNotInitializedResponseBody(res *controlplane.APIError) *GetHostClusterNotInitializedResponseBody {
	body := &GetHostClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetHostInvalidInputResponseBody builds the HTTP response body from the
// result of the "get-host" endpoint of the "control-plane" service.
func NewGetHostInvalidInputResponseBody(res *controlplane.APIError) *GetHostInvalidInputResponseBody {
	body := &GetHostInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetHostNotFoundResponseBody builds the HTTP response body from the result
// of the "get-host" endpoint of the "control-plane" service.
func NewGetHostNotFoundResponseBody(res *controlplane.APIError) *GetHostNotFoundResponseBody {
	body := &GetHostNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetHostServerErrorResponseBody builds the HTTP response body from the
// result of the "get-host" endpoint of the "control-plane" service.
func NewGetHostServerErrorResponseBody(res *controlplane.APIError) *GetHostServerErrorResponseBody {
	body := &GetHostServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRemoveHostClusterNotInitializedResponseBody builds the HTTP response body
// from the result of the "remove-host" endpoint of the "control-plane" service.
func NewRemoveHostClusterNotInitializedResponseBody(res *controlplane.APIError) *RemoveHostClusterNotInitializedResponseBody {
	body := &RemoveHostClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRemoveHostInvalidInputResponseBody builds the HTTP response body from the
// result of the "remove-host" endpoint of the "control-plane" service.
func NewRemoveHostInvalidInputResponseBody(res *controlplane.APIError) *RemoveHostInvalidInputResponseBody {
	body := &RemoveHostInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRemoveHostNotFoundResponseBody builds the HTTP response body from the
// result of the "remove-host" endpoint of the "control-plane" service.
func NewRemoveHostNotFoundResponseBody(res *controlplane.APIError) *RemoveHostNotFoundResponseBody {
	body := &RemoveHostNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRemoveHostServerErrorResponseBody builds the HTTP response body from the
// result of the "remove-host" endpoint of the "control-plane" service.
func NewRemoveHostServerErrorResponseBody(res *controlplane.APIError) *RemoveHostServerErrorResponseBody {
	body := &RemoveHostServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewListDatabasesClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "list-databases" endpoint of the "control-plane"
// service.
func NewListDatabasesClusterNotInitializedResponseBody(res *controlplane.APIError) *ListDatabasesClusterNotInitializedResponseBody {
	body := &ListDatabasesClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewListDatabasesServerErrorResponseBody builds the HTTP response body from
// the result of the "list-databases" endpoint of the "control-plane" service.
func NewListDatabasesServerErrorResponseBody(res *controlplane.APIError) *ListDatabasesServerErrorResponseBody {
	body := &ListDatabasesServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewCreateDatabaseDatabaseAlreadyExistsResponseBody builds the HTTP response
// body from the result of the "create-database" endpoint of the
// "control-plane" service.
func NewCreateDatabaseDatabaseAlreadyExistsResponseBody(res *controlplane.APIError) *CreateDatabaseDatabaseAlreadyExistsResponseBody {
	body := &CreateDatabaseDatabaseAlreadyExistsResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewCreateDatabaseClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "create-database" endpoint of the
// "control-plane" service.
func NewCreateDatabaseClusterNotInitializedResponseBody(res *controlplane.APIError) *CreateDatabaseClusterNotInitializedResponseBody {
	body := &CreateDatabaseClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewCreateDatabaseOperationAlreadyInProgressResponseBody builds the HTTP
// response body from the result of the "create-database" endpoint of the
// "control-plane" service.
func NewCreateDatabaseOperationAlreadyInProgressResponseBody(res *controlplane.APIError) *CreateDatabaseOperationAlreadyInProgressResponseBody {
	body := &CreateDatabaseOperationAlreadyInProgressResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewCreateDatabaseInvalidInputResponseBody builds the HTTP response body from
// the result of the "create-database" endpoint of the "control-plane" service.
func NewCreateDatabaseInvalidInputResponseBody(res *controlplane.APIError) *CreateDatabaseInvalidInputResponseBody {
	body := &CreateDatabaseInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewCreateDatabaseServerErrorResponseBody builds the HTTP response body from
// the result of the "create-database" endpoint of the "control-plane" service.
func NewCreateDatabaseServerErrorResponseBody(res *controlplane.APIError) *CreateDatabaseServerErrorResponseBody {
	body := &CreateDatabaseServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "get-database" endpoint of the "control-plane"
// service.
func NewGetDatabaseClusterNotInitializedResponseBody(res *controlplane.APIError) *GetDatabaseClusterNotInitializedResponseBody {
	body := &GetDatabaseClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseInvalidInputResponseBody builds the HTTP response body from
// the result of the "get-database" endpoint of the "control-plane" service.
func NewGetDatabaseInvalidInputResponseBody(res *controlplane.APIError) *GetDatabaseInvalidInputResponseBody {
	body := &GetDatabaseInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseNotFoundResponseBody builds the HTTP response body from the
// result of the "get-database" endpoint of the "control-plane" service.
func NewGetDatabaseNotFoundResponseBody(res *controlplane.APIError) *GetDatabaseNotFoundResponseBody {
	body := &GetDatabaseNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseServerErrorResponseBody builds the HTTP response body from the
// result of the "get-database" endpoint of the "control-plane" service.
func NewGetDatabaseServerErrorResponseBody(res *controlplane.APIError) *GetDatabaseServerErrorResponseBody {
	body := &GetDatabaseServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewUpdateDatabaseClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "update-database" endpoint of the
// "control-plane" service.
func NewUpdateDatabaseClusterNotInitializedResponseBody(res *controlplane.APIError) *UpdateDatabaseClusterNotInitializedResponseBody {
	body := &UpdateDatabaseClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewUpdateDatabaseDatabaseNotModifiableResponseBody builds the HTTP response
// body from the result of the "update-database" endpoint of the
// "control-plane" service.
func NewUpdateDatabaseDatabaseNotModifiableResponseBody(res *controlplane.APIError) *UpdateDatabaseDatabaseNotModifiableResponseBody {
	body := &UpdateDatabaseDatabaseNotModifiableResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewUpdateDatabaseOperationAlreadyInProgressResponseBody builds the HTTP
// response body from the result of the "update-database" endpoint of the
// "control-plane" service.
func NewUpdateDatabaseOperationAlreadyInProgressResponseBody(res *controlplane.APIError) *UpdateDatabaseOperationAlreadyInProgressResponseBody {
	body := &UpdateDatabaseOperationAlreadyInProgressResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewUpdateDatabaseInvalidInputResponseBody builds the HTTP response body from
// the result of the "update-database" endpoint of the "control-plane" service.
func NewUpdateDatabaseInvalidInputResponseBody(res *controlplane.APIError) *UpdateDatabaseInvalidInputResponseBody {
	body := &UpdateDatabaseInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewUpdateDatabaseNotFoundResponseBody builds the HTTP response body from the
// result of the "update-database" endpoint of the "control-plane" service.
func NewUpdateDatabaseNotFoundResponseBody(res *controlplane.APIError) *UpdateDatabaseNotFoundResponseBody {
	body := &UpdateDatabaseNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewUpdateDatabaseServerErrorResponseBody builds the HTTP response body from
// the result of the "update-database" endpoint of the "control-plane" service.
func NewUpdateDatabaseServerErrorResponseBody(res *controlplane.APIError) *UpdateDatabaseServerErrorResponseBody {
	body := &UpdateDatabaseServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewDeleteDatabaseClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "delete-database" endpoint of the
// "control-plane" service.
func NewDeleteDatabaseClusterNotInitializedResponseBody(res *controlplane.APIError) *DeleteDatabaseClusterNotInitializedResponseBody {
	body := &DeleteDatabaseClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewDeleteDatabaseDatabaseNotModifiableResponseBody builds the HTTP response
// body from the result of the "delete-database" endpoint of the
// "control-plane" service.
func NewDeleteDatabaseDatabaseNotModifiableResponseBody(res *controlplane.APIError) *DeleteDatabaseDatabaseNotModifiableResponseBody {
	body := &DeleteDatabaseDatabaseNotModifiableResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewDeleteDatabaseOperationAlreadyInProgressResponseBody builds the HTTP
// response body from the result of the "delete-database" endpoint of the
// "control-plane" service.
func NewDeleteDatabaseOperationAlreadyInProgressResponseBody(res *controlplane.APIError) *DeleteDatabaseOperationAlreadyInProgressResponseBody {
	body := &DeleteDatabaseOperationAlreadyInProgressResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewDeleteDatabaseInvalidInputResponseBody builds the HTTP response body from
// the result of the "delete-database" endpoint of the "control-plane" service.
func NewDeleteDatabaseInvalidInputResponseBody(res *controlplane.APIError) *DeleteDatabaseInvalidInputResponseBody {
	body := &DeleteDatabaseInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewDeleteDatabaseNotFoundResponseBody builds the HTTP response body from the
// result of the "delete-database" endpoint of the "control-plane" service.
func NewDeleteDatabaseNotFoundResponseBody(res *controlplane.APIError) *DeleteDatabaseNotFoundResponseBody {
	body := &DeleteDatabaseNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewDeleteDatabaseServerErrorResponseBody builds the HTTP response body from
// the result of the "delete-database" endpoint of the "control-plane" service.
func NewDeleteDatabaseServerErrorResponseBody(res *controlplane.APIError) *DeleteDatabaseServerErrorResponseBody {
	body := &DeleteDatabaseServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewBackupDatabaseNodeClusterNotInitializedResponseBody builds the HTTP
// response body from the result of the "backup-database-node" endpoint of the
// "control-plane" service.
func NewBackupDatabaseNodeClusterNotInitializedResponseBody(res *controlplane.APIError) *BackupDatabaseNodeClusterNotInitializedResponseBody {
	body := &BackupDatabaseNodeClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewBackupDatabaseNodeDatabaseNotModifiableResponseBody builds the HTTP
// response body from the result of the "backup-database-node" endpoint of the
// "control-plane" service.
func NewBackupDatabaseNodeDatabaseNotModifiableResponseBody(res *controlplane.APIError) *BackupDatabaseNodeDatabaseNotModifiableResponseBody {
	body := &BackupDatabaseNodeDatabaseNotModifiableResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewBackupDatabaseNodeOperationAlreadyInProgressResponseBody builds the HTTP
// response body from the result of the "backup-database-node" endpoint of the
// "control-plane" service.
func NewBackupDatabaseNodeOperationAlreadyInProgressResponseBody(res *controlplane.APIError) *BackupDatabaseNodeOperationAlreadyInProgressResponseBody {
	body := &BackupDatabaseNodeOperationAlreadyInProgressResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewBackupDatabaseNodeInvalidInputResponseBody builds the HTTP response body
// from the result of the "backup-database-node" endpoint of the
// "control-plane" service.
func NewBackupDatabaseNodeInvalidInputResponseBody(res *controlplane.APIError) *BackupDatabaseNodeInvalidInputResponseBody {
	body := &BackupDatabaseNodeInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewBackupDatabaseNodeNotFoundResponseBody builds the HTTP response body from
// the result of the "backup-database-node" endpoint of the "control-plane"
// service.
func NewBackupDatabaseNodeNotFoundResponseBody(res *controlplane.APIError) *BackupDatabaseNodeNotFoundResponseBody {
	body := &BackupDatabaseNodeNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewBackupDatabaseNodeServerErrorResponseBody builds the HTTP response body
// from the result of the "backup-database-node" endpoint of the
// "control-plane" service.
func NewBackupDatabaseNodeServerErrorResponseBody(res *controlplane.APIError) *BackupDatabaseNodeServerErrorResponseBody {
	body := &BackupDatabaseNodeServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewSwitchoverDatabaseNodeClusterNotInitializedResponseBody builds the HTTP
// response body from the result of the "switchover-database-node" endpoint of
// the "control-plane" service.
func NewSwitchoverDatabaseNodeClusterNotInitializedResponseBody(res *controlplane.APIError) *SwitchoverDatabaseNodeClusterNotInitializedResponseBody {
	body := &SwitchoverDatabaseNodeClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewSwitchoverDatabaseNodeDatabaseNotModifiableResponseBody builds the HTTP
// response body from the result of the "switchover-database-node" endpoint of
// the "control-plane" service.
func NewSwitchoverDatabaseNodeDatabaseNotModifiableResponseBody(res *controlplane.APIError) *SwitchoverDatabaseNodeDatabaseNotModifiableResponseBody {
	body := &SwitchoverDatabaseNodeDatabaseNotModifiableResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewSwitchoverDatabaseNodeOperationAlreadyInProgressResponseBody builds the
// HTTP response body from the result of the "switchover-database-node"
// endpoint of the "control-plane" service.
func NewSwitchoverDatabaseNodeOperationAlreadyInProgressResponseBody(res *controlplane.APIError) *SwitchoverDatabaseNodeOperationAlreadyInProgressResponseBody {
	body := &SwitchoverDatabaseNodeOperationAlreadyInProgressResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewSwitchoverDatabaseNodeInvalidInputResponseBody builds the HTTP response
// body from the result of the "switchover-database-node" endpoint of the
// "control-plane" service.
func NewSwitchoverDatabaseNodeInvalidInputResponseBody(res *controlplane.APIError) *SwitchoverDatabaseNodeInvalidInputResponseBody {
	body := &SwitchoverDatabaseNodeInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewSwitchoverDatabaseNodeNotFoundResponseBody builds the HTTP response body
// from the result of the "switchover-database-node" endpoint of the
// "control-plane" service.
func NewSwitchoverDatabaseNodeNotFoundResponseBody(res *controlplane.APIError) *SwitchoverDatabaseNodeNotFoundResponseBody {
	body := &SwitchoverDatabaseNodeNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewSwitchoverDatabaseNodeServerErrorResponseBody builds the HTTP response
// body from the result of the "switchover-database-node" endpoint of the
// "control-plane" service.
func NewSwitchoverDatabaseNodeServerErrorResponseBody(res *controlplane.APIError) *SwitchoverDatabaseNodeServerErrorResponseBody {
	body := &SwitchoverDatabaseNodeServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewFailoverDatabaseNodeClusterNotInitializedResponseBody builds the HTTP
// response body from the result of the "failover-database-node" endpoint of
// the "control-plane" service.
func NewFailoverDatabaseNodeClusterNotInitializedResponseBody(res *controlplane.APIError) *FailoverDatabaseNodeClusterNotInitializedResponseBody {
	body := &FailoverDatabaseNodeClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewFailoverDatabaseNodeDatabaseNotModifiableResponseBody builds the HTTP
// response body from the result of the "failover-database-node" endpoint of
// the "control-plane" service.
func NewFailoverDatabaseNodeDatabaseNotModifiableResponseBody(res *controlplane.APIError) *FailoverDatabaseNodeDatabaseNotModifiableResponseBody {
	body := &FailoverDatabaseNodeDatabaseNotModifiableResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewFailoverDatabaseNodeOperationAlreadyInProgressResponseBody builds the
// HTTP response body from the result of the "failover-database-node" endpoint
// of the "control-plane" service.
func NewFailoverDatabaseNodeOperationAlreadyInProgressResponseBody(res *controlplane.APIError) *FailoverDatabaseNodeOperationAlreadyInProgressResponseBody {
	body := &FailoverDatabaseNodeOperationAlreadyInProgressResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewFailoverDatabaseNodeInvalidInputResponseBody builds the HTTP response
// body from the result of the "failover-database-node" endpoint of the
// "control-plane" service.
func NewFailoverDatabaseNodeInvalidInputResponseBody(res *controlplane.APIError) *FailoverDatabaseNodeInvalidInputResponseBody {
	body := &FailoverDatabaseNodeInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewFailoverDatabaseNodeNotFoundResponseBody builds the HTTP response body
// from the result of the "failover-database-node" endpoint of the
// "control-plane" service.
func NewFailoverDatabaseNodeNotFoundResponseBody(res *controlplane.APIError) *FailoverDatabaseNodeNotFoundResponseBody {
	body := &FailoverDatabaseNodeNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewFailoverDatabaseNodeServerErrorResponseBody builds the HTTP response body
// from the result of the "failover-database-node" endpoint of the
// "control-plane" service.
func NewFailoverDatabaseNodeServerErrorResponseBody(res *controlplane.APIError) *FailoverDatabaseNodeServerErrorResponseBody {
	body := &FailoverDatabaseNodeServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewListDatabaseTasksClusterNotInitializedResponseBody builds the HTTP
// response body from the result of the "list-database-tasks" endpoint of the
// "control-plane" service.
func NewListDatabaseTasksClusterNotInitializedResponseBody(res *controlplane.APIError) *ListDatabaseTasksClusterNotInitializedResponseBody {
	body := &ListDatabaseTasksClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewListDatabaseTasksInvalidInputResponseBody builds the HTTP response body
// from the result of the "list-database-tasks" endpoint of the "control-plane"
// service.
func NewListDatabaseTasksInvalidInputResponseBody(res *controlplane.APIError) *ListDatabaseTasksInvalidInputResponseBody {
	body := &ListDatabaseTasksInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewListDatabaseTasksNotFoundResponseBody builds the HTTP response body from
// the result of the "list-database-tasks" endpoint of the "control-plane"
// service.
func NewListDatabaseTasksNotFoundResponseBody(res *controlplane.APIError) *ListDatabaseTasksNotFoundResponseBody {
	body := &ListDatabaseTasksNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewListDatabaseTasksServerErrorResponseBody builds the HTTP response body
// from the result of the "list-database-tasks" endpoint of the "control-plane"
// service.
func NewListDatabaseTasksServerErrorResponseBody(res *controlplane.APIError) *ListDatabaseTasksServerErrorResponseBody {
	body := &ListDatabaseTasksServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseTaskClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "get-database-task" endpoint of the
// "control-plane" service.
func NewGetDatabaseTaskClusterNotInitializedResponseBody(res *controlplane.APIError) *GetDatabaseTaskClusterNotInitializedResponseBody {
	body := &GetDatabaseTaskClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseTaskInvalidInputResponseBody builds the HTTP response body
// from the result of the "get-database-task" endpoint of the "control-plane"
// service.
func NewGetDatabaseTaskInvalidInputResponseBody(res *controlplane.APIError) *GetDatabaseTaskInvalidInputResponseBody {
	body := &GetDatabaseTaskInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseTaskNotFoundResponseBody builds the HTTP response body from
// the result of the "get-database-task" endpoint of the "control-plane"
// service.
func NewGetDatabaseTaskNotFoundResponseBody(res *controlplane.APIError) *GetDatabaseTaskNotFoundResponseBody {
	body := &GetDatabaseTaskNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseTaskServerErrorResponseBody builds the HTTP response body from
// the result of the "get-database-task" endpoint of the "control-plane"
// service.
func NewGetDatabaseTaskServerErrorResponseBody(res *controlplane.APIError) *GetDatabaseTaskServerErrorResponseBody {
	body := &GetDatabaseTaskServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseTaskLogClusterNotInitializedResponseBody builds the HTTP
// response body from the result of the "get-database-task-log" endpoint of the
// "control-plane" service.
func NewGetDatabaseTaskLogClusterNotInitializedResponseBody(res *controlplane.APIError) *GetDatabaseTaskLogClusterNotInitializedResponseBody {
	body := &GetDatabaseTaskLogClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseTaskLogInvalidInputResponseBody builds the HTTP response body
// from the result of the "get-database-task-log" endpoint of the
// "control-plane" service.
func NewGetDatabaseTaskLogInvalidInputResponseBody(res *controlplane.APIError) *GetDatabaseTaskLogInvalidInputResponseBody {
	body := &GetDatabaseTaskLogInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseTaskLogNotFoundResponseBody builds the HTTP response body from
// the result of the "get-database-task-log" endpoint of the "control-plane"
// service.
func NewGetDatabaseTaskLogNotFoundResponseBody(res *controlplane.APIError) *GetDatabaseTaskLogNotFoundResponseBody {
	body := &GetDatabaseTaskLogNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetDatabaseTaskLogServerErrorResponseBody builds the HTTP response body
// from the result of the "get-database-task-log" endpoint of the
// "control-plane" service.
func NewGetDatabaseTaskLogServerErrorResponseBody(res *controlplane.APIError) *GetDatabaseTaskLogServerErrorResponseBody {
	body := &GetDatabaseTaskLogServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestoreDatabaseClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "restore-database" endpoint of the
// "control-plane" service.
func NewRestoreDatabaseClusterNotInitializedResponseBody(res *controlplane.APIError) *RestoreDatabaseClusterNotInitializedResponseBody {
	body := &RestoreDatabaseClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestoreDatabaseDatabaseNotModifiableResponseBody builds the HTTP response
// body from the result of the "restore-database" endpoint of the
// "control-plane" service.
func NewRestoreDatabaseDatabaseNotModifiableResponseBody(res *controlplane.APIError) *RestoreDatabaseDatabaseNotModifiableResponseBody {
	body := &RestoreDatabaseDatabaseNotModifiableResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestoreDatabaseOperationAlreadyInProgressResponseBody builds the HTTP
// response body from the result of the "restore-database" endpoint of the
// "control-plane" service.
func NewRestoreDatabaseOperationAlreadyInProgressResponseBody(res *controlplane.APIError) *RestoreDatabaseOperationAlreadyInProgressResponseBody {
	body := &RestoreDatabaseOperationAlreadyInProgressResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestoreDatabaseInvalidInputResponseBody builds the HTTP response body
// from the result of the "restore-database" endpoint of the "control-plane"
// service.
func NewRestoreDatabaseInvalidInputResponseBody(res *controlplane.APIError) *RestoreDatabaseInvalidInputResponseBody {
	body := &RestoreDatabaseInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestoreDatabaseNotFoundResponseBody builds the HTTP response body from
// the result of the "restore-database" endpoint of the "control-plane" service.
func NewRestoreDatabaseNotFoundResponseBody(res *controlplane.APIError) *RestoreDatabaseNotFoundResponseBody {
	body := &RestoreDatabaseNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestoreDatabaseServerErrorResponseBody builds the HTTP response body from
// the result of the "restore-database" endpoint of the "control-plane" service.
func NewRestoreDatabaseServerErrorResponseBody(res *controlplane.APIError) *RestoreDatabaseServerErrorResponseBody {
	body := &RestoreDatabaseServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewGetVersionServerErrorResponseBody builds the HTTP response body from the
// result of the "get-version" endpoint of the "control-plane" service.
func NewGetVersionServerErrorResponseBody(res *controlplane.APIError) *GetVersionServerErrorResponseBody {
	body := &GetVersionServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestartInstanceClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "restart-instance" endpoint of the
// "control-plane" service.
func NewRestartInstanceClusterNotInitializedResponseBody(res *controlplane.APIError) *RestartInstanceClusterNotInitializedResponseBody {
	body := &RestartInstanceClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestartInstanceInvalidInputResponseBody builds the HTTP response body
// from the result of the "restart-instance" endpoint of the "control-plane"
// service.
func NewRestartInstanceInvalidInputResponseBody(res *controlplane.APIError) *RestartInstanceInvalidInputResponseBody {
	body := &RestartInstanceInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestartInstanceNotFoundResponseBody builds the HTTP response body from
// the result of the "restart-instance" endpoint of the "control-plane" service.
func NewRestartInstanceNotFoundResponseBody(res *controlplane.APIError) *RestartInstanceNotFoundResponseBody {
	body := &RestartInstanceNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewRestartInstanceServerErrorResponseBody builds the HTTP response body from
// the result of the "restart-instance" endpoint of the "control-plane" service.
func NewRestartInstanceServerErrorResponseBody(res *controlplane.APIError) *RestartInstanceServerErrorResponseBody {
	body := &RestartInstanceServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewStopInstanceClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "stop-instance" endpoint of the "control-plane"
// service.
func NewStopInstanceClusterNotInitializedResponseBody(res *controlplane.APIError) *StopInstanceClusterNotInitializedResponseBody {
	body := &StopInstanceClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewStopInstanceInvalidInputResponseBody builds the HTTP response body from
// the result of the "stop-instance" endpoint of the "control-plane" service.
func NewStopInstanceInvalidInputResponseBody(res *controlplane.APIError) *StopInstanceInvalidInputResponseBody {
	body := &StopInstanceInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewStopInstanceNotFoundResponseBody builds the HTTP response body from the
// result of the "stop-instance" endpoint of the "control-plane" service.
func NewStopInstanceNotFoundResponseBody(res *controlplane.APIError) *StopInstanceNotFoundResponseBody {
	body := &StopInstanceNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewStopInstanceServerErrorResponseBody builds the HTTP response body from
// the result of the "stop-instance" endpoint of the "control-plane" service.
func NewStopInstanceServerErrorResponseBody(res *controlplane.APIError) *StopInstanceServerErrorResponseBody {
	body := &StopInstanceServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewStartInstanceClusterNotInitializedResponseBody builds the HTTP response
// body from the result of the "start-instance" endpoint of the "control-plane"
// service.
func NewStartInstanceClusterNotInitializedResponseBody(res *controlplane.APIError) *StartInstanceClusterNotInitializedResponseBody {
	body := &StartInstanceClusterNotInitializedResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewStartInstanceInvalidInputResponseBody builds the HTTP response body from
// the result of the "start-instance" endpoint of the "control-plane" service.
func NewStartInstanceInvalidInputResponseBody(res *controlplane.APIError) *StartInstanceInvalidInputResponseBody {
	body := &StartInstanceInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewStartInstanceNotFoundResponseBody builds the HTTP response body from the
// result of the "start-instance" endpoint of the "control-plane" service.
func NewStartInstanceNotFoundResponseBody(res *controlplane.APIError) *StartInstanceNotFoundResponseBody {
	body := &StartInstanceNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewStartInstanceServerErrorResponseBody builds the HTTP response body from
// the result of the "start-instance" endpoint of the "control-plane" service.
func NewStartInstanceServerErrorResponseBody(res *controlplane.APIError) *StartInstanceServerErrorResponseBody {
	body := &StartInstanceServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewCancelDatabaseTaskNotFoundResponseBody builds the HTTP response body from
// the result of the "cancel-database-task" endpoint of the "control-plane"
// service.
func NewCancelDatabaseTaskNotFoundResponseBody(res *controlplane.APIError) *CancelDatabaseTaskNotFoundResponseBody {
	body := &CancelDatabaseTaskNotFoundResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewCancelDatabaseTaskInvalidInputResponseBody builds the HTTP response body
// from the result of the "cancel-database-task" endpoint of the
// "control-plane" service.
func NewCancelDatabaseTaskInvalidInputResponseBody(res *controlplane.APIError) *CancelDatabaseTaskInvalidInputResponseBody {
	body := &CancelDatabaseTaskInvalidInputResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewCancelDatabaseTaskServerErrorResponseBody builds the HTTP response body
// from the result of the "cancel-database-task" endpoint of the
// "control-plane" service.
func NewCancelDatabaseTaskServerErrorResponseBody(res *controlplane.APIError) *CancelDatabaseTaskServerErrorResponseBody {
	body := &CancelDatabaseTaskServerErrorResponseBody{
		Name:    res.Name,
		Message: res.Message,
	}
	return body
}

// NewJoinClusterClusterJoinToken builds a control-plane service join-cluster
// endpoint payload.
func NewJoinClusterClusterJoinToken(body *JoinClusterRequestBody) *controlplane.ClusterJoinToken {
	v := &controlplane.ClusterJoinToken{
		Token:     *body.Token,
		ServerURL: *body.ServerURL,
	}

	return v
}

// NewGetJoinOptionsClusterJoinRequest builds a control-plane service
// get-join-options endpoint payload.
func NewGetJoinOptionsClusterJoinRequest(body *GetJoinOptionsRequestBody) *controlplane.ClusterJoinRequest {
	v := &controlplane.ClusterJoinRequest{
		Token:       *body.Token,
		HostID:      controlplane.Identifier(*body.HostID),
		Hostname:    *body.Hostname,
		Ipv4Address: *body.Ipv4Address,
	}

	return v
}

// NewGetHostPayload builds a control-plane service get-host endpoint payload.
func NewGetHostPayload(hostID string) *controlplane.GetHostPayload {
	v := &controlplane.GetHostPayload{}
	v.HostID = controlplane.Identifier(hostID)

	return v
}

// NewRemoveHostPayload builds a control-plane service remove-host endpoint
// payload.
func NewRemoveHostPayload(hostID string) *controlplane.RemoveHostPayload {
	v := &controlplane.RemoveHostPayload{}
	v.HostID = controlplane.Identifier(hostID)

	return v
}

// NewCreateDatabaseRequest builds a control-plane service create-database
// endpoint payload.
func NewCreateDatabaseRequest(body *CreateDatabaseRequestBody) *controlplane.CreateDatabaseRequest {
	v := &controlplane.CreateDatabaseRequest{}
	if body.ID != nil {
		id := controlplane.Identifier(*body.ID)
		v.ID = &id
	}
	if body.TenantID != nil {
		tenantID := controlplane.Identifier(*body.TenantID)
		v.TenantID = &tenantID
	}
	v.Spec = unmarshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec(body.Spec)

	return v
}

// NewGetDatabasePayload builds a control-plane service get-database endpoint
// payload.
func NewGetDatabasePayload(databaseID string) *controlplane.GetDatabasePayload {
	v := &controlplane.GetDatabasePayload{}
	v.DatabaseID = controlplane.Identifier(databaseID)

	return v
}

// NewUpdateDatabasePayload builds a control-plane service update-database
// endpoint payload.
func NewUpdateDatabasePayload(body *UpdateDatabaseRequestBody, databaseID string, forceUpdate bool) *controlplane.UpdateDatabasePayload {
	v := &controlplane.UpdateDatabaseRequest{}
	if body.TenantID != nil {
		tenantID := controlplane.Identifier(*body.TenantID)
		v.TenantID = &tenantID
	}
	v.Spec = unmarshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec(body.Spec)
	res := &controlplane.UpdateDatabasePayload{
		Request: v,
	}
	res.DatabaseID = controlplane.Identifier(databaseID)
	res.ForceUpdate = forceUpdate

	return res
}

// NewDeleteDatabasePayload builds a control-plane service delete-database
// endpoint payload.
func NewDeleteDatabasePayload(databaseID string, force bool) *controlplane.DeleteDatabasePayload {
	v := &controlplane.DeleteDatabasePayload{}
	v.DatabaseID = controlplane.Identifier(databaseID)
	v.Force = force

	return v
}

// NewBackupDatabaseNodePayload builds a control-plane service
// backup-database-node endpoint payload.
func NewBackupDatabaseNodePayload(body *BackupDatabaseNodeRequestBody, databaseID string, nodeName string, force bool) *controlplane.BackupDatabaseNodePayload {
	v := &controlplane.BackupOptions{
		Type: *body.Type,
	}
	if body.Annotations != nil {
		v.Annotations = make(map[string]string, len(body.Annotations))
		for key, val := range body.Annotations {
			tk := key
			tv := val
			v.Annotations[tk] = tv
		}
	}
	if body.BackupOptions != nil {
		v.BackupOptions = make(map[string]string, len(body.BackupOptions))
		for key, val := range body.BackupOptions {
			tk := key
			tv := val
			v.BackupOptions[tk] = tv
		}
	}
	res := &controlplane.BackupDatabaseNodePayload{
		Options: v,
	}
	res.DatabaseID = controlplane.Identifier(databaseID)
	res.NodeName = nodeName
	res.Force = force

	return res
}

// NewSwitchoverDatabaseNodePayload builds a control-plane service
// switchover-database-node endpoint payload.
func NewSwitchoverDatabaseNodePayload(body *SwitchoverDatabaseNodeRequestBody, databaseID string, nodeName string) *controlplane.SwitchoverDatabaseNodePayload {
	v := &controlplane.SwitchoverDatabaseNodePayload{
		CandidateInstanceID: body.CandidateInstanceID,
		ScheduledAt:         body.ScheduledAt,
	}
	v.DatabaseID = controlplane.Identifier(databaseID)
	v.NodeName = nodeName

	return v
}

// NewFailoverDatabaseNodeRequest builds a control-plane service
// failover-database-node endpoint payload.
func NewFailoverDatabaseNodeRequest(body *FailoverDatabaseNodeRequestBody, databaseID string, nodeName string) *controlplane.FailoverDatabaseNodeRequest {
	v := &controlplane.FailoverDatabaseNodeRequest{
		CandidateInstanceID: body.CandidateInstanceID,
	}
	if body.SkipValidation != nil {
		v.SkipValidation = *body.SkipValidation
	}
	if body.SkipValidation == nil {
		v.SkipValidation = false
	}
	v.DatabaseID = controlplane.Identifier(databaseID)
	v.NodeName = nodeName

	return v
}

// NewListDatabaseTasksPayload builds a control-plane service
// list-database-tasks endpoint payload.
func NewListDatabaseTasksPayload(databaseID string, afterTaskID *string, limit *int, sortOrder *string) *controlplane.ListDatabaseTasksPayload {
	v := &controlplane.ListDatabaseTasksPayload{}
	v.DatabaseID = controlplane.Identifier(databaseID)
	v.AfterTaskID = afterTaskID
	v.Limit = limit
	v.SortOrder = sortOrder

	return v
}

// NewGetDatabaseTaskPayload builds a control-plane service get-database-task
// endpoint payload.
func NewGetDatabaseTaskPayload(databaseID string, taskID string) *controlplane.GetDatabaseTaskPayload {
	v := &controlplane.GetDatabaseTaskPayload{}
	v.DatabaseID = controlplane.Identifier(databaseID)
	v.TaskID = taskID

	return v
}

// NewGetDatabaseTaskLogPayload builds a control-plane service
// get-database-task-log endpoint payload.
func NewGetDatabaseTaskLogPayload(databaseID string, taskID string, afterEntryID *string, limit *int) *controlplane.GetDatabaseTaskLogPayload {
	v := &controlplane.GetDatabaseTaskLogPayload{}
	v.DatabaseID = controlplane.Identifier(databaseID)
	v.TaskID = taskID
	v.AfterEntryID = afterEntryID
	v.Limit = limit

	return v
}

// NewRestoreDatabasePayload builds a control-plane service restore-database
// endpoint payload.
func NewRestoreDatabasePayload(body *RestoreDatabaseRequestBody, databaseID string, force bool) *controlplane.RestoreDatabasePayload {
	v := &controlplane.RestoreDatabaseRequest{}
	v.RestoreConfig = unmarshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec(body.RestoreConfig)
	if body.TargetNodes != nil {
		v.TargetNodes = make([]string, len(body.TargetNodes))
		for i, val := range body.TargetNodes {
			v.TargetNodes[i] = val
		}
	}
	res := &controlplane.RestoreDatabasePayload{
		Request: v,
	}
	res.DatabaseID = controlplane.Identifier(databaseID)
	res.Force = force

	return res
}

// NewRestartInstancePayload builds a control-plane service restart-instance
// endpoint payload.
func NewRestartInstancePayload(body *RestartInstanceRequestBody, databaseID string, instanceID string) *controlplane.RestartInstancePayload {
	v := &controlplane.RestartOptions{
		ScheduledAt: body.ScheduledAt,
	}
	res := &controlplane.RestartInstancePayload{
		RestartOptions: v,
	}
	res.DatabaseID = controlplane.Identifier(databaseID)
	res.InstanceID = controlplane.Identifier(instanceID)

	return res
}

// NewStopInstancePayload builds a control-plane service stop-instance endpoint
// payload.
func NewStopInstancePayload(databaseID string, instanceID string, force bool) *controlplane.StopInstancePayload {
	v := &controlplane.StopInstancePayload{}
	v.DatabaseID = controlplane.Identifier(databaseID)
	v.InstanceID = controlplane.Identifier(instanceID)
	v.Force = force

	return v
}

// NewStartInstancePayload builds a control-plane service start-instance
// endpoint payload.
func NewStartInstancePayload(databaseID string, instanceID string, force bool) *controlplane.StartInstancePayload {
	v := &controlplane.StartInstancePayload{}
	v.DatabaseID = controlplane.Identifier(databaseID)
	v.InstanceID = controlplane.Identifier(instanceID)
	v.Force = force

	return v
}

// NewCancelDatabaseTaskPayload builds a control-plane service
// cancel-database-task endpoint payload.
func NewCancelDatabaseTaskPayload(databaseID string, taskID string) *controlplane.CancelDatabaseTaskPayload {
	v := &controlplane.CancelDatabaseTaskPayload{}
	v.DatabaseID = controlplane.Identifier(databaseID)
	v.TaskID = controlplane.Identifier(taskID)

	return v
}

// ValidateJoinClusterRequestBody runs the validations defined on
// Join-ClusterRequestBody
func ValidateJoinClusterRequestBody(body *JoinClusterRequestBody) (err error) {
	if body.Token == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("token", "body"))
	}
	if body.ServerURL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("server_url", "body"))
	}
	if body.ServerURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.server_url", *body.ServerURL, goa.FormatURI))
	}
	return
}

// ValidateGetJoinOptionsRequestBody runs the validations defined on
// Get-Join-OptionsRequestBody
func ValidateGetJoinOptionsRequestBody(body *GetJoinOptionsRequestBody) (err error) {
	if body.Token == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("token", "body"))
	}
	if body.HostID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_id", "body"))
	}
	if body.Hostname == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("hostname", "body"))
	}
	if body.Ipv4Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ipv4_address", "body"))
	}
	if body.Token != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.token", *body.Token, "^PGEDGE-[\\w]{64}-[\\w]{32}$"))
	}
	if body.HostID != nil {
		if utf8.RuneCountInString(*body.HostID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_id", *body.HostID, utf8.RuneCountInString(*body.HostID), 1, true))
		}
	}
	if body.HostID != nil {
		if utf8.RuneCountInString(*body.HostID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_id", *body.HostID, utf8.RuneCountInString(*body.HostID), 63, false))
		}
	}
	if body.Hostname != nil {
		if utf8.RuneCountInString(*body.Hostname) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.hostname", *body.Hostname, utf8.RuneCountInString(*body.Hostname), 3, true))
		}
	}
	if body.Hostname != nil {
		if utf8.RuneCountInString(*body.Hostname) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.hostname", *body.Hostname, utf8.RuneCountInString(*body.Hostname), 128, false))
		}
	}
	if body.Ipv4Address != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.ipv4_address", *body.Ipv4Address, goa.FormatIPv4))
	}
	return
}

// ValidateCreateDatabaseRequestBody runs the validations defined on
// Create-DatabaseRequestBody
func ValidateCreateDatabaseRequestBody(body *CreateDatabaseRequestBody) (err error) {
	if body.Spec == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spec", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 1, true))
		}
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 63, false))
		}
	}
	if body.TenantID != nil {
		if utf8.RuneCountInString(*body.TenantID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tenant_id", *body.TenantID, utf8.RuneCountInString(*body.TenantID), 1, true))
		}
	}
	if body.TenantID != nil {
		if utf8.RuneCountInString(*body.TenantID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tenant_id", *body.TenantID, utf8.RuneCountInString(*body.TenantID), 63, false))
		}
	}
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecRequestBody(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateUpdateDatabaseRequestBody runs the validations defined on
// Update-DatabaseRequestBody
func ValidateUpdateDatabaseRequestBody(body *UpdateDatabaseRequestBody) (err error) {
	if body.Spec == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spec", "body"))
	}
	if body.TenantID != nil {
		if utf8.RuneCountInString(*body.TenantID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tenant_id", *body.TenantID, utf8.RuneCountInString(*body.TenantID), 1, true))
		}
	}
	if body.TenantID != nil {
		if utf8.RuneCountInString(*body.TenantID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tenant_id", *body.TenantID, utf8.RuneCountInString(*body.TenantID), 63, false))
		}
	}
	if body.Spec != nil {
		if err2 := ValidateDatabaseSpecRequestBodyRequestBody(body.Spec); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBackupDatabaseNodeRequestBody runs the validations defined on
// Backup-Database-NodeRequestBody
func ValidateBackupDatabaseNodeRequestBody(body *BackupDatabaseNodeRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "diff" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "diff", "incr"}))
		}
	}
	return
}

// ValidateSwitchoverDatabaseNodeRequestBody runs the validations defined on
// Switchover-Database-NodeRequestBody
func ValidateSwitchoverDatabaseNodeRequestBody(body *SwitchoverDatabaseNodeRequestBody) (err error) {
	if body.ScheduledAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.scheduled_at", *body.ScheduledAt, goa.FormatDateTime))
	}
	return
}

// ValidateRestoreDatabaseRequestBody runs the validations defined on
// Restore-DatabaseRequestBody
func ValidateRestoreDatabaseRequestBody(body *RestoreDatabaseRequestBody) (err error) {
	if body.RestoreConfig == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("restore_config", "body"))
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecRequestBodyRequestBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if len(body.TargetNodes) > 9 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.target_nodes", body.TargetNodes, len(body.TargetNodes), 9, false))
	}
	return
}

// ValidateRestartInstanceRequestBody runs the validations defined on
// Restart-InstanceRequestBody
func ValidateRestartInstanceRequestBody(body *RestartInstanceRequestBody) (err error) {
	if body.ScheduledAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.scheduled_at", *body.ScheduledAt, goa.FormatDateTime))
	}
	return
}

// ValidateDatabaseSpecRequestBody runs the validations defined on
// DatabaseSpecRequestBody
func ValidateDatabaseSpecRequestBody(body *DatabaseSpecRequestBody) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.DatabaseName != nil {
		if utf8.RuneCountInString(*body.DatabaseName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.database_name", *body.DatabaseName, utf8.RuneCountInString(*body.DatabaseName), 1, true))
		}
	}
	if body.DatabaseName != nil {
		if utf8.RuneCountInString(*body.DatabaseName) > 31 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.database_name", *body.DatabaseName, utf8.RuneCountInString(*body.DatabaseName), 31, false))
		}
	}
	if body.PostgresVersion != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.postgres_version", *body.PostgresVersion, "^\\d{2}\\.\\d{1,2}$"))
	}
	if body.SpockVersion != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.spock_version", *body.SpockVersion, "^\\d{1}$"))
	}
	if body.Port != nil {
		if *body.Port < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.port", *body.Port, 0, true))
		}
	}
	if body.Port != nil {
		if *body.Port > 65535 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.port", *body.Port, 65535, false))
		}
	}
	if body.Cpus != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.cpus", *body.Cpus, "^[0-9]+(\\.[0-9]{1,3}|m)?$"))
	}
	if body.Memory != nil {
		if utf8.RuneCountInString(*body.Memory) > 16 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.memory", *body.Memory, utf8.RuneCountInString(*body.Memory), 16, false))
		}
	}
	if len(body.Nodes) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.nodes", body.Nodes, len(body.Nodes), 1, true))
	}
	if len(body.Nodes) > 9 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.nodes", body.Nodes, len(body.Nodes), 9, false))
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if len(body.DatabaseUsers) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.database_users", body.DatabaseUsers, len(body.DatabaseUsers), 16, false))
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecRequestBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if len(body.PostgresqlConf) > 64 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.postgresql_conf", body.PostgresqlConf, len(body.PostgresqlConf), 64, false))
	}
	if body.OrchestratorOpts != nil {
		if err2 := ValidateOrchestratorOptsRequestBody(body.OrchestratorOpts); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBody runs the validations defined on
// DatabaseNodeSpecRequestBody
func ValidateDatabaseNodeSpecRequestBody(body *DatabaseNodeSpecRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "body"))
	}
	if body.Name != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.name", *body.Name, "n[0-9]+"))
	}
	if len(body.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids", body.HostIds, len(body.HostIds), 1, true))
	}
	for _, e := range body.HostIds {
		if utf8.RuneCountInString(e) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids[*]", e, utf8.RuneCountInString(e), 1, true))
		}
		if utf8.RuneCountInString(e) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids[*]", e, utf8.RuneCountInString(e), 63, false))
		}
	}
	if body.PostgresVersion != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.postgres_version", *body.PostgresVersion, "^\\d{2}\\.\\d{1,2}$"))
	}
	if body.Port != nil {
		if *body.Port < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.port", *body.Port, 0, true))
		}
	}
	if body.Port != nil {
		if *body.Port > 65535 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.port", *body.Port, 65535, false))
		}
	}
	if body.Cpus != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.cpus", *body.Cpus, "^[0-9]+(\\.[0-9]{1,3}|m)?$"))
	}
	if body.Memory != nil {
		if utf8.RuneCountInString(*body.Memory) > 16 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.memory", *body.Memory, utf8.RuneCountInString(*body.Memory), 16, false))
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecRequestBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.OrchestratorOpts != nil {
		if err2 := ValidateOrchestratorOptsRequestBody(body.OrchestratorOpts); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBackupConfigSpecRequestBody runs the validations defined on
// BackupConfigSpecRequestBody
func ValidateBackupConfigSpecRequestBody(body *BackupConfigSpecRequestBody) (err error) {
	if body.Repositories == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repositories", "body"))
	}
	if len(body.Repositories) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.repositories", body.Repositories, len(body.Repositories), 1, true))
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if len(body.Schedules) > 32 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.schedules", body.Schedules, len(body.Schedules), 32, false))
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBody runs the validations defined on
// BackupRepositorySpecRequestBody
func ValidateBackupRepositorySpecRequestBody(body *BackupRepositorySpecRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 1, true))
		}
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 63, false))
		}
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure" || *body.Type == "posix" || *body.Type == "cifs") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure", "posix", "cifs"}))
		}
	}
	if body.S3Bucket != nil {
		if utf8.RuneCountInString(*body.S3Bucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_bucket", *body.S3Bucket, utf8.RuneCountInString(*body.S3Bucket), 3, true))
		}
	}
	if body.S3Bucket != nil {
		if utf8.RuneCountInString(*body.S3Bucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_bucket", *body.S3Bucket, utf8.RuneCountInString(*body.S3Bucket), 63, false))
		}
	}
	if body.S3Region != nil {
		if utf8.RuneCountInString(*body.S3Region) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_region", *body.S3Region, utf8.RuneCountInString(*body.S3Region), 1, true))
		}
	}
	if body.S3Region != nil {
		if utf8.RuneCountInString(*body.S3Region) > 32 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_region", *body.S3Region, utf8.RuneCountInString(*body.S3Region), 32, false))
		}
	}
	if body.S3Endpoint != nil {
		if utf8.RuneCountInString(*body.S3Endpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_endpoint", *body.S3Endpoint, utf8.RuneCountInString(*body.S3Endpoint), 3, true))
		}
	}
	if body.S3Endpoint != nil {
		if utf8.RuneCountInString(*body.S3Endpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_endpoint", *body.S3Endpoint, utf8.RuneCountInString(*body.S3Endpoint), 128, false))
		}
	}
	if body.S3Key != nil {
		if utf8.RuneCountInString(*body.S3Key) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_key", *body.S3Key, utf8.RuneCountInString(*body.S3Key), 128, false))
		}
	}
	if body.S3KeySecret != nil {
		if utf8.RuneCountInString(*body.S3KeySecret) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_key_secret", *body.S3KeySecret, utf8.RuneCountInString(*body.S3KeySecret), 128, false))
		}
	}
	if body.GcsBucket != nil {
		if utf8.RuneCountInString(*body.GcsBucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_bucket", *body.GcsBucket, utf8.RuneCountInString(*body.GcsBucket), 3, true))
		}
	}
	if body.GcsBucket != nil {
		if utf8.RuneCountInString(*body.GcsBucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_bucket", *body.GcsBucket, utf8.RuneCountInString(*body.GcsBucket), 63, false))
		}
	}
	if body.GcsEndpoint != nil {
		if utf8.RuneCountInString(*body.GcsEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_endpoint", *body.GcsEndpoint, utf8.RuneCountInString(*body.GcsEndpoint), 3, true))
		}
	}
	if body.GcsEndpoint != nil {
		if utf8.RuneCountInString(*body.GcsEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_endpoint", *body.GcsEndpoint, utf8.RuneCountInString(*body.GcsEndpoint), 128, false))
		}
	}
	if body.GcsKey != nil {
		if utf8.RuneCountInString(*body.GcsKey) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_key", *body.GcsKey, utf8.RuneCountInString(*body.GcsKey), 1024, false))
		}
	}
	if body.AzureAccount != nil {
		if utf8.RuneCountInString(*body.AzureAccount) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_account", *body.AzureAccount, utf8.RuneCountInString(*body.AzureAccount), 3, true))
		}
	}
	if body.AzureAccount != nil {
		if utf8.RuneCountInString(*body.AzureAccount) > 24 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_account", *body.AzureAccount, utf8.RuneCountInString(*body.AzureAccount), 24, false))
		}
	}
	if body.AzureContainer != nil {
		if utf8.RuneCountInString(*body.AzureContainer) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_container", *body.AzureContainer, utf8.RuneCountInString(*body.AzureContainer), 3, true))
		}
	}
	if body.AzureContainer != nil {
		if utf8.RuneCountInString(*body.AzureContainer) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_container", *body.AzureContainer, utf8.RuneCountInString(*body.AzureContainer), 63, false))
		}
	}
	if body.AzureEndpoint != nil {
		if utf8.RuneCountInString(*body.AzureEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_endpoint", *body.AzureEndpoint, utf8.RuneCountInString(*body.AzureEndpoint), 3, true))
		}
	}
	if body.AzureEndpoint != nil {
		if utf8.RuneCountInString(*body.AzureEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_endpoint", *body.AzureEndpoint, utf8.RuneCountInString(*body.AzureEndpoint), 128, false))
		}
	}
	if body.AzureKey != nil {
		if utf8.RuneCountInString(*body.AzureKey) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_key", *body.AzureKey, utf8.RuneCountInString(*body.AzureKey), 128, false))
		}
	}
	if body.RetentionFull != nil {
		if *body.RetentionFull < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.retention_full", *body.RetentionFull, 1, true))
		}
	}
	if body.RetentionFull != nil {
		if *body.RetentionFull > 9.999999e+06 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.retention_full", *body.RetentionFull, 9.999999e+06, false))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	if body.BasePath != nil {
		if utf8.RuneCountInString(*body.BasePath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.base_path", *body.BasePath, utf8.RuneCountInString(*body.BasePath), 256, false))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBody runs the validations defined on
// BackupScheduleSpecRequestBody
func ValidateBackupScheduleSpecRequestBody(body *BackupScheduleSpecRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 64, false))
		}
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	if body.CronExpression != nil {
		if utf8.RuneCountInString(*body.CronExpression) > 32 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.cron_expression", *body.CronExpression, utf8.RuneCountInString(*body.CronExpression), 32, false))
		}
	}
	return
}

// ValidateRestoreConfigSpecRequestBody runs the validations defined on
// RestoreConfigSpecRequestBody
func ValidateRestoreConfigSpecRequestBody(body *RestoreConfigSpecRequestBody) (err error) {
	if body.SourceDatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_database_id", "body"))
	}
	if body.SourceNodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_node_name", "body"))
	}
	if body.SourceDatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_database_name", "body"))
	}
	if body.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "body"))
	}
	if body.SourceDatabaseID != nil {
		if utf8.RuneCountInString(*body.SourceDatabaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.source_database_id", *body.SourceDatabaseID, utf8.RuneCountInString(*body.SourceDatabaseID), 1, true))
		}
	}
	if body.SourceDatabaseID != nil {
		if utf8.RuneCountInString(*body.SourceDatabaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.source_database_id", *body.SourceDatabaseID, utf8.RuneCountInString(*body.SourceDatabaseID), 63, false))
		}
	}
	if body.SourceNodeName != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.source_node_name", *body.SourceNodeName, "n[0-9]+"))
	}
	if body.SourceDatabaseName != nil {
		if utf8.RuneCountInString(*body.SourceDatabaseName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.source_database_name", *body.SourceDatabaseName, utf8.RuneCountInString(*body.SourceDatabaseName), 1, true))
		}
	}
	if body.SourceDatabaseName != nil {
		if utf8.RuneCountInString(*body.SourceDatabaseName) > 31 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.source_database_name", *body.SourceDatabaseName, utf8.RuneCountInString(*body.SourceDatabaseName), 31, false))
		}
	}
	if body.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecRequestBody(body.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if len(body.RestoreOptions) > 32 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.restore_options", body.RestoreOptions, len(body.RestoreOptions), 32, false))
	}
	return
}

// ValidateRestoreRepositorySpecRequestBody runs the validations defined on
// RestoreRepositorySpecRequestBody
func ValidateRestoreRepositorySpecRequestBody(body *RestoreRepositorySpecRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 1, true))
		}
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 63, false))
		}
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure" || *body.Type == "posix" || *body.Type == "cifs") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure", "posix", "cifs"}))
		}
	}
	if body.S3Bucket != nil {
		if utf8.RuneCountInString(*body.S3Bucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_bucket", *body.S3Bucket, utf8.RuneCountInString(*body.S3Bucket), 3, true))
		}
	}
	if body.S3Bucket != nil {
		if utf8.RuneCountInString(*body.S3Bucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_bucket", *body.S3Bucket, utf8.RuneCountInString(*body.S3Bucket), 63, false))
		}
	}
	if body.S3Region != nil {
		if utf8.RuneCountInString(*body.S3Region) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_region", *body.S3Region, utf8.RuneCountInString(*body.S3Region), 1, true))
		}
	}
	if body.S3Region != nil {
		if utf8.RuneCountInString(*body.S3Region) > 32 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_region", *body.S3Region, utf8.RuneCountInString(*body.S3Region), 32, false))
		}
	}
	if body.S3Endpoint != nil {
		if utf8.RuneCountInString(*body.S3Endpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_endpoint", *body.S3Endpoint, utf8.RuneCountInString(*body.S3Endpoint), 3, true))
		}
	}
	if body.S3Endpoint != nil {
		if utf8.RuneCountInString(*body.S3Endpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_endpoint", *body.S3Endpoint, utf8.RuneCountInString(*body.S3Endpoint), 128, false))
		}
	}
	if body.S3Key != nil {
		if utf8.RuneCountInString(*body.S3Key) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_key", *body.S3Key, utf8.RuneCountInString(*body.S3Key), 128, false))
		}
	}
	if body.S3KeySecret != nil {
		if utf8.RuneCountInString(*body.S3KeySecret) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_key_secret", *body.S3KeySecret, utf8.RuneCountInString(*body.S3KeySecret), 128, false))
		}
	}
	if body.GcsBucket != nil {
		if utf8.RuneCountInString(*body.GcsBucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_bucket", *body.GcsBucket, utf8.RuneCountInString(*body.GcsBucket), 3, true))
		}
	}
	if body.GcsBucket != nil {
		if utf8.RuneCountInString(*body.GcsBucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_bucket", *body.GcsBucket, utf8.RuneCountInString(*body.GcsBucket), 63, false))
		}
	}
	if body.GcsEndpoint != nil {
		if utf8.RuneCountInString(*body.GcsEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_endpoint", *body.GcsEndpoint, utf8.RuneCountInString(*body.GcsEndpoint), 3, true))
		}
	}
	if body.GcsEndpoint != nil {
		if utf8.RuneCountInString(*body.GcsEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_endpoint", *body.GcsEndpoint, utf8.RuneCountInString(*body.GcsEndpoint), 128, false))
		}
	}
	if body.GcsKey != nil {
		if utf8.RuneCountInString(*body.GcsKey) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_key", *body.GcsKey, utf8.RuneCountInString(*body.GcsKey), 1024, false))
		}
	}
	if body.AzureAccount != nil {
		if utf8.RuneCountInString(*body.AzureAccount) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_account", *body.AzureAccount, utf8.RuneCountInString(*body.AzureAccount), 3, true))
		}
	}
	if body.AzureAccount != nil {
		if utf8.RuneCountInString(*body.AzureAccount) > 24 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_account", *body.AzureAccount, utf8.RuneCountInString(*body.AzureAccount), 24, false))
		}
	}
	if body.AzureContainer != nil {
		if utf8.RuneCountInString(*body.AzureContainer) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_container", *body.AzureContainer, utf8.RuneCountInString(*body.AzureContainer), 3, true))
		}
	}
	if body.AzureContainer != nil {
		if utf8.RuneCountInString(*body.AzureContainer) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_container", *body.AzureContainer, utf8.RuneCountInString(*body.AzureContainer), 63, false))
		}
	}
	if body.AzureEndpoint != nil {
		if utf8.RuneCountInString(*body.AzureEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_endpoint", *body.AzureEndpoint, utf8.RuneCountInString(*body.AzureEndpoint), 3, true))
		}
	}
	if body.AzureEndpoint != nil {
		if utf8.RuneCountInString(*body.AzureEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_endpoint", *body.AzureEndpoint, utf8.RuneCountInString(*body.AzureEndpoint), 128, false))
		}
	}
	if body.AzureKey != nil {
		if utf8.RuneCountInString(*body.AzureKey) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_key", *body.AzureKey, utf8.RuneCountInString(*body.AzureKey), 128, false))
		}
	}
	if body.BasePath != nil {
		if utf8.RuneCountInString(*body.BasePath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.base_path", *body.BasePath, utf8.RuneCountInString(*body.BasePath), 256, false))
		}
	}
	return
}

// ValidateOrchestratorOptsRequestBody runs the validations defined on
// OrchestratorOptsRequestBody
func ValidateOrchestratorOptsRequestBody(body *OrchestratorOptsRequestBody) (err error) {
	if body.Swarm != nil {
		if err2 := ValidateSwarmOptsRequestBody(body.Swarm); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateSwarmOptsRequestBody runs the validations defined on
// SwarmOptsRequestBody
func ValidateSwarmOptsRequestBody(body *SwarmOptsRequestBody) (err error) {
	if len(body.ExtraVolumes) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.extra_volumes", body.ExtraVolumes, len(body.ExtraVolumes), 16, false))
	}
	for _, e := range body.ExtraVolumes {
		if e != nil {
			if err2 := ValidateExtraVolumesSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if len(body.ExtraNetworks) > 8 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.extra_networks", body.ExtraNetworks, len(body.ExtraNetworks), 8, false))
	}
	for _, e := range body.ExtraNetworks {
		if e != nil {
			if err2 := ValidateExtraNetworkSpecRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateExtraVolumesSpecRequestBody runs the validations defined on
// ExtraVolumesSpecRequestBody
func ValidateExtraVolumesSpecRequestBody(body *ExtraVolumesSpecRequestBody) (err error) {
	if body.HostPath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_path", "body"))
	}
	if body.DestinationPath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("destination_path", "body"))
	}
	if body.HostPath != nil {
		if utf8.RuneCountInString(*body.HostPath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_path", *body.HostPath, utf8.RuneCountInString(*body.HostPath), 256, false))
		}
	}
	if body.DestinationPath != nil {
		if utf8.RuneCountInString(*body.DestinationPath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.destination_path", *body.DestinationPath, utf8.RuneCountInString(*body.DestinationPath), 256, false))
		}
	}
	return
}

// ValidateExtraNetworkSpecRequestBody runs the validations defined on
// ExtraNetworkSpecRequestBody
func ValidateExtraNetworkSpecRequestBody(body *ExtraNetworkSpecRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if len(body.Aliases) > 8 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.aliases", body.Aliases, len(body.Aliases), 8, false))
	}
	return
}

// ValidateDatabaseUserSpecRequestBody runs the validations defined on
// DatabaseUserSpecRequestBody
func ValidateDatabaseUserSpecRequestBody(body *DatabaseUserSpecRequestBody) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Username != nil {
		if utf8.RuneCountInString(*body.Username) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.username", *body.Username, utf8.RuneCountInString(*body.Username), 1, true))
		}
	}
	if body.Password != nil {
		if utf8.RuneCountInString(*body.Password) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.password", *body.Password, utf8.RuneCountInString(*body.Password), 1, true))
		}
	}
	if len(body.Attributes) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.attributes", body.Attributes, len(body.Attributes), 16, false))
	}
	if len(body.Roles) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.roles", body.Roles, len(body.Roles), 16, false))
	}
	return
}

// ValidateDatabaseSpecRequestBodyRequestBody runs the validations defined on
// DatabaseSpecRequestBodyRequestBody
func ValidateDatabaseSpecRequestBodyRequestBody(body *DatabaseSpecRequestBodyRequestBody) (err error) {
	if body.DatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("database_name", "body"))
	}
	if body.Nodes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nodes", "body"))
	}
	if body.DatabaseName != nil {
		if utf8.RuneCountInString(*body.DatabaseName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.database_name", *body.DatabaseName, utf8.RuneCountInString(*body.DatabaseName), 1, true))
		}
	}
	if body.DatabaseName != nil {
		if utf8.RuneCountInString(*body.DatabaseName) > 31 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.database_name", *body.DatabaseName, utf8.RuneCountInString(*body.DatabaseName), 31, false))
		}
	}
	if body.PostgresVersion != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.postgres_version", *body.PostgresVersion, "^\\d{2}\\.\\d{1,2}$"))
	}
	if body.SpockVersion != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.spock_version", *body.SpockVersion, "^\\d{1}$"))
	}
	if body.Port != nil {
		if *body.Port < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.port", *body.Port, 0, true))
		}
	}
	if body.Port != nil {
		if *body.Port > 65535 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.port", *body.Port, 65535, false))
		}
	}
	if body.Cpus != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.cpus", *body.Cpus, "^[0-9]+(\\.[0-9]{1,3}|m)?$"))
	}
	if body.Memory != nil {
		if utf8.RuneCountInString(*body.Memory) > 16 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.memory", *body.Memory, utf8.RuneCountInString(*body.Memory), 16, false))
		}
	}
	if len(body.Nodes) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.nodes", body.Nodes, len(body.Nodes), 1, true))
	}
	if len(body.Nodes) > 9 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.nodes", body.Nodes, len(body.Nodes), 9, false))
	}
	for _, e := range body.Nodes {
		if e != nil {
			if err2 := ValidateDatabaseNodeSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if len(body.DatabaseUsers) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.database_users", body.DatabaseUsers, len(body.DatabaseUsers), 16, false))
	}
	for _, e := range body.DatabaseUsers {
		if e != nil {
			if err2 := ValidateDatabaseUserSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBodyRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecRequestBodyRequestBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if len(body.PostgresqlConf) > 64 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.postgresql_conf", body.PostgresqlConf, len(body.PostgresqlConf), 64, false))
	}
	if body.OrchestratorOpts != nil {
		if err2 := ValidateOrchestratorOptsRequestBodyRequestBody(body.OrchestratorOpts); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDatabaseNodeSpecRequestBodyRequestBody runs the validations defined
// on DatabaseNodeSpecRequestBodyRequestBody
func ValidateDatabaseNodeSpecRequestBodyRequestBody(body *DatabaseNodeSpecRequestBodyRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.HostIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_ids", "body"))
	}
	if body.Name != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.name", *body.Name, "n[0-9]+"))
	}
	if len(body.HostIds) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids", body.HostIds, len(body.HostIds), 1, true))
	}
	for _, e := range body.HostIds {
		if utf8.RuneCountInString(e) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids[*]", e, utf8.RuneCountInString(e), 1, true))
		}
		if utf8.RuneCountInString(e) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_ids[*]", e, utf8.RuneCountInString(e), 63, false))
		}
	}
	if body.PostgresVersion != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.postgres_version", *body.PostgresVersion, "^\\d{2}\\.\\d{1,2}$"))
	}
	if body.Port != nil {
		if *body.Port < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.port", *body.Port, 0, true))
		}
	}
	if body.Port != nil {
		if *body.Port > 65535 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.port", *body.Port, 65535, false))
		}
	}
	if body.Cpus != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.cpus", *body.Cpus, "^[0-9]+(\\.[0-9]{1,3}|m)?$"))
	}
	if body.Memory != nil {
		if utf8.RuneCountInString(*body.Memory) > 16 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.memory", *body.Memory, utf8.RuneCountInString(*body.Memory), 16, false))
		}
	}
	if body.BackupConfig != nil {
		if err2 := ValidateBackupConfigSpecRequestBodyRequestBody(body.BackupConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.RestoreConfig != nil {
		if err2 := ValidateRestoreConfigSpecRequestBodyRequestBody(body.RestoreConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.OrchestratorOpts != nil {
		if err2 := ValidateOrchestratorOptsRequestBodyRequestBody(body.OrchestratorOpts); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBackupConfigSpecRequestBodyRequestBody runs the validations defined
// on BackupConfigSpecRequestBodyRequestBody
func ValidateBackupConfigSpecRequestBodyRequestBody(body *BackupConfigSpecRequestBodyRequestBody) (err error) {
	if body.Repositories == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repositories", "body"))
	}
	if len(body.Repositories) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.repositories", body.Repositories, len(body.Repositories), 1, true))
	}
	for _, e := range body.Repositories {
		if e != nil {
			if err2 := ValidateBackupRepositorySpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if len(body.Schedules) > 32 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.schedules", body.Schedules, len(body.Schedules), 32, false))
	}
	for _, e := range body.Schedules {
		if e != nil {
			if err2 := ValidateBackupScheduleSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateBackupRepositorySpecRequestBodyRequestBody runs the validations
// defined on BackupRepositorySpecRequestBodyRequestBody
func ValidateBackupRepositorySpecRequestBodyRequestBody(body *BackupRepositorySpecRequestBodyRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 1, true))
		}
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 63, false))
		}
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure" || *body.Type == "posix" || *body.Type == "cifs") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure", "posix", "cifs"}))
		}
	}
	if body.S3Bucket != nil {
		if utf8.RuneCountInString(*body.S3Bucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_bucket", *body.S3Bucket, utf8.RuneCountInString(*body.S3Bucket), 3, true))
		}
	}
	if body.S3Bucket != nil {
		if utf8.RuneCountInString(*body.S3Bucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_bucket", *body.S3Bucket, utf8.RuneCountInString(*body.S3Bucket), 63, false))
		}
	}
	if body.S3Region != nil {
		if utf8.RuneCountInString(*body.S3Region) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_region", *body.S3Region, utf8.RuneCountInString(*body.S3Region), 1, true))
		}
	}
	if body.S3Region != nil {
		if utf8.RuneCountInString(*body.S3Region) > 32 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_region", *body.S3Region, utf8.RuneCountInString(*body.S3Region), 32, false))
		}
	}
	if body.S3Endpoint != nil {
		if utf8.RuneCountInString(*body.S3Endpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_endpoint", *body.S3Endpoint, utf8.RuneCountInString(*body.S3Endpoint), 3, true))
		}
	}
	if body.S3Endpoint != nil {
		if utf8.RuneCountInString(*body.S3Endpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_endpoint", *body.S3Endpoint, utf8.RuneCountInString(*body.S3Endpoint), 128, false))
		}
	}
	if body.S3Key != nil {
		if utf8.RuneCountInString(*body.S3Key) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_key", *body.S3Key, utf8.RuneCountInString(*body.S3Key), 128, false))
		}
	}
	if body.S3KeySecret != nil {
		if utf8.RuneCountInString(*body.S3KeySecret) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_key_secret", *body.S3KeySecret, utf8.RuneCountInString(*body.S3KeySecret), 128, false))
		}
	}
	if body.GcsBucket != nil {
		if utf8.RuneCountInString(*body.GcsBucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_bucket", *body.GcsBucket, utf8.RuneCountInString(*body.GcsBucket), 3, true))
		}
	}
	if body.GcsBucket != nil {
		if utf8.RuneCountInString(*body.GcsBucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_bucket", *body.GcsBucket, utf8.RuneCountInString(*body.GcsBucket), 63, false))
		}
	}
	if body.GcsEndpoint != nil {
		if utf8.RuneCountInString(*body.GcsEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_endpoint", *body.GcsEndpoint, utf8.RuneCountInString(*body.GcsEndpoint), 3, true))
		}
	}
	if body.GcsEndpoint != nil {
		if utf8.RuneCountInString(*body.GcsEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_endpoint", *body.GcsEndpoint, utf8.RuneCountInString(*body.GcsEndpoint), 128, false))
		}
	}
	if body.GcsKey != nil {
		if utf8.RuneCountInString(*body.GcsKey) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_key", *body.GcsKey, utf8.RuneCountInString(*body.GcsKey), 1024, false))
		}
	}
	if body.AzureAccount != nil {
		if utf8.RuneCountInString(*body.AzureAccount) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_account", *body.AzureAccount, utf8.RuneCountInString(*body.AzureAccount), 3, true))
		}
	}
	if body.AzureAccount != nil {
		if utf8.RuneCountInString(*body.AzureAccount) > 24 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_account", *body.AzureAccount, utf8.RuneCountInString(*body.AzureAccount), 24, false))
		}
	}
	if body.AzureContainer != nil {
		if utf8.RuneCountInString(*body.AzureContainer) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_container", *body.AzureContainer, utf8.RuneCountInString(*body.AzureContainer), 3, true))
		}
	}
	if body.AzureContainer != nil {
		if utf8.RuneCountInString(*body.AzureContainer) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_container", *body.AzureContainer, utf8.RuneCountInString(*body.AzureContainer), 63, false))
		}
	}
	if body.AzureEndpoint != nil {
		if utf8.RuneCountInString(*body.AzureEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_endpoint", *body.AzureEndpoint, utf8.RuneCountInString(*body.AzureEndpoint), 3, true))
		}
	}
	if body.AzureEndpoint != nil {
		if utf8.RuneCountInString(*body.AzureEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_endpoint", *body.AzureEndpoint, utf8.RuneCountInString(*body.AzureEndpoint), 128, false))
		}
	}
	if body.AzureKey != nil {
		if utf8.RuneCountInString(*body.AzureKey) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_key", *body.AzureKey, utf8.RuneCountInString(*body.AzureKey), 128, false))
		}
	}
	if body.RetentionFull != nil {
		if *body.RetentionFull < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.retention_full", *body.RetentionFull, 1, true))
		}
	}
	if body.RetentionFull != nil {
		if *body.RetentionFull > 9.999999e+06 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.retention_full", *body.RetentionFull, 9.999999e+06, false))
		}
	}
	if body.RetentionFullType != nil {
		if !(*body.RetentionFullType == "time" || *body.RetentionFullType == "count") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.retention_full_type", *body.RetentionFullType, []any{"time", "count"}))
		}
	}
	if body.BasePath != nil {
		if utf8.RuneCountInString(*body.BasePath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.base_path", *body.BasePath, utf8.RuneCountInString(*body.BasePath), 256, false))
		}
	}
	return
}

// ValidateBackupScheduleSpecRequestBodyRequestBody runs the validations
// defined on BackupScheduleSpecRequestBodyRequestBody
func ValidateBackupScheduleSpecRequestBodyRequestBody(body *BackupScheduleSpecRequestBodyRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.CronExpression == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cron_expression", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 64, false))
		}
	}
	if body.Type != nil {
		if !(*body.Type == "full" || *body.Type == "incr") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"full", "incr"}))
		}
	}
	if body.CronExpression != nil {
		if utf8.RuneCountInString(*body.CronExpression) > 32 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.cron_expression", *body.CronExpression, utf8.RuneCountInString(*body.CronExpression), 32, false))
		}
	}
	return
}

// ValidateRestoreConfigSpecRequestBodyRequestBody runs the validations defined
// on RestoreConfigSpecRequestBodyRequestBody
func ValidateRestoreConfigSpecRequestBodyRequestBody(body *RestoreConfigSpecRequestBodyRequestBody) (err error) {
	if body.SourceDatabaseID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_database_id", "body"))
	}
	if body.SourceNodeName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_node_name", "body"))
	}
	if body.SourceDatabaseName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source_database_name", "body"))
	}
	if body.Repository == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repository", "body"))
	}
	if body.SourceDatabaseID != nil {
		if utf8.RuneCountInString(*body.SourceDatabaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.source_database_id", *body.SourceDatabaseID, utf8.RuneCountInString(*body.SourceDatabaseID), 1, true))
		}
	}
	if body.SourceDatabaseID != nil {
		if utf8.RuneCountInString(*body.SourceDatabaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.source_database_id", *body.SourceDatabaseID, utf8.RuneCountInString(*body.SourceDatabaseID), 63, false))
		}
	}
	if body.SourceNodeName != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.source_node_name", *body.SourceNodeName, "n[0-9]+"))
	}
	if body.SourceDatabaseName != nil {
		if utf8.RuneCountInString(*body.SourceDatabaseName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.source_database_name", *body.SourceDatabaseName, utf8.RuneCountInString(*body.SourceDatabaseName), 1, true))
		}
	}
	if body.SourceDatabaseName != nil {
		if utf8.RuneCountInString(*body.SourceDatabaseName) > 31 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.source_database_name", *body.SourceDatabaseName, utf8.RuneCountInString(*body.SourceDatabaseName), 31, false))
		}
	}
	if body.Repository != nil {
		if err2 := ValidateRestoreRepositorySpecRequestBodyRequestBody(body.Repository); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if len(body.RestoreOptions) > 32 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.restore_options", body.RestoreOptions, len(body.RestoreOptions), 32, false))
	}
	return
}

// ValidateRestoreRepositorySpecRequestBodyRequestBody runs the validations
// defined on RestoreRepositorySpecRequestBodyRequestBody
func ValidateRestoreRepositorySpecRequestBodyRequestBody(body *RestoreRepositorySpecRequestBodyRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 1, true))
		}
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 63, false))
		}
	}
	if body.Type != nil {
		if !(*body.Type == "s3" || *body.Type == "gcs" || *body.Type == "azure" || *body.Type == "posix" || *body.Type == "cifs") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"s3", "gcs", "azure", "posix", "cifs"}))
		}
	}
	if body.S3Bucket != nil {
		if utf8.RuneCountInString(*body.S3Bucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_bucket", *body.S3Bucket, utf8.RuneCountInString(*body.S3Bucket), 3, true))
		}
	}
	if body.S3Bucket != nil {
		if utf8.RuneCountInString(*body.S3Bucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_bucket", *body.S3Bucket, utf8.RuneCountInString(*body.S3Bucket), 63, false))
		}
	}
	if body.S3Region != nil {
		if utf8.RuneCountInString(*body.S3Region) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_region", *body.S3Region, utf8.RuneCountInString(*body.S3Region), 1, true))
		}
	}
	if body.S3Region != nil {
		if utf8.RuneCountInString(*body.S3Region) > 32 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_region", *body.S3Region, utf8.RuneCountInString(*body.S3Region), 32, false))
		}
	}
	if body.S3Endpoint != nil {
		if utf8.RuneCountInString(*body.S3Endpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_endpoint", *body.S3Endpoint, utf8.RuneCountInString(*body.S3Endpoint), 3, true))
		}
	}
	if body.S3Endpoint != nil {
		if utf8.RuneCountInString(*body.S3Endpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_endpoint", *body.S3Endpoint, utf8.RuneCountInString(*body.S3Endpoint), 128, false))
		}
	}
	if body.S3Key != nil {
		if utf8.RuneCountInString(*body.S3Key) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_key", *body.S3Key, utf8.RuneCountInString(*body.S3Key), 128, false))
		}
	}
	if body.S3KeySecret != nil {
		if utf8.RuneCountInString(*body.S3KeySecret) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.s3_key_secret", *body.S3KeySecret, utf8.RuneCountInString(*body.S3KeySecret), 128, false))
		}
	}
	if body.GcsBucket != nil {
		if utf8.RuneCountInString(*body.GcsBucket) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_bucket", *body.GcsBucket, utf8.RuneCountInString(*body.GcsBucket), 3, true))
		}
	}
	if body.GcsBucket != nil {
		if utf8.RuneCountInString(*body.GcsBucket) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_bucket", *body.GcsBucket, utf8.RuneCountInString(*body.GcsBucket), 63, false))
		}
	}
	if body.GcsEndpoint != nil {
		if utf8.RuneCountInString(*body.GcsEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_endpoint", *body.GcsEndpoint, utf8.RuneCountInString(*body.GcsEndpoint), 3, true))
		}
	}
	if body.GcsEndpoint != nil {
		if utf8.RuneCountInString(*body.GcsEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_endpoint", *body.GcsEndpoint, utf8.RuneCountInString(*body.GcsEndpoint), 128, false))
		}
	}
	if body.GcsKey != nil {
		if utf8.RuneCountInString(*body.GcsKey) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gcs_key", *body.GcsKey, utf8.RuneCountInString(*body.GcsKey), 1024, false))
		}
	}
	if body.AzureAccount != nil {
		if utf8.RuneCountInString(*body.AzureAccount) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_account", *body.AzureAccount, utf8.RuneCountInString(*body.AzureAccount), 3, true))
		}
	}
	if body.AzureAccount != nil {
		if utf8.RuneCountInString(*body.AzureAccount) > 24 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_account", *body.AzureAccount, utf8.RuneCountInString(*body.AzureAccount), 24, false))
		}
	}
	if body.AzureContainer != nil {
		if utf8.RuneCountInString(*body.AzureContainer) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_container", *body.AzureContainer, utf8.RuneCountInString(*body.AzureContainer), 3, true))
		}
	}
	if body.AzureContainer != nil {
		if utf8.RuneCountInString(*body.AzureContainer) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_container", *body.AzureContainer, utf8.RuneCountInString(*body.AzureContainer), 63, false))
		}
	}
	if body.AzureEndpoint != nil {
		if utf8.RuneCountInString(*body.AzureEndpoint) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_endpoint", *body.AzureEndpoint, utf8.RuneCountInString(*body.AzureEndpoint), 3, true))
		}
	}
	if body.AzureEndpoint != nil {
		if utf8.RuneCountInString(*body.AzureEndpoint) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_endpoint", *body.AzureEndpoint, utf8.RuneCountInString(*body.AzureEndpoint), 128, false))
		}
	}
	if body.AzureKey != nil {
		if utf8.RuneCountInString(*body.AzureKey) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.azure_key", *body.AzureKey, utf8.RuneCountInString(*body.AzureKey), 128, false))
		}
	}
	if body.BasePath != nil {
		if utf8.RuneCountInString(*body.BasePath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.base_path", *body.BasePath, utf8.RuneCountInString(*body.BasePath), 256, false))
		}
	}
	return
}

// ValidateOrchestratorOptsRequestBodyRequestBody runs the validations defined
// on OrchestratorOptsRequestBodyRequestBody
func ValidateOrchestratorOptsRequestBodyRequestBody(body *OrchestratorOptsRequestBodyRequestBody) (err error) {
	if body.Swarm != nil {
		if err2 := ValidateSwarmOptsRequestBodyRequestBody(body.Swarm); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateSwarmOptsRequestBodyRequestBody runs the validations defined on
// SwarmOptsRequestBodyRequestBody
func ValidateSwarmOptsRequestBodyRequestBody(body *SwarmOptsRequestBodyRequestBody) (err error) {
	if len(body.ExtraVolumes) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.extra_volumes", body.ExtraVolumes, len(body.ExtraVolumes), 16, false))
	}
	for _, e := range body.ExtraVolumes {
		if e != nil {
			if err2 := ValidateExtraVolumesSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if len(body.ExtraNetworks) > 8 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.extra_networks", body.ExtraNetworks, len(body.ExtraNetworks), 8, false))
	}
	for _, e := range body.ExtraNetworks {
		if e != nil {
			if err2 := ValidateExtraNetworkSpecRequestBodyRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateExtraVolumesSpecRequestBodyRequestBody runs the validations defined
// on ExtraVolumesSpecRequestBodyRequestBody
func ValidateExtraVolumesSpecRequestBodyRequestBody(body *ExtraVolumesSpecRequestBodyRequestBody) (err error) {
	if body.HostPath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("host_path", "body"))
	}
	if body.DestinationPath == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("destination_path", "body"))
	}
	if body.HostPath != nil {
		if utf8.RuneCountInString(*body.HostPath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.host_path", *body.HostPath, utf8.RuneCountInString(*body.HostPath), 256, false))
		}
	}
	if body.DestinationPath != nil {
		if utf8.RuneCountInString(*body.DestinationPath) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.destination_path", *body.DestinationPath, utf8.RuneCountInString(*body.DestinationPath), 256, false))
		}
	}
	return
}

// ValidateExtraNetworkSpecRequestBodyRequestBody runs the validations defined
// on ExtraNetworkSpecRequestBodyRequestBody
func ValidateExtraNetworkSpecRequestBodyRequestBody(body *ExtraNetworkSpecRequestBodyRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if len(body.Aliases) > 8 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.aliases", body.Aliases, len(body.Aliases), 8, false))
	}
	return
}

// ValidateDatabaseUserSpecRequestBodyRequestBody runs the validations defined
// on DatabaseUserSpecRequestBodyRequestBody
func ValidateDatabaseUserSpecRequestBodyRequestBody(body *DatabaseUserSpecRequestBodyRequestBody) (err error) {
	if body.Username == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("username", "body"))
	}
	if body.Username != nil {
		if utf8.RuneCountInString(*body.Username) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.username", *body.Username, utf8.RuneCountInString(*body.Username), 1, true))
		}
	}
	if body.Password != nil {
		if utf8.RuneCountInString(*body.Password) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.password", *body.Password, utf8.RuneCountInString(*body.Password), 1, true))
		}
	}
	if len(body.Attributes) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.attributes", body.Attributes, len(body.Attributes), 16, false))
	}
	if len(body.Roles) > 16 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.roles", body.Roles, len(body.Roles), 16, false))
	}
	return
}
