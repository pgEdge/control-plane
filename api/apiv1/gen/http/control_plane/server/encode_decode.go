// Code generated by goa v3.23.4, DO NOT EDIT.
//
// control-plane HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/pgEdge/control-plane/api/apiv1/design -o apiv1

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"
	"unicode/utf8"

	controlplane "github.com/pgEdge/control-plane/api/apiv1/gen/control_plane"
	controlplaneviews "github.com/pgEdge/control-plane/api/apiv1/gen/control_plane/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeInitClusterResponse returns an encoder for responses returned by the
// control-plane init-cluster endpoint.
func EncodeInitClusterResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ClusterJoinToken)
		enc := encoder(ctx, w)
		body := NewInitClusterResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeInitClusterRequest returns a decoder for requests sent to the
// control-plane init-cluster endpoint.
func DecodeInitClusterRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.InitClusterRequest, error) {
	return func(r *http.Request) (*controlplane.InitClusterRequest, error) {
		var (
			clusterID *string
			err       error
		)
		clusterIDRaw := r.URL.Query().Get("cluster_id")
		if clusterIDRaw != "" {
			clusterID = &clusterIDRaw
		}
		if clusterID != nil {
			if utf8.RuneCountInString(*clusterID) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("cluster_id", *clusterID, utf8.RuneCountInString(*clusterID), 1, true))
			}
		}
		if clusterID != nil {
			if utf8.RuneCountInString(*clusterID) > 63 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("cluster_id", *clusterID, utf8.RuneCountInString(*clusterID), 63, false))
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewInitClusterRequest(clusterID)

		return payload, nil
	}
}

// EncodeInitClusterError returns an encoder for errors returned by the
// init-cluster control-plane endpoint.
func EncodeInitClusterError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_already_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInitClusterClusterAlreadyInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "operation_not_supported":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInitClusterOperationNotSupportedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewInitClusterServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeJoinClusterResponse returns an encoder for responses returned by the
// control-plane join-cluster endpoint.
func EncodeJoinClusterResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeJoinClusterRequest returns a decoder for requests sent to the
// control-plane join-cluster endpoint.
func DecodeJoinClusterRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.ClusterJoinToken, error) {
	return func(r *http.Request) (*controlplane.ClusterJoinToken, error) {
		var (
			body JoinClusterRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateJoinClusterRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewJoinClusterClusterJoinToken(&body)

		return payload, nil
	}
}

// EncodeJoinClusterError returns an encoder for errors returned by the
// join-cluster control-plane endpoint.
func EncodeJoinClusterError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_already_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewJoinClusterClusterAlreadyInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_join_token":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewJoinClusterInvalidJoinTokenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewJoinClusterInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewJoinClusterServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetJoinTokenResponse returns an encoder for responses returned by the
// control-plane get-join-token endpoint.
func EncodeGetJoinTokenResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ClusterJoinToken)
		enc := encoder(ctx, w)
		body := NewGetJoinTokenResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeGetJoinTokenError returns an encoder for errors returned by the
// get-join-token control-plane endpoint.
func EncodeGetJoinTokenError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetJoinTokenClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetJoinTokenServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetJoinOptionsResponse returns an encoder for responses returned by
// the control-plane get-join-options endpoint.
func EncodeGetJoinOptionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ClusterJoinOptions)
		enc := encoder(ctx, w)
		body := NewGetJoinOptionsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetJoinOptionsRequest returns a decoder for requests sent to the
// control-plane get-join-options endpoint.
func DecodeGetJoinOptionsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.ClusterJoinRequest, error) {
	return func(r *http.Request) (*controlplane.ClusterJoinRequest, error) {
		var (
			body GetJoinOptionsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateGetJoinOptionsRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewGetJoinOptionsClusterJoinRequest(&body)

		return payload, nil
	}
}

// EncodeGetJoinOptionsError returns an encoder for errors returned by the
// get-join-options control-plane endpoint.
func EncodeGetJoinOptionsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetJoinOptionsClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_join_token":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetJoinOptionsInvalidJoinTokenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetJoinOptionsInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetJoinOptionsServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetClusterResponse returns an encoder for responses returned by the
// control-plane get-cluster endpoint.
func EncodeGetClusterResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Cluster)
		enc := encoder(ctx, w)
		body := NewGetClusterResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeGetClusterError returns an encoder for errors returned by the
// get-cluster control-plane endpoint.
func EncodeGetClusterError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetClusterClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetClusterServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListHostsResponse returns an encoder for responses returned by the
// control-plane list-hosts endpoint.
func EncodeListHostsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ListHostsResponse)
		enc := encoder(ctx, w)
		body := NewListHostsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeListHostsError returns an encoder for errors returned by the
// list-hosts control-plane endpoint.
func EncodeListHostsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListHostsClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListHostsServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetHostResponse returns an encoder for responses returned by the
// control-plane get-host endpoint.
func EncodeGetHostResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Host)
		enc := encoder(ctx, w)
		body := NewGetHostResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetHostRequest returns a decoder for requests sent to the
// control-plane get-host endpoint.
func DecodeGetHostRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.GetHostPayload, error) {
	return func(r *http.Request) (*controlplane.GetHostPayload, error) {
		var (
			hostID string
			err    error

			params = mux.Vars(r)
		)
		hostID = params["host_id"]
		if utf8.RuneCountInString(hostID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 1, true))
		}
		if utf8.RuneCountInString(hostID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 63, false))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetHostPayload(hostID)

		return payload, nil
	}
}

// EncodeGetHostError returns an encoder for errors returned by the get-host
// control-plane endpoint.
func EncodeGetHostError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRemoveHostResponse returns an encoder for responses returned by the
// control-plane remove-host endpoint.
func EncodeRemoveHostResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.RemoveHostResponse)
		enc := encoder(ctx, w)
		body := NewRemoveHostResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeRemoveHostRequest returns a decoder for requests sent to the
// control-plane remove-host endpoint.
func DecodeRemoveHostRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.RemoveHostPayload, error) {
	return func(r *http.Request) (*controlplane.RemoveHostPayload, error) {
		var (
			hostID string
			force  bool
			err    error

			params = mux.Vars(r)
		)
		hostID = params["host_id"]
		if utf8.RuneCountInString(hostID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 1, true))
		}
		if utf8.RuneCountInString(hostID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 63, false))
		}
		{
			forceRaw := r.URL.Query().Get("force")
			if forceRaw != "" {
				v, err2 := strconv.ParseBool(forceRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("force", forceRaw, "boolean"))
				}
				force = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewRemoveHostPayload(hostID, force)

		return payload, nil
	}
}

// EncodeRemoveHostError returns an encoder for errors returned by the
// remove-host control-plane endpoint.
func EncodeRemoveHostError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveHostClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveHostInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveHostNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveHostServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListDatabasesResponse returns an encoder for responses returned by the
// control-plane list-databases endpoint.
func EncodeListDatabasesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*controlplaneviews.ListDatabasesResponse)
		enc := encoder(ctx, w)
		body := NewListDatabasesResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeListDatabasesError returns an encoder for errors returned by the
// list-databases control-plane endpoint.
func EncodeListDatabasesError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListDatabasesClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListDatabasesServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateDatabaseResponse returns an encoder for responses returned by
// the control-plane create-database endpoint.
func EncodeCreateDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.CreateDatabaseResponse)
		enc := encoder(ctx, w)
		body := NewCreateDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreateDatabaseRequest returns a decoder for requests sent to the
// control-plane create-database endpoint.
func DecodeCreateDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.CreateDatabaseRequest, error) {
	return func(r *http.Request) (*controlplane.CreateDatabaseRequest, error) {
		var (
			body CreateDatabaseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateDatabaseRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewCreateDatabaseRequest(&body)

		return payload, nil
	}
}

// EncodeCreateDatabaseError returns an encoder for errors returned by the
// create-database control-plane endpoint.
func EncodeCreateDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "database_already_exists":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateDatabaseDatabaseAlreadyExistsResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "operation_already_in_progress":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateDatabaseOperationAlreadyInProgressResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateDatabaseInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateDatabaseServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetDatabaseResponse returns an encoder for responses returned by the
// control-plane get-database endpoint.
func EncodeGetDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*controlplaneviews.Database)
		enc := encoder(ctx, w)
		body := NewGetDatabaseResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetDatabaseRequest returns a decoder for requests sent to the
// control-plane get-database endpoint.
func DecodeGetDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.GetDatabasePayload, error) {
	return func(r *http.Request) (*controlplane.GetDatabasePayload, error) {
		var (
			databaseID string
			err        error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetDatabasePayload(databaseID)

		return payload, nil
	}
}

// EncodeGetDatabaseError returns an encoder for errors returned by the
// get-database control-plane endpoint.
func EncodeGetDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateDatabaseResponse returns an encoder for responses returned by
// the control-plane update-database endpoint.
func EncodeUpdateDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.UpdateDatabaseResponse)
		enc := encoder(ctx, w)
		body := NewUpdateDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateDatabaseRequest returns a decoder for requests sent to the
// control-plane update-database endpoint.
func DecodeUpdateDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.UpdateDatabasePayload, error) {
	return func(r *http.Request) (*controlplane.UpdateDatabasePayload, error) {
		var (
			body UpdateDatabaseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateDatabaseRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			databaseID  string
			forceUpdate bool

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		{
			forceUpdateRaw := r.URL.Query().Get("force_update")
			if forceUpdateRaw != "" {
				v, err2 := strconv.ParseBool(forceUpdateRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("force_update", forceUpdateRaw, "boolean"))
				}
				forceUpdate = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateDatabasePayload(&body, databaseID, forceUpdate)

		return payload, nil
	}
}

// EncodeUpdateDatabaseError returns an encoder for errors returned by the
// update-database control-plane endpoint.
func EncodeUpdateDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateDatabaseDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "operation_already_in_progress":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateDatabaseOperationAlreadyInProgressResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateDatabaseInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateDatabaseNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateDatabaseServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteDatabaseResponse returns an encoder for responses returned by
// the control-plane delete-database endpoint.
func EncodeDeleteDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.DeleteDatabaseResponse)
		enc := encoder(ctx, w)
		body := NewDeleteDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDeleteDatabaseRequest returns a decoder for requests sent to the
// control-plane delete-database endpoint.
func DecodeDeleteDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.DeleteDatabasePayload, error) {
	return func(r *http.Request) (*controlplane.DeleteDatabasePayload, error) {
		var (
			databaseID string
			force      bool
			err        error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		{
			forceRaw := r.URL.Query().Get("force")
			if forceRaw != "" {
				v, err2 := strconv.ParseBool(forceRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("force", forceRaw, "boolean"))
				}
				force = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteDatabasePayload(databaseID, force)

		return payload, nil
	}
}

// EncodeDeleteDatabaseError returns an encoder for errors returned by the
// delete-database control-plane endpoint.
func EncodeDeleteDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteDatabaseDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "operation_already_in_progress":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteDatabaseOperationAlreadyInProgressResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteDatabaseInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteDatabaseNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteDatabaseServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeBackupDatabaseNodeResponse returns an encoder for responses returned
// by the control-plane backup-database-node endpoint.
func EncodeBackupDatabaseNodeResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.BackupDatabaseNodeResponse)
		enc := encoder(ctx, w)
		body := NewBackupDatabaseNodeResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeBackupDatabaseNodeRequest returns a decoder for requests sent to the
// control-plane backup-database-node endpoint.
func DecodeBackupDatabaseNodeRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.BackupDatabaseNodePayload, error) {
	return func(r *http.Request) (*controlplane.BackupDatabaseNodePayload, error) {
		var (
			body BackupDatabaseNodeRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateBackupDatabaseNodeRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			databaseID string
			nodeName   string
			force      bool

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		nodeName = params["node_name"]
		err = goa.MergeErrors(err, goa.ValidatePattern("node_name", nodeName, "n[0-9]+"))
		{
			forceRaw := r.URL.Query().Get("force")
			if forceRaw != "" {
				v, err2 := strconv.ParseBool(forceRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("force", forceRaw, "boolean"))
				}
				force = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewBackupDatabaseNodePayload(&body, databaseID, nodeName, force)

		return payload, nil
	}
}

// EncodeBackupDatabaseNodeError returns an encoder for errors returned by the
// backup-database-node control-plane endpoint.
func EncodeBackupDatabaseNodeError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "operation_already_in_progress":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeOperationAlreadyInProgressResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewBackupDatabaseNodeServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeSwitchoverDatabaseNodeResponse returns an encoder for responses
// returned by the control-plane switchover-database-node endpoint.
func EncodeSwitchoverDatabaseNodeResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.SwitchoverDatabaseNodeResponse)
		enc := encoder(ctx, w)
		body := NewSwitchoverDatabaseNodeResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSwitchoverDatabaseNodeRequest returns a decoder for requests sent to
// the control-plane switchover-database-node endpoint.
func DecodeSwitchoverDatabaseNodeRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.SwitchoverDatabaseNodePayload, error) {
	return func(r *http.Request) (*controlplane.SwitchoverDatabaseNodePayload, error) {
		var (
			body SwitchoverDatabaseNodeRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateSwitchoverDatabaseNodeRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			databaseID string
			nodeName   string

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		nodeName = params["node_name"]
		err = goa.MergeErrors(err, goa.ValidatePattern("node_name", nodeName, "n[0-9]+"))
		if err != nil {
			return nil, err
		}
		payload := NewSwitchoverDatabaseNodePayload(&body, databaseID, nodeName)

		return payload, nil
	}
}

// EncodeSwitchoverDatabaseNodeError returns an encoder for errors returned by
// the switchover-database-node control-plane endpoint.
func EncodeSwitchoverDatabaseNodeError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSwitchoverDatabaseNodeClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSwitchoverDatabaseNodeDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "operation_already_in_progress":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSwitchoverDatabaseNodeOperationAlreadyInProgressResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSwitchoverDatabaseNodeInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSwitchoverDatabaseNodeNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSwitchoverDatabaseNodeServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeFailoverDatabaseNodeResponse returns an encoder for responses returned
// by the control-plane failover-database-node endpoint.
func EncodeFailoverDatabaseNodeResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.FailoverDatabaseNodeResponse)
		enc := encoder(ctx, w)
		body := NewFailoverDatabaseNodeResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeFailoverDatabaseNodeRequest returns a decoder for requests sent to the
// control-plane failover-database-node endpoint.
func DecodeFailoverDatabaseNodeRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.FailoverDatabaseNodeRequest, error) {
	return func(r *http.Request) (*controlplane.FailoverDatabaseNodeRequest, error) {
		var (
			body FailoverDatabaseNodeRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}

		var (
			databaseID string
			nodeName   string

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		nodeName = params["node_name"]
		err = goa.MergeErrors(err, goa.ValidatePattern("node_name", nodeName, "n[0-9]+"))
		if err != nil {
			return nil, err
		}
		payload := NewFailoverDatabaseNodeRequest(&body, databaseID, nodeName)

		return payload, nil
	}
}

// EncodeFailoverDatabaseNodeError returns an encoder for errors returned by
// the failover-database-node control-plane endpoint.
func EncodeFailoverDatabaseNodeError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewFailoverDatabaseNodeClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewFailoverDatabaseNodeDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "operation_already_in_progress":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewFailoverDatabaseNodeOperationAlreadyInProgressResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewFailoverDatabaseNodeInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewFailoverDatabaseNodeNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewFailoverDatabaseNodeServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListDatabaseTasksResponse returns an encoder for responses returned by
// the control-plane list-database-tasks endpoint.
func EncodeListDatabaseTasksResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ListDatabaseTasksResponse)
		enc := encoder(ctx, w)
		body := NewListDatabaseTasksResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListDatabaseTasksRequest returns a decoder for requests sent to the
// control-plane list-database-tasks endpoint.
func DecodeListDatabaseTasksRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.ListDatabaseTasksPayload, error) {
	return func(r *http.Request) (*controlplane.ListDatabaseTasksPayload, error) {
		var (
			databaseID  string
			afterTaskID *string
			limit       *int
			sortOrder   *string
			err         error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		qp := r.URL.Query()
		afterTaskIDRaw := qp.Get("after_task_id")
		if afterTaskIDRaw != "" {
			afterTaskID = &afterTaskIDRaw
		}
		if afterTaskID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("after_task_id", *afterTaskID, goa.FormatUUID))
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw != "" {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				pv := int(v)
				limit = &pv
			}
		}
		sortOrderRaw := qp.Get("sort_order")
		if sortOrderRaw != "" {
			sortOrder = &sortOrderRaw
		}
		if sortOrder != nil {
			if !(*sortOrder == "asc" || *sortOrder == "ascend" || *sortOrder == "ascending" || *sortOrder == "desc" || *sortOrder == "descend" || *sortOrder == "descending") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort_order", *sortOrder, []any{"asc", "ascend", "ascending", "desc", "descend", "descending"}))
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewListDatabaseTasksPayload(databaseID, afterTaskID, limit, sortOrder)

		return payload, nil
	}
}

// EncodeListDatabaseTasksError returns an encoder for errors returned by the
// list-database-tasks control-plane endpoint.
func EncodeListDatabaseTasksError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListDatabaseTasksClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListDatabaseTasksInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListDatabaseTasksNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListDatabaseTasksServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetDatabaseTaskResponse returns an encoder for responses returned by
// the control-plane get-database-task endpoint.
func EncodeGetDatabaseTaskResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Task)
		enc := encoder(ctx, w)
		body := NewGetDatabaseTaskResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetDatabaseTaskRequest returns a decoder for requests sent to the
// control-plane get-database-task endpoint.
func DecodeGetDatabaseTaskRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.GetDatabaseTaskPayload, error) {
	return func(r *http.Request) (*controlplane.GetDatabaseTaskPayload, error) {
		var (
			databaseID string
			taskID     string
			err        error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		taskID = params["task_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("task_id", taskID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
		payload := NewGetDatabaseTaskPayload(databaseID, taskID)

		return payload, nil
	}
}

// EncodeGetDatabaseTaskError returns an encoder for errors returned by the
// get-database-task control-plane endpoint.
func EncodeGetDatabaseTaskError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetDatabaseTaskLogResponse returns an encoder for responses returned
// by the control-plane get-database-task-log endpoint.
func EncodeGetDatabaseTaskLogResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.TaskLog)
		enc := encoder(ctx, w)
		body := NewGetDatabaseTaskLogResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetDatabaseTaskLogRequest returns a decoder for requests sent to the
// control-plane get-database-task-log endpoint.
func DecodeGetDatabaseTaskLogRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.GetDatabaseTaskLogPayload, error) {
	return func(r *http.Request) (*controlplane.GetDatabaseTaskLogPayload, error) {
		var (
			databaseID   string
			taskID       string
			afterEntryID *string
			limit        *int
			err          error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		taskID = params["task_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("task_id", taskID, goa.FormatUUID))
		qp := r.URL.Query()
		afterEntryIDRaw := qp.Get("after_entry_id")
		if afterEntryIDRaw != "" {
			afterEntryID = &afterEntryIDRaw
		}
		if afterEntryID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("after_entry_id", *afterEntryID, goa.FormatUUID))
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw != "" {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				pv := int(v)
				limit = &pv
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetDatabaseTaskLogPayload(databaseID, taskID, afterEntryID, limit)

		return payload, nil
	}
}

// EncodeGetDatabaseTaskLogError returns an encoder for errors returned by the
// get-database-task-log control-plane endpoint.
func EncodeGetDatabaseTaskLogError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskLogClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskLogInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskLogNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDatabaseTaskLogServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListHostTasksResponse returns an encoder for responses returned by the
// control-plane list-host-tasks endpoint.
func EncodeListHostTasksResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ListHostTasksResponse)
		enc := encoder(ctx, w)
		body := NewListHostTasksResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListHostTasksRequest returns a decoder for requests sent to the
// control-plane list-host-tasks endpoint.
func DecodeListHostTasksRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.ListHostTasksPayload, error) {
	return func(r *http.Request) (*controlplane.ListHostTasksPayload, error) {
		var (
			hostID      string
			afterTaskID *string
			limit       *int
			sortOrder   *string
			err         error

			params = mux.Vars(r)
		)
		hostID = params["host_id"]
		if utf8.RuneCountInString(hostID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 1, true))
		}
		if utf8.RuneCountInString(hostID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 63, false))
		}
		qp := r.URL.Query()
		afterTaskIDRaw := qp.Get("after_task_id")
		if afterTaskIDRaw != "" {
			afterTaskID = &afterTaskIDRaw
		}
		if afterTaskID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("after_task_id", *afterTaskID, goa.FormatUUID))
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw != "" {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				pv := int(v)
				limit = &pv
			}
		}
		sortOrderRaw := qp.Get("sort_order")
		if sortOrderRaw != "" {
			sortOrder = &sortOrderRaw
		}
		if sortOrder != nil {
			if !(*sortOrder == "asc" || *sortOrder == "ascend" || *sortOrder == "ascending" || *sortOrder == "desc" || *sortOrder == "descend" || *sortOrder == "descending") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort_order", *sortOrder, []any{"asc", "ascend", "ascending", "desc", "descend", "descending"}))
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewListHostTasksPayload(hostID, afterTaskID, limit, sortOrder)

		return payload, nil
	}
}

// EncodeListHostTasksError returns an encoder for errors returned by the
// list-host-tasks control-plane endpoint.
func EncodeListHostTasksError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListHostTasksClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListHostTasksInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListHostTasksNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListHostTasksServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetHostTaskResponse returns an encoder for responses returned by the
// control-plane get-host-task endpoint.
func EncodeGetHostTaskResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Task)
		enc := encoder(ctx, w)
		body := NewGetHostTaskResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetHostTaskRequest returns a decoder for requests sent to the
// control-plane get-host-task endpoint.
func DecodeGetHostTaskRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.GetHostTaskPayload, error) {
	return func(r *http.Request) (*controlplane.GetHostTaskPayload, error) {
		var (
			hostID string
			taskID string
			err    error

			params = mux.Vars(r)
		)
		hostID = params["host_id"]
		if utf8.RuneCountInString(hostID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 1, true))
		}
		if utf8.RuneCountInString(hostID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 63, false))
		}
		taskID = params["task_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("task_id", taskID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
		payload := NewGetHostTaskPayload(hostID, taskID)

		return payload, nil
	}
}

// EncodeGetHostTaskError returns an encoder for errors returned by the
// get-host-task control-plane endpoint.
func EncodeGetHostTaskError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostTaskClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostTaskInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostTaskNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostTaskServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetHostTaskLogResponse returns an encoder for responses returned by
// the control-plane get-host-task-log endpoint.
func EncodeGetHostTaskLogResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.TaskLog)
		enc := encoder(ctx, w)
		body := NewGetHostTaskLogResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetHostTaskLogRequest returns a decoder for requests sent to the
// control-plane get-host-task-log endpoint.
func DecodeGetHostTaskLogRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.GetHostTaskLogPayload, error) {
	return func(r *http.Request) (*controlplane.GetHostTaskLogPayload, error) {
		var (
			hostID       string
			taskID       string
			afterEntryID *string
			limit        *int
			err          error

			params = mux.Vars(r)
		)
		hostID = params["host_id"]
		if utf8.RuneCountInString(hostID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 1, true))
		}
		if utf8.RuneCountInString(hostID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("host_id", hostID, utf8.RuneCountInString(hostID), 63, false))
		}
		taskID = params["task_id"]
		err = goa.MergeErrors(err, goa.ValidateFormat("task_id", taskID, goa.FormatUUID))
		qp := r.URL.Query()
		afterEntryIDRaw := qp.Get("after_entry_id")
		if afterEntryIDRaw != "" {
			afterEntryID = &afterEntryIDRaw
		}
		if afterEntryID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("after_entry_id", *afterEntryID, goa.FormatUUID))
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw != "" {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				pv := int(v)
				limit = &pv
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetHostTaskLogPayload(hostID, taskID, afterEntryID, limit)

		return payload, nil
	}
}

// EncodeGetHostTaskLogError returns an encoder for errors returned by the
// get-host-task-log control-plane endpoint.
func EncodeGetHostTaskLogError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostTaskLogClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostTaskLogInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostTaskLogNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetHostTaskLogServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListTasksResponse returns an encoder for responses returned by the
// control-plane list-tasks endpoint.
func EncodeListTasksResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.ListTasksResponse)
		enc := encoder(ctx, w)
		body := NewListTasksResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListTasksRequest returns a decoder for requests sent to the
// control-plane list-tasks endpoint.
func DecodeListTasksRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.ListTasksPayload, error) {
	return func(r *http.Request) (*controlplane.ListTasksPayload, error) {
		var (
			scope       *string
			entityID    *string
			afterTaskID *string
			limit       *int
			sortOrder   *string
			err         error
		)
		qp := r.URL.Query()
		scopeRaw := qp.Get("scope")
		if scopeRaw != "" {
			scope = &scopeRaw
		}
		if scope != nil {
			if !(*scope == "database" || *scope == "host") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("scope", *scope, []any{"database", "host"}))
			}
		}
		entityIDRaw := qp.Get("entity_id")
		if entityIDRaw != "" {
			entityID = &entityIDRaw
		}
		if entityID != nil {
			if utf8.RuneCountInString(*entityID) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("entity_id", *entityID, utf8.RuneCountInString(*entityID), 1, true))
			}
		}
		if entityID != nil {
			if utf8.RuneCountInString(*entityID) > 63 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("entity_id", *entityID, utf8.RuneCountInString(*entityID), 63, false))
			}
		}
		afterTaskIDRaw := qp.Get("after_task_id")
		if afterTaskIDRaw != "" {
			afterTaskID = &afterTaskIDRaw
		}
		if afterTaskID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("after_task_id", *afterTaskID, goa.FormatUUID))
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw != "" {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				pv := int(v)
				limit = &pv
			}
		}
		sortOrderRaw := qp.Get("sort_order")
		if sortOrderRaw != "" {
			sortOrder = &sortOrderRaw
		}
		if sortOrder != nil {
			if !(*sortOrder == "asc" || *sortOrder == "ascend" || *sortOrder == "ascending" || *sortOrder == "desc" || *sortOrder == "descend" || *sortOrder == "descending") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort_order", *sortOrder, []any{"asc", "ascend", "ascending", "desc", "descend", "descending"}))
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewListTasksPayload(scope, entityID, afterTaskID, limit, sortOrder)

		return payload, nil
	}
}

// EncodeListTasksError returns an encoder for errors returned by the
// list-tasks control-plane endpoint.
func EncodeListTasksError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListTasksClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListTasksInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListTasksServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRestoreDatabaseResponse returns an encoder for responses returned by
// the control-plane restore-database endpoint.
func EncodeRestoreDatabaseResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.RestoreDatabaseResponse)
		enc := encoder(ctx, w)
		body := NewRestoreDatabaseResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeRestoreDatabaseRequest returns a decoder for requests sent to the
// control-plane restore-database endpoint.
func DecodeRestoreDatabaseRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.RestoreDatabasePayload, error) {
	return func(r *http.Request) (*controlplane.RestoreDatabasePayload, error) {
		var (
			body RestoreDatabaseRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateRestoreDatabaseRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			databaseID string
			force      bool

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		{
			forceRaw := r.URL.Query().Get("force")
			if forceRaw != "" {
				v, err2 := strconv.ParseBool(forceRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("force", forceRaw, "boolean"))
				}
				force = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewRestoreDatabasePayload(&body, databaseID, force)

		return payload, nil
	}
}

// EncodeRestoreDatabaseError returns an encoder for errors returned by the
// restore-database control-plane endpoint.
func EncodeRestoreDatabaseError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "database_not_modifiable":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseDatabaseNotModifiableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "operation_already_in_progress":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseOperationAlreadyInProgressResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreDatabaseServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetVersionResponse returns an encoder for responses returned by the
// control-plane get-version endpoint.
func EncodeGetVersionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.VersionInfo)
		enc := encoder(ctx, w)
		body := NewGetVersionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeGetVersionError returns an encoder for errors returned by the
// get-version control-plane endpoint.
func EncodeGetVersionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetVersionServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRestartInstanceResponse returns an encoder for responses returned by
// the control-plane restart-instance endpoint.
func EncodeRestartInstanceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.RestartInstanceResponse)
		enc := encoder(ctx, w)
		body := NewRestartInstanceResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeRestartInstanceRequest returns a decoder for requests sent to the
// control-plane restart-instance endpoint.
func DecodeRestartInstanceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.RestartInstancePayload, error) {
	return func(r *http.Request) (*controlplane.RestartInstancePayload, error) {
		var (
			body struct {
				// The time at which the restart is scheduled.
				ScheduledAt *string `form:"scheduled_at" json:"scheduled_at" xml:"scheduled_at"`
			}
			err error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		if body.ScheduledAt != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.scheduled_at", *body.ScheduledAt, goa.FormatDateTime))
		}
		if err != nil {
			return nil, err
		}

		var (
			databaseID string
			instanceID string

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		instanceID = params["instance_id"]
		if utf8.RuneCountInString(instanceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("instance_id", instanceID, utf8.RuneCountInString(instanceID), 1, true))
		}
		if utf8.RuneCountInString(instanceID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("instance_id", instanceID, utf8.RuneCountInString(instanceID), 63, false))
		}
		if err != nil {
			return nil, err
		}
		payload := NewRestartInstancePayload(body, databaseID, instanceID)

		return payload, nil
	}
}

// EncodeRestartInstanceError returns an encoder for errors returned by the
// restart-instance control-plane endpoint.
func EncodeRestartInstanceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestartInstanceClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestartInstanceInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestartInstanceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestartInstanceServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeStopInstanceResponse returns an encoder for responses returned by the
// control-plane stop-instance endpoint.
func EncodeStopInstanceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.StopInstanceResponse)
		enc := encoder(ctx, w)
		body := NewStopInstanceResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeStopInstanceRequest returns a decoder for requests sent to the
// control-plane stop-instance endpoint.
func DecodeStopInstanceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.StopInstancePayload, error) {
	return func(r *http.Request) (*controlplane.StopInstancePayload, error) {
		var (
			databaseID string
			instanceID string
			force      bool
			err        error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		instanceID = params["instance_id"]
		if utf8.RuneCountInString(instanceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("instance_id", instanceID, utf8.RuneCountInString(instanceID), 1, true))
		}
		if utf8.RuneCountInString(instanceID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("instance_id", instanceID, utf8.RuneCountInString(instanceID), 63, false))
		}
		{
			forceRaw := r.URL.Query().Get("force")
			if forceRaw != "" {
				v, err2 := strconv.ParseBool(forceRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("force", forceRaw, "boolean"))
				}
				force = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewStopInstancePayload(databaseID, instanceID, force)

		return payload, nil
	}
}

// EncodeStopInstanceError returns an encoder for errors returned by the
// stop-instance control-plane endpoint.
func EncodeStopInstanceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStopInstanceClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStopInstanceInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStopInstanceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStopInstanceServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeStartInstanceResponse returns an encoder for responses returned by the
// control-plane start-instance endpoint.
func EncodeStartInstanceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.StartInstanceResponse)
		enc := encoder(ctx, w)
		body := NewStartInstanceResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeStartInstanceRequest returns a decoder for requests sent to the
// control-plane start-instance endpoint.
func DecodeStartInstanceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.StartInstancePayload, error) {
	return func(r *http.Request) (*controlplane.StartInstancePayload, error) {
		var (
			databaseID string
			instanceID string
			force      bool
			err        error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		instanceID = params["instance_id"]
		if utf8.RuneCountInString(instanceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("instance_id", instanceID, utf8.RuneCountInString(instanceID), 1, true))
		}
		if utf8.RuneCountInString(instanceID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("instance_id", instanceID, utf8.RuneCountInString(instanceID), 63, false))
		}
		{
			forceRaw := r.URL.Query().Get("force")
			if forceRaw != "" {
				v, err2 := strconv.ParseBool(forceRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("force", forceRaw, "boolean"))
				}
				force = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewStartInstancePayload(databaseID, instanceID, force)

		return payload, nil
	}
}

// EncodeStartInstanceError returns an encoder for errors returned by the
// start-instance control-plane endpoint.
func EncodeStartInstanceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "cluster_not_initialized":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStartInstanceClusterNotInitializedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStartInstanceInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStartInstanceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStartInstanceServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCancelDatabaseTaskResponse returns an encoder for responses returned
// by the control-plane cancel-database-task endpoint.
func EncodeCancelDatabaseTaskResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*controlplane.Task)
		enc := encoder(ctx, w)
		body := NewCancelDatabaseTaskResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCancelDatabaseTaskRequest returns a decoder for requests sent to the
// control-plane cancel-database-task endpoint.
func DecodeCancelDatabaseTaskRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*controlplane.CancelDatabaseTaskPayload, error) {
	return func(r *http.Request) (*controlplane.CancelDatabaseTaskPayload, error) {
		var (
			databaseID string
			taskID     string
			err        error

			params = mux.Vars(r)
		)
		databaseID = params["database_id"]
		if utf8.RuneCountInString(databaseID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 1, true))
		}
		if utf8.RuneCountInString(databaseID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("database_id", databaseID, utf8.RuneCountInString(databaseID), 63, false))
		}
		taskID = params["task_id"]
		if utf8.RuneCountInString(taskID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("task_id", taskID, utf8.RuneCountInString(taskID), 1, true))
		}
		if utf8.RuneCountInString(taskID) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("task_id", taskID, utf8.RuneCountInString(taskID), 63, false))
		}
		if err != nil {
			return nil, err
		}
		payload := NewCancelDatabaseTaskPayload(databaseID, taskID)

		return payload, nil
	}
}

// EncodeCancelDatabaseTaskError returns an encoder for errors returned by the
// cancel-database-task control-plane endpoint.
func EncodeCancelDatabaseTaskError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "not_found":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCancelDatabaseTaskNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "invalid_input":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCancelDatabaseTaskInvalidInputResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "server_error":
			var res *controlplane.APIError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCancelDatabaseTaskServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalControlplaneEtcdClusterMemberToEtcdClusterMemberResponseBody builds a
// value of type *EtcdClusterMemberResponseBody from a value of type
// *controlplane.EtcdClusterMember.
func marshalControlplaneEtcdClusterMemberToEtcdClusterMemberResponseBody(v *controlplane.EtcdClusterMember) *EtcdClusterMemberResponseBody {
	res := &EtcdClusterMemberResponseBody{
		Name: v.Name,
	}
	if v.PeerUrls != nil {
		res.PeerUrls = make([]string, len(v.PeerUrls))
		for i, val := range v.PeerUrls {
			res.PeerUrls[i] = val
		}
	} else {
		res.PeerUrls = []string{}
	}
	if v.ClientUrls != nil {
		res.ClientUrls = make([]string, len(v.ClientUrls))
		for i, val := range v.ClientUrls {
			res.ClientUrls[i] = val
		}
	} else {
		res.ClientUrls = []string{}
	}

	return res
}

// marshalControlplaneClusterCredentialsToClusterCredentialsResponseBody builds
// a value of type *ClusterCredentialsResponseBody from a value of type
// *controlplane.ClusterCredentials.
func marshalControlplaneClusterCredentialsToClusterCredentialsResponseBody(v *controlplane.ClusterCredentials) *ClusterCredentialsResponseBody {
	res := &ClusterCredentialsResponseBody{
		Username:   v.Username,
		Password:   v.Password,
		CaCert:     v.CaCert,
		ClientCert: v.ClientCert,
		ClientKey:  v.ClientKey,
		ServerCert: v.ServerCert,
		ServerKey:  v.ServerKey,
	}

	return res
}

// marshalControlplaneClusterStatusToClusterStatusResponseBody builds a value
// of type *ClusterStatusResponseBody from a value of type
// *controlplane.ClusterStatus.
func marshalControlplaneClusterStatusToClusterStatusResponseBody(v *controlplane.ClusterStatus) *ClusterStatusResponseBody {
	res := &ClusterStatusResponseBody{
		State: v.State,
	}

	return res
}

// marshalControlplaneHostToHostResponseBody builds a value of type
// *HostResponseBody from a value of type *controlplane.Host.
func marshalControlplaneHostToHostResponseBody(v *controlplane.Host) *HostResponseBody {
	res := &HostResponseBody{
		ID:           string(v.ID),
		Orchestrator: v.Orchestrator,
		DataDir:      v.DataDir,
		Hostname:     v.Hostname,
		Ipv4Address:  v.Ipv4Address,
		Cpus:         v.Cpus,
		Memory:       v.Memory,
		EtcdMode:     v.EtcdMode,
	}
	if v.Cohort != nil {
		res.Cohort = marshalControlplaneHostCohortToHostCohortResponseBody(v.Cohort)
	}
	if v.Status != nil {
		res.Status = marshalControlplaneHostStatusToHostStatusResponseBody(v.Status)
	}
	if v.DefaultPgedgeVersion != nil {
		res.DefaultPgedgeVersion = marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(v.DefaultPgedgeVersion)
	}
	if v.SupportedPgedgeVersions != nil {
		res.SupportedPgedgeVersions = make([]*PgEdgeVersionResponseBody, len(v.SupportedPgedgeVersions))
		for i, val := range v.SupportedPgedgeVersions {
			if val == nil {
				res.SupportedPgedgeVersions[i] = nil
				continue
			}
			res.SupportedPgedgeVersions[i] = marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneHostCohortToHostCohortResponseBody builds a value of type
// *HostCohortResponseBody from a value of type *controlplane.HostCohort.
func marshalControlplaneHostCohortToHostCohortResponseBody(v *controlplane.HostCohort) *HostCohortResponseBody {
	if v == nil {
		return nil
	}
	res := &HostCohortResponseBody{
		Type:             v.Type,
		MemberID:         v.MemberID,
		ControlAvailable: v.ControlAvailable,
	}

	return res
}

// marshalControlplaneHostStatusToHostStatusResponseBody builds a value of type
// *HostStatusResponseBody from a value of type *controlplane.HostStatus.
func marshalControlplaneHostStatusToHostStatusResponseBody(v *controlplane.HostStatus) *HostStatusResponseBody {
	res := &HostStatusResponseBody{
		State:     v.State,
		UpdatedAt: v.UpdatedAt,
	}
	if v.Components != nil {
		res.Components = make(map[string]*ComponentStatusResponseBody, len(v.Components))
		for key, val := range v.Components {
			tk := key
			if val == nil {
				res.Components[tk] = nil
				continue
			}
			res.Components[tk] = marshalControlplaneComponentStatusToComponentStatusResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneComponentStatusToComponentStatusResponseBody builds a
// value of type *ComponentStatusResponseBody from a value of type
// *controlplane.ComponentStatus.
func marshalControlplaneComponentStatusToComponentStatusResponseBody(v *controlplane.ComponentStatus) *ComponentStatusResponseBody {
	res := &ComponentStatusResponseBody{
		Healthy: v.Healthy,
		Error:   v.Error,
	}
	if v.Details != nil {
		res.Details = make(map[string]any, len(v.Details))
		for key, val := range v.Details {
			tk := key
			tv := val
			res.Details[tk] = tv
		}
	}

	return res
}

// marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody builds a value
// of type *PgEdgeVersionResponseBody from a value of type
// *controlplane.PgEdgeVersion.
func marshalControlplanePgEdgeVersionToPgEdgeVersionResponseBody(v *controlplane.PgEdgeVersion) *PgEdgeVersionResponseBody {
	if v == nil {
		return nil
	}
	res := &PgEdgeVersionResponseBody{
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
	}

	return res
}

// marshalControlplaneTaskToTaskResponseBody builds a value of type
// *TaskResponseBody from a value of type *controlplane.Task.
func marshalControlplaneTaskToTaskResponseBody(v *controlplane.Task) *TaskResponseBody {
	res := &TaskResponseBody{
		ParentID:    v.ParentID,
		Scope:       v.Scope,
		EntityID:    v.EntityID,
		DatabaseID:  v.DatabaseID,
		NodeName:    v.NodeName,
		InstanceID:  v.InstanceID,
		HostID:      v.HostID,
		TaskID:      v.TaskID,
		CreatedAt:   v.CreatedAt,
		CompletedAt: v.CompletedAt,
		Type:        v.Type,
		Status:      v.Status,
		Error:       v.Error,
	}

	return res
}

// marshalControlplaneviewsDatabaseViewToDatabaseResponseBodyAbbreviated builds
// a value of type *DatabaseResponseBodyAbbreviated from a value of type
// *controlplaneviews.DatabaseView.
func marshalControlplaneviewsDatabaseViewToDatabaseResponseBodyAbbreviated(v *controlplaneviews.DatabaseView) *DatabaseResponseBodyAbbreviated {
	if v == nil {
		return nil
	}
	res := &DatabaseResponseBodyAbbreviated{
		ID:        string(*v.ID),
		CreatedAt: *v.CreatedAt,
		UpdatedAt: *v.UpdatedAt,
		State:     *v.State,
	}
	if v.TenantID != nil {
		tenantID := string(*v.TenantID)
		res.TenantID = &tenantID
	}
	if v.Instances != nil {
		res.Instances = make([]*InstanceResponseBodyAbbreviated, len(v.Instances))
		for i, val := range v.Instances {
			if val == nil {
				res.Instances[i] = nil
				continue
			}
			res.Instances[i] = marshalControlplaneviewsInstanceViewToInstanceResponseBodyAbbreviated(val)
		}
	} else {
		res.Instances = []*InstanceResponseBodyAbbreviated{}
	}

	return res
}

// marshalControlplaneviewsInstanceViewToInstanceResponseBodyAbbreviated builds
// a value of type *InstanceResponseBodyAbbreviated from a value of type
// *controlplaneviews.InstanceView.
func marshalControlplaneviewsInstanceViewToInstanceResponseBodyAbbreviated(v *controlplaneviews.InstanceView) *InstanceResponseBodyAbbreviated {
	res := &InstanceResponseBodyAbbreviated{
		ID:       *v.ID,
		HostID:   *v.HostID,
		NodeName: *v.NodeName,
		State:    *v.State,
	}

	return res
}

// unmarshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec builds a value of
// type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBody.
func unmarshalDatabaseSpecRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBody) *controlplane.DatabaseSpec {
	res := &controlplane.DatabaseSpec{
		DatabaseName:    *v.DatabaseName,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
	for i, val := range v.Nodes {
		if val == nil {
			res.Nodes[i] = nil
			continue
		}
		res.Nodes[i] = unmarshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			if val == nil {
				res.DatabaseUsers[i] = nil
				continue
			}
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Services != nil {
		res.Services = make([]*controlplane.ServiceSpec, len(v.Services))
		for i, val := range v.Services {
			if val == nil {
				res.Services[i] = nil
				continue
			}
			res.Services[i] = unmarshalServiceSpecRequestBodyToControlplaneServiceSpec(val)
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = unmarshalOrchestratorOptsRequestBodyToControlplaneOrchestratorOpts(v.OrchestratorOpts)
	}

	return res
}

// unmarshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec builds a
// value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBody.
func unmarshalDatabaseNodeSpecRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            *v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
		SourceNode:      v.SourceNode,
	}
	res.HostIds = make([]controlplane.Identifier, len(v.HostIds))
	for i, val := range v.HostIds {
		res.HostIds[i] = controlplane.Identifier(val)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = unmarshalOrchestratorOptsRequestBodyToControlplaneOrchestratorOpts(v.OrchestratorOpts)
	}

	return res
}

// unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec builds a
// value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBody.
func unmarshalBackupConfigSpecRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{}
	res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
	for i, val := range v.Repositories {
		if val == nil {
			res.Repositories[i] = nil
			continue
		}
		res.Repositories[i] = unmarshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(val)
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			if val == nil {
				res.Schedules[i] = nil
				continue
			}
			res.Schedules[i] = unmarshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBody.
func unmarshalBackupRepositorySpecRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBody) *controlplane.BackupRepositorySpec {
	res := &controlplane.BackupRepositorySpec{
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.ID != nil {
		id := controlplane.Identifier(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec
// builds a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBody.
func unmarshalBackupScheduleSpecRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// unmarshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec builds
// a value of type *controlplane.RestoreConfigSpec from a value of type
// *RestoreConfigSpecRequestBody.
func unmarshalRestoreConfigSpecRequestBodyToControlplaneRestoreConfigSpec(v *RestoreConfigSpecRequestBody) *controlplane.RestoreConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.RestoreConfigSpec{
		SourceDatabaseID:   controlplane.Identifier(*v.SourceDatabaseID),
		SourceNodeName:     *v.SourceNodeName,
		SourceDatabaseName: *v.SourceDatabaseName,
	}
	res.Repository = unmarshalRestoreRepositorySpecRequestBodyToControlplaneRestoreRepositorySpec(v.Repository)
	if v.RestoreOptions != nil {
		res.RestoreOptions = make(map[string]string, len(v.RestoreOptions))
		for key, val := range v.RestoreOptions {
			tk := key
			tv := val
			res.RestoreOptions[tk] = tv
		}
	}

	return res
}

// unmarshalRestoreRepositorySpecRequestBodyToControlplaneRestoreRepositorySpec
// builds a value of type *controlplane.RestoreRepositorySpec from a value of
// type *RestoreRepositorySpecRequestBody.
func unmarshalRestoreRepositorySpecRequestBodyToControlplaneRestoreRepositorySpec(v *RestoreRepositorySpecRequestBody) *controlplane.RestoreRepositorySpec {
	res := &controlplane.RestoreRepositorySpec{
		Type:           *v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.ID != nil {
		id := controlplane.Identifier(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalOrchestratorOptsRequestBodyToControlplaneOrchestratorOpts builds a
// value of type *controlplane.OrchestratorOpts from a value of type
// *OrchestratorOptsRequestBody.
func unmarshalOrchestratorOptsRequestBodyToControlplaneOrchestratorOpts(v *OrchestratorOptsRequestBody) *controlplane.OrchestratorOpts {
	if v == nil {
		return nil
	}
	res := &controlplane.OrchestratorOpts{}
	if v.Swarm != nil {
		res.Swarm = unmarshalSwarmOptsRequestBodyToControlplaneSwarmOpts(v.Swarm)
	}

	return res
}

// unmarshalSwarmOptsRequestBodyToControlplaneSwarmOpts builds a value of type
// *controlplane.SwarmOpts from a value of type *SwarmOptsRequestBody.
func unmarshalSwarmOptsRequestBodyToControlplaneSwarmOpts(v *SwarmOptsRequestBody) *controlplane.SwarmOpts {
	if v == nil {
		return nil
	}
	res := &controlplane.SwarmOpts{}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*controlplane.ExtraVolumesSpec, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			if val == nil {
				res.ExtraVolumes[i] = nil
				continue
			}
			res.ExtraVolumes[i] = unmarshalExtraVolumesSpecRequestBodyToControlplaneExtraVolumesSpec(val)
		}
	}
	if v.ExtraNetworks != nil {
		res.ExtraNetworks = make([]*controlplane.ExtraNetworkSpec, len(v.ExtraNetworks))
		for i, val := range v.ExtraNetworks {
			if val == nil {
				res.ExtraNetworks[i] = nil
				continue
			}
			res.ExtraNetworks[i] = unmarshalExtraNetworkSpecRequestBodyToControlplaneExtraNetworkSpec(val)
		}
	}
	if v.ExtraLabels != nil {
		res.ExtraLabels = make(map[string]string, len(v.ExtraLabels))
		for key, val := range v.ExtraLabels {
			tk := key
			tv := val
			res.ExtraLabels[tk] = tv
		}
	}

	return res
}

// unmarshalExtraVolumesSpecRequestBodyToControlplaneExtraVolumesSpec builds a
// value of type *controlplane.ExtraVolumesSpec from a value of type
// *ExtraVolumesSpecRequestBody.
func unmarshalExtraVolumesSpecRequestBodyToControlplaneExtraVolumesSpec(v *ExtraVolumesSpecRequestBody) *controlplane.ExtraVolumesSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.ExtraVolumesSpec{
		HostPath:        *v.HostPath,
		DestinationPath: *v.DestinationPath,
	}

	return res
}

// unmarshalExtraNetworkSpecRequestBodyToControlplaneExtraNetworkSpec builds a
// value of type *controlplane.ExtraNetworkSpec from a value of type
// *ExtraNetworkSpecRequestBody.
func unmarshalExtraNetworkSpecRequestBodyToControlplaneExtraNetworkSpec(v *ExtraNetworkSpecRequestBody) *controlplane.ExtraNetworkSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.ExtraNetworkSpec{
		ID: *v.ID,
	}
	if v.Aliases != nil {
		res.Aliases = make([]string, len(v.Aliases))
		for i, val := range v.Aliases {
			res.Aliases[i] = val
		}
	}
	if v.DriverOpts != nil {
		res.DriverOpts = make(map[string]string, len(v.DriverOpts))
		for key, val := range v.DriverOpts {
			tk := key
			tv := val
			res.DriverOpts[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec builds a
// value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBody.
func unmarshalDatabaseUserSpecRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username: *v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// unmarshalServiceSpecRequestBodyToControlplaneServiceSpec builds a value of
// type *controlplane.ServiceSpec from a value of type *ServiceSpecRequestBody.
func unmarshalServiceSpecRequestBodyToControlplaneServiceSpec(v *ServiceSpecRequestBody) *controlplane.ServiceSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.ServiceSpec{
		ServiceID:   controlplane.Identifier(*v.ServiceID),
		ServiceType: *v.ServiceType,
		Version:     *v.Version,
		Port:        v.Port,
		Cpus:        v.Cpus,
		Memory:      v.Memory,
	}
	res.HostIds = make([]controlplane.Identifier, len(v.HostIds))
	for i, val := range v.HostIds {
		res.HostIds[i] = controlplane.Identifier(val)
	}
	res.Config = make(map[string]any, len(v.Config))
	for key, val := range v.Config {
		tk := key
		tv := val
		res.Config[tk] = tv
	}

	return res
}

// marshalControlplaneDatabaseToDatabaseResponseBody builds a value of type
// *DatabaseResponseBody from a value of type *controlplane.Database.
func marshalControlplaneDatabaseToDatabaseResponseBody(v *controlplane.Database) *DatabaseResponseBody {
	res := &DatabaseResponseBody{
		ID:        string(v.ID),
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
		State:     v.State,
	}
	if v.TenantID != nil {
		tenantID := string(*v.TenantID)
		res.TenantID = &tenantID
	}
	if v.Instances != nil {
		res.Instances = make([]*InstanceResponseBody, len(v.Instances))
		for i, val := range v.Instances {
			if val == nil {
				res.Instances[i] = nil
				continue
			}
			res.Instances[i] = marshalControlplaneInstanceToInstanceResponseBody(val)
		}
	} else {
		res.Instances = []*InstanceResponseBody{}
	}
	if v.ServiceInstances != nil {
		res.ServiceInstances = make([]*ServiceinstanceResponseBody, len(v.ServiceInstances))
		for i, val := range v.ServiceInstances {
			if val == nil {
				res.ServiceInstances[i] = nil
				continue
			}
			res.ServiceInstances[i] = marshalControlplaneServiceinstanceToServiceinstanceResponseBody(val)
		}
	} else {
		res.ServiceInstances = []*ServiceinstanceResponseBody{}
	}
	if v.Spec != nil {
		res.Spec = marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody(v.Spec)
	}

	return res
}

// marshalControlplaneInstanceToInstanceResponseBody builds a value of type
// *InstanceResponseBody from a value of type *controlplane.Instance.
func marshalControlplaneInstanceToInstanceResponseBody(v *controlplane.Instance) *InstanceResponseBody {
	res := &InstanceResponseBody{
		ID:              v.ID,
		HostID:          v.HostID,
		NodeName:        v.NodeName,
		CreatedAt:       v.CreatedAt,
		UpdatedAt:       v.UpdatedAt,
		StatusUpdatedAt: v.StatusUpdatedAt,
		State:           v.State,
		Error:           v.Error,
	}
	if v.ConnectionInfo != nil {
		res.ConnectionInfo = marshalControlplaneInstanceConnectionInfoToInstanceConnectionInfoResponseBody(v.ConnectionInfo)
	}
	if v.Postgres != nil {
		res.Postgres = marshalControlplaneInstancePostgresStatusToInstancePostgresStatusResponseBody(v.Postgres)
	}
	if v.Spock != nil {
		res.Spock = marshalControlplaneInstanceSpockStatusToInstanceSpockStatusResponseBody(v.Spock)
	}

	return res
}

// marshalControlplaneInstanceConnectionInfoToInstanceConnectionInfoResponseBody
// builds a value of type *InstanceConnectionInfoResponseBody from a value of
// type *controlplane.InstanceConnectionInfo.
func marshalControlplaneInstanceConnectionInfoToInstanceConnectionInfoResponseBody(v *controlplane.InstanceConnectionInfo) *InstanceConnectionInfoResponseBody {
	if v == nil {
		return nil
	}
	res := &InstanceConnectionInfoResponseBody{
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// marshalControlplaneInstancePostgresStatusToInstancePostgresStatusResponseBody
// builds a value of type *InstancePostgresStatusResponseBody from a value of
// type *controlplane.InstancePostgresStatus.
func marshalControlplaneInstancePostgresStatusToInstancePostgresStatusResponseBody(v *controlplane.InstancePostgresStatus) *InstancePostgresStatusResponseBody {
	if v == nil {
		return nil
	}
	res := &InstancePostgresStatusResponseBody{
		Version:        v.Version,
		PatroniState:   v.PatroniState,
		Role:           v.Role,
		PendingRestart: v.PendingRestart,
		PatroniPaused:  v.PatroniPaused,
	}

	return res
}

// marshalControlplaneInstanceSpockStatusToInstanceSpockStatusResponseBody
// builds a value of type *InstanceSpockStatusResponseBody from a value of type
// *controlplane.InstanceSpockStatus.
func marshalControlplaneInstanceSpockStatusToInstanceSpockStatusResponseBody(v *controlplane.InstanceSpockStatus) *InstanceSpockStatusResponseBody {
	if v == nil {
		return nil
	}
	res := &InstanceSpockStatusResponseBody{
		ReadOnly: v.ReadOnly,
		Version:  v.Version,
	}
	if v.Subscriptions != nil {
		res.Subscriptions = make([]*InstanceSubscriptionResponseBody, len(v.Subscriptions))
		for i, val := range v.Subscriptions {
			if val == nil {
				res.Subscriptions[i] = nil
				continue
			}
			res.Subscriptions[i] = marshalControlplaneInstanceSubscriptionToInstanceSubscriptionResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneInstanceSubscriptionToInstanceSubscriptionResponseBody
// builds a value of type *InstanceSubscriptionResponseBody from a value of
// type *controlplane.InstanceSubscription.
func marshalControlplaneInstanceSubscriptionToInstanceSubscriptionResponseBody(v *controlplane.InstanceSubscription) *InstanceSubscriptionResponseBody {
	if v == nil {
		return nil
	}
	res := &InstanceSubscriptionResponseBody{
		ProviderNode: v.ProviderNode,
		Name:         v.Name,
		Status:       v.Status,
	}

	return res
}

// marshalControlplaneServiceinstanceToServiceinstanceResponseBody builds a
// value of type *ServiceinstanceResponseBody from a value of type
// *controlplane.Serviceinstance.
func marshalControlplaneServiceinstanceToServiceinstanceResponseBody(v *controlplane.Serviceinstance) *ServiceinstanceResponseBody {
	res := &ServiceinstanceResponseBody{
		ServiceInstanceID: v.ServiceInstanceID,
		ServiceID:         v.ServiceID,
		DatabaseID:        string(v.DatabaseID),
		HostID:            v.HostID,
		State:             v.State,
		CreatedAt:         v.CreatedAt,
		UpdatedAt:         v.UpdatedAt,
		Error:             v.Error,
	}
	if v.Status != nil {
		res.Status = marshalControlplaneServiceInstanceStatusToServiceInstanceStatusResponseBody(v.Status)
	}

	return res
}

// marshalControlplaneServiceInstanceStatusToServiceInstanceStatusResponseBody
// builds a value of type *ServiceInstanceStatusResponseBody from a value of
// type *controlplane.ServiceInstanceStatus.
func marshalControlplaneServiceInstanceStatusToServiceInstanceStatusResponseBody(v *controlplane.ServiceInstanceStatus) *ServiceInstanceStatusResponseBody {
	if v == nil {
		return nil
	}
	res := &ServiceInstanceStatusResponseBody{
		ContainerID:  v.ContainerID,
		ImageVersion: v.ImageVersion,
		Hostname:     v.Hostname,
		Ipv4Address:  v.Ipv4Address,
		LastHealthAt: v.LastHealthAt,
		ServiceReady: v.ServiceReady,
	}
	if v.Ports != nil {
		res.Ports = make([]*PortMappingResponseBody, len(v.Ports))
		for i, val := range v.Ports {
			if val == nil {
				res.Ports[i] = nil
				continue
			}
			res.Ports[i] = marshalControlplanePortMappingToPortMappingResponseBody(val)
		}
	}
	if v.HealthCheck != nil {
		res.HealthCheck = marshalControlplaneHealthCheckResultToHealthCheckResultResponseBody(v.HealthCheck)
	}

	return res
}

// marshalControlplanePortMappingToPortMappingResponseBody builds a value of
// type *PortMappingResponseBody from a value of type *controlplane.PortMapping.
func marshalControlplanePortMappingToPortMappingResponseBody(v *controlplane.PortMapping) *PortMappingResponseBody {
	if v == nil {
		return nil
	}
	res := &PortMappingResponseBody{
		Name:          v.Name,
		ContainerPort: v.ContainerPort,
		HostPort:      v.HostPort,
	}

	return res
}

// marshalControlplaneHealthCheckResultToHealthCheckResultResponseBody builds a
// value of type *HealthCheckResultResponseBody from a value of type
// *controlplane.HealthCheckResult.
func marshalControlplaneHealthCheckResultToHealthCheckResultResponseBody(v *controlplane.HealthCheckResult) *HealthCheckResultResponseBody {
	if v == nil {
		return nil
	}
	res := &HealthCheckResultResponseBody{
		Status:    v.Status,
		Message:   v.Message,
		CheckedAt: v.CheckedAt,
	}

	return res
}

// marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody builds a value of
// type *DatabaseSpecResponseBody from a value of type
// *controlplane.DatabaseSpec.
func marshalControlplaneDatabaseSpecToDatabaseSpecResponseBody(v *controlplane.DatabaseSpec) *DatabaseSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecResponseBody{
		DatabaseName:    v.DatabaseName,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecResponseBody, len(v.Nodes))
		for i, val := range v.Nodes {
			if val == nil {
				res.Nodes[i] = nil
				continue
			}
			res.Nodes[i] = marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponseBody(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecResponseBody{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecResponseBody, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			if val == nil {
				res.DatabaseUsers[i] = nil
				continue
			}
			res.DatabaseUsers[i] = marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponseBody(val)
		}
	}
	if v.Services != nil {
		res.Services = make([]*ServiceSpecResponseBody, len(v.Services))
		for i, val := range v.Services {
			if val == nil {
				res.Services[i] = nil
				continue
			}
			res.Services[i] = marshalControlplaneServiceSpecToServiceSpecResponseBody(val)
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneRestoreConfigSpecToRestoreConfigSpecResponseBody(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = marshalControlplaneOrchestratorOptsToOrchestratorOptsResponseBody(v.OrchestratorOpts)
	}

	return res
}

// marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponseBody builds a
// value of type *DatabaseNodeSpecResponseBody from a value of type
// *controlplane.DatabaseNodeSpec.
func marshalControlplaneDatabaseNodeSpecToDatabaseNodeSpecResponseBody(v *controlplane.DatabaseNodeSpec) *DatabaseNodeSpecResponseBody {
	res := &DatabaseNodeSpecResponseBody{
		Name:            v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
		SourceNode:      v.SourceNode,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = string(val)
		}
	} else {
		res.HostIds = []string{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneRestoreConfigSpecToRestoreConfigSpecResponseBody(v.RestoreConfig)
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = marshalControlplaneOrchestratorOptsToOrchestratorOptsResponseBody(v.OrchestratorOpts)
	}

	return res
}

// marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody builds a
// value of type *BackupConfigSpecResponseBody from a value of type
// *controlplane.BackupConfigSpec.
func marshalControlplaneBackupConfigSpecToBackupConfigSpecResponseBody(v *controlplane.BackupConfigSpec) *BackupConfigSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecResponseBody{}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecResponseBody, len(v.Repositories))
		for i, val := range v.Repositories {
			if val == nil {
				res.Repositories[i] = nil
				continue
			}
			res.Repositories[i] = marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponseBody(val)
		}
	} else {
		res.Repositories = []*BackupRepositorySpecResponseBody{}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecResponseBody, len(v.Schedules))
		for i, val := range v.Schedules {
			if val == nil {
				res.Schedules[i] = nil
				continue
			}
			res.Schedules[i] = marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponseBody
// builds a value of type *BackupRepositorySpecResponseBody from a value of
// type *controlplane.BackupRepositorySpec.
func marshalControlplaneBackupRepositorySpecToBackupRepositorySpecResponseBody(v *controlplane.BackupRepositorySpec) *BackupRepositorySpecResponseBody {
	res := &BackupRepositorySpecResponseBody{
		Type:              v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.ID != nil {
		id := string(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponseBody builds
// a value of type *BackupScheduleSpecResponseBody from a value of type
// *controlplane.BackupScheduleSpec.
func marshalControlplaneBackupScheduleSpecToBackupScheduleSpecResponseBody(v *controlplane.BackupScheduleSpec) *BackupScheduleSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecResponseBody{
		ID:             v.ID,
		Type:           v.Type,
		CronExpression: v.CronExpression,
	}

	return res
}

// marshalControlplaneRestoreConfigSpecToRestoreConfigSpecResponseBody builds a
// value of type *RestoreConfigSpecResponseBody from a value of type
// *controlplane.RestoreConfigSpec.
func marshalControlplaneRestoreConfigSpecToRestoreConfigSpecResponseBody(v *controlplane.RestoreConfigSpec) *RestoreConfigSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &RestoreConfigSpecResponseBody{
		SourceDatabaseID:   string(v.SourceDatabaseID),
		SourceNodeName:     v.SourceNodeName,
		SourceDatabaseName: v.SourceDatabaseName,
	}
	if v.Repository != nil {
		res.Repository = marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecResponseBody(v.Repository)
	}
	if v.RestoreOptions != nil {
		res.RestoreOptions = make(map[string]string, len(v.RestoreOptions))
		for key, val := range v.RestoreOptions {
			tk := key
			tv := val
			res.RestoreOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecResponseBody
// builds a value of type *RestoreRepositorySpecResponseBody from a value of
// type *controlplane.RestoreRepositorySpec.
func marshalControlplaneRestoreRepositorySpecToRestoreRepositorySpecResponseBody(v *controlplane.RestoreRepositorySpec) *RestoreRepositorySpecResponseBody {
	res := &RestoreRepositorySpecResponseBody{
		Type:           v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.ID != nil {
		id := string(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneOrchestratorOptsToOrchestratorOptsResponseBody builds a
// value of type *OrchestratorOptsResponseBody from a value of type
// *controlplane.OrchestratorOpts.
func marshalControlplaneOrchestratorOptsToOrchestratorOptsResponseBody(v *controlplane.OrchestratorOpts) *OrchestratorOptsResponseBody {
	if v == nil {
		return nil
	}
	res := &OrchestratorOptsResponseBody{}
	if v.Swarm != nil {
		res.Swarm = marshalControlplaneSwarmOptsToSwarmOptsResponseBody(v.Swarm)
	}

	return res
}

// marshalControlplaneSwarmOptsToSwarmOptsResponseBody builds a value of type
// *SwarmOptsResponseBody from a value of type *controlplane.SwarmOpts.
func marshalControlplaneSwarmOptsToSwarmOptsResponseBody(v *controlplane.SwarmOpts) *SwarmOptsResponseBody {
	if v == nil {
		return nil
	}
	res := &SwarmOptsResponseBody{}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*ExtraVolumesSpecResponseBody, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			if val == nil {
				res.ExtraVolumes[i] = nil
				continue
			}
			res.ExtraVolumes[i] = marshalControlplaneExtraVolumesSpecToExtraVolumesSpecResponseBody(val)
		}
	}
	if v.ExtraNetworks != nil {
		res.ExtraNetworks = make([]*ExtraNetworkSpecResponseBody, len(v.ExtraNetworks))
		for i, val := range v.ExtraNetworks {
			if val == nil {
				res.ExtraNetworks[i] = nil
				continue
			}
			res.ExtraNetworks[i] = marshalControlplaneExtraNetworkSpecToExtraNetworkSpecResponseBody(val)
		}
	}
	if v.ExtraLabels != nil {
		res.ExtraLabels = make(map[string]string, len(v.ExtraLabels))
		for key, val := range v.ExtraLabels {
			tk := key
			tv := val
			res.ExtraLabels[tk] = tv
		}
	}

	return res
}

// marshalControlplaneExtraVolumesSpecToExtraVolumesSpecResponseBody builds a
// value of type *ExtraVolumesSpecResponseBody from a value of type
// *controlplane.ExtraVolumesSpec.
func marshalControlplaneExtraVolumesSpecToExtraVolumesSpecResponseBody(v *controlplane.ExtraVolumesSpec) *ExtraVolumesSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &ExtraVolumesSpecResponseBody{
		HostPath:        v.HostPath,
		DestinationPath: v.DestinationPath,
	}

	return res
}

// marshalControlplaneExtraNetworkSpecToExtraNetworkSpecResponseBody builds a
// value of type *ExtraNetworkSpecResponseBody from a value of type
// *controlplane.ExtraNetworkSpec.
func marshalControlplaneExtraNetworkSpecToExtraNetworkSpecResponseBody(v *controlplane.ExtraNetworkSpec) *ExtraNetworkSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &ExtraNetworkSpecResponseBody{
		ID: v.ID,
	}
	if v.Aliases != nil {
		res.Aliases = make([]string, len(v.Aliases))
		for i, val := range v.Aliases {
			res.Aliases[i] = val
		}
	}
	if v.DriverOpts != nil {
		res.DriverOpts = make(map[string]string, len(v.DriverOpts))
		for key, val := range v.DriverOpts {
			tk := key
			tv := val
			res.DriverOpts[tk] = tv
		}
	}

	return res
}

// marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponseBody builds a
// value of type *DatabaseUserSpecResponseBody from a value of type
// *controlplane.DatabaseUserSpec.
func marshalControlplaneDatabaseUserSpecToDatabaseUserSpecResponseBody(v *controlplane.DatabaseUserSpec) *DatabaseUserSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecResponseBody{
		Username: v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneServiceSpecToServiceSpecResponseBody builds a value of
// type *ServiceSpecResponseBody from a value of type *controlplane.ServiceSpec.
func marshalControlplaneServiceSpecToServiceSpecResponseBody(v *controlplane.ServiceSpec) *ServiceSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &ServiceSpecResponseBody{
		ServiceID:   string(v.ServiceID),
		ServiceType: v.ServiceType,
		Version:     v.Version,
		Port:        v.Port,
		Cpus:        v.Cpus,
		Memory:      v.Memory,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = string(val)
		}
	} else {
		res.HostIds = []string{}
	}
	if v.Config != nil {
		res.Config = make(map[string]any, len(v.Config))
		for key, val := range v.Config {
			tk := key
			tv := val
			res.Config[tk] = tv
		}
	}

	return res
}

// marshalControlplaneviewsInstanceViewToInstanceResponseBody builds a value of
// type *InstanceResponseBody from a value of type
// *controlplaneviews.InstanceView.
func marshalControlplaneviewsInstanceViewToInstanceResponseBody(v *controlplaneviews.InstanceView) *InstanceResponseBody {
	res := &InstanceResponseBody{
		ID:              *v.ID,
		HostID:          *v.HostID,
		NodeName:        *v.NodeName,
		CreatedAt:       *v.CreatedAt,
		UpdatedAt:       *v.UpdatedAt,
		StatusUpdatedAt: v.StatusUpdatedAt,
		State:           *v.State,
		Error:           v.Error,
	}
	if v.ConnectionInfo != nil {
		res.ConnectionInfo = marshalControlplaneviewsInstanceConnectionInfoViewToInstanceConnectionInfoResponseBody(v.ConnectionInfo)
	}
	if v.Postgres != nil {
		res.Postgres = marshalControlplaneviewsInstancePostgresStatusViewToInstancePostgresStatusResponseBody(v.Postgres)
	}
	if v.Spock != nil {
		res.Spock = marshalControlplaneviewsInstanceSpockStatusViewToInstanceSpockStatusResponseBody(v.Spock)
	}

	return res
}

// marshalControlplaneviewsInstanceConnectionInfoViewToInstanceConnectionInfoResponseBody
// builds a value of type *InstanceConnectionInfoResponseBody from a value of
// type *controlplaneviews.InstanceConnectionInfoView.
func marshalControlplaneviewsInstanceConnectionInfoViewToInstanceConnectionInfoResponseBody(v *controlplaneviews.InstanceConnectionInfoView) *InstanceConnectionInfoResponseBody {
	if v == nil {
		return nil
	}
	res := &InstanceConnectionInfoResponseBody{
		Hostname:    v.Hostname,
		Ipv4Address: v.Ipv4Address,
		Port:        v.Port,
	}

	return res
}

// marshalControlplaneviewsInstancePostgresStatusViewToInstancePostgresStatusResponseBody
// builds a value of type *InstancePostgresStatusResponseBody from a value of
// type *controlplaneviews.InstancePostgresStatusView.
func marshalControlplaneviewsInstancePostgresStatusViewToInstancePostgresStatusResponseBody(v *controlplaneviews.InstancePostgresStatusView) *InstancePostgresStatusResponseBody {
	if v == nil {
		return nil
	}
	res := &InstancePostgresStatusResponseBody{
		Version:        v.Version,
		PatroniState:   v.PatroniState,
		Role:           v.Role,
		PendingRestart: v.PendingRestart,
		PatroniPaused:  v.PatroniPaused,
	}

	return res
}

// marshalControlplaneviewsInstanceSpockStatusViewToInstanceSpockStatusResponseBody
// builds a value of type *InstanceSpockStatusResponseBody from a value of type
// *controlplaneviews.InstanceSpockStatusView.
func marshalControlplaneviewsInstanceSpockStatusViewToInstanceSpockStatusResponseBody(v *controlplaneviews.InstanceSpockStatusView) *InstanceSpockStatusResponseBody {
	if v == nil {
		return nil
	}
	res := &InstanceSpockStatusResponseBody{
		ReadOnly: v.ReadOnly,
		Version:  v.Version,
	}
	if v.Subscriptions != nil {
		res.Subscriptions = make([]*InstanceSubscriptionResponseBody, len(v.Subscriptions))
		for i, val := range v.Subscriptions {
			if val == nil {
				res.Subscriptions[i] = nil
				continue
			}
			res.Subscriptions[i] = marshalControlplaneviewsInstanceSubscriptionViewToInstanceSubscriptionResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneviewsInstanceSubscriptionViewToInstanceSubscriptionResponseBody
// builds a value of type *InstanceSubscriptionResponseBody from a value of
// type *controlplaneviews.InstanceSubscriptionView.
func marshalControlplaneviewsInstanceSubscriptionViewToInstanceSubscriptionResponseBody(v *controlplaneviews.InstanceSubscriptionView) *InstanceSubscriptionResponseBody {
	if v == nil {
		return nil
	}
	res := &InstanceSubscriptionResponseBody{
		ProviderNode: *v.ProviderNode,
		Name:         *v.Name,
		Status:       *v.Status,
	}

	return res
}

// marshalControlplaneviewsServiceinstanceViewToServiceinstanceResponseBody
// builds a value of type *ServiceinstanceResponseBody from a value of type
// *controlplaneviews.ServiceinstanceView.
func marshalControlplaneviewsServiceinstanceViewToServiceinstanceResponseBody(v *controlplaneviews.ServiceinstanceView) *ServiceinstanceResponseBody {
	res := &ServiceinstanceResponseBody{
		ServiceInstanceID: *v.ServiceInstanceID,
		ServiceID:         *v.ServiceID,
		DatabaseID:        string(*v.DatabaseID),
		HostID:            *v.HostID,
		State:             *v.State,
		CreatedAt:         *v.CreatedAt,
		UpdatedAt:         *v.UpdatedAt,
		Error:             v.Error,
	}
	if v.Status != nil {
		res.Status = marshalControlplaneviewsServiceInstanceStatusViewToServiceInstanceStatusResponseBody(v.Status)
	}

	return res
}

// marshalControlplaneviewsServiceInstanceStatusViewToServiceInstanceStatusResponseBody
// builds a value of type *ServiceInstanceStatusResponseBody from a value of
// type *controlplaneviews.ServiceInstanceStatusView.
func marshalControlplaneviewsServiceInstanceStatusViewToServiceInstanceStatusResponseBody(v *controlplaneviews.ServiceInstanceStatusView) *ServiceInstanceStatusResponseBody {
	if v == nil {
		return nil
	}
	res := &ServiceInstanceStatusResponseBody{
		ContainerID:  v.ContainerID,
		ImageVersion: v.ImageVersion,
		Hostname:     v.Hostname,
		Ipv4Address:  v.Ipv4Address,
		LastHealthAt: v.LastHealthAt,
		ServiceReady: v.ServiceReady,
	}
	if v.Ports != nil {
		res.Ports = make([]*PortMappingResponseBody, len(v.Ports))
		for i, val := range v.Ports {
			if val == nil {
				res.Ports[i] = nil
				continue
			}
			res.Ports[i] = marshalControlplaneviewsPortMappingViewToPortMappingResponseBody(val)
		}
	}
	if v.HealthCheck != nil {
		res.HealthCheck = marshalControlplaneviewsHealthCheckResultViewToHealthCheckResultResponseBody(v.HealthCheck)
	}

	return res
}

// marshalControlplaneviewsPortMappingViewToPortMappingResponseBody builds a
// value of type *PortMappingResponseBody from a value of type
// *controlplaneviews.PortMappingView.
func marshalControlplaneviewsPortMappingViewToPortMappingResponseBody(v *controlplaneviews.PortMappingView) *PortMappingResponseBody {
	if v == nil {
		return nil
	}
	res := &PortMappingResponseBody{
		Name:          *v.Name,
		ContainerPort: v.ContainerPort,
		HostPort:      v.HostPort,
	}

	return res
}

// marshalControlplaneviewsHealthCheckResultViewToHealthCheckResultResponseBody
// builds a value of type *HealthCheckResultResponseBody from a value of type
// *controlplaneviews.HealthCheckResultView.
func marshalControlplaneviewsHealthCheckResultViewToHealthCheckResultResponseBody(v *controlplaneviews.HealthCheckResultView) *HealthCheckResultResponseBody {
	if v == nil {
		return nil
	}
	res := &HealthCheckResultResponseBody{
		Status:    *v.Status,
		Message:   v.Message,
		CheckedAt: *v.CheckedAt,
	}

	return res
}

// marshalControlplaneviewsDatabaseSpecViewToDatabaseSpecResponseBody builds a
// value of type *DatabaseSpecResponseBody from a value of type
// *controlplaneviews.DatabaseSpecView.
func marshalControlplaneviewsDatabaseSpecViewToDatabaseSpecResponseBody(v *controlplaneviews.DatabaseSpecView) *DatabaseSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseSpecResponseBody{
		DatabaseName:    *v.DatabaseName,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	if v.Nodes != nil {
		res.Nodes = make([]*DatabaseNodeSpecResponseBody, len(v.Nodes))
		for i, val := range v.Nodes {
			if val == nil {
				res.Nodes[i] = nil
				continue
			}
			res.Nodes[i] = marshalControlplaneviewsDatabaseNodeSpecViewToDatabaseNodeSpecResponseBody(val)
		}
	} else {
		res.Nodes = []*DatabaseNodeSpecResponseBody{}
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*DatabaseUserSpecResponseBody, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			if val == nil {
				res.DatabaseUsers[i] = nil
				continue
			}
			res.DatabaseUsers[i] = marshalControlplaneviewsDatabaseUserSpecViewToDatabaseUserSpecResponseBody(val)
		}
	}
	if v.Services != nil {
		res.Services = make([]*ServiceSpecResponseBody, len(v.Services))
		for i, val := range v.Services {
			if val == nil {
				res.Services[i] = nil
				continue
			}
			res.Services[i] = marshalControlplaneviewsServiceSpecViewToServiceSpecResponseBody(val)
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneviewsBackupConfigSpecViewToBackupConfigSpecResponseBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpecResponseBody(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = marshalControlplaneviewsOrchestratorOptsViewToOrchestratorOptsResponseBody(v.OrchestratorOpts)
	}

	return res
}

// marshalControlplaneviewsDatabaseNodeSpecViewToDatabaseNodeSpecResponseBody
// builds a value of type *DatabaseNodeSpecResponseBody from a value of type
// *controlplaneviews.DatabaseNodeSpecView.
func marshalControlplaneviewsDatabaseNodeSpecViewToDatabaseNodeSpecResponseBody(v *controlplaneviews.DatabaseNodeSpecView) *DatabaseNodeSpecResponseBody {
	res := &DatabaseNodeSpecResponseBody{
		Name:            *v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
		SourceNode:      v.SourceNode,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = string(val)
		}
	} else {
		res.HostIds = []string{}
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = marshalControlplaneviewsBackupConfigSpecViewToBackupConfigSpecResponseBody(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = marshalControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpecResponseBody(v.RestoreConfig)
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = marshalControlplaneviewsOrchestratorOptsViewToOrchestratorOptsResponseBody(v.OrchestratorOpts)
	}

	return res
}

// marshalControlplaneviewsBackupConfigSpecViewToBackupConfigSpecResponseBody
// builds a value of type *BackupConfigSpecResponseBody from a value of type
// *controlplaneviews.BackupConfigSpecView.
func marshalControlplaneviewsBackupConfigSpecViewToBackupConfigSpecResponseBody(v *controlplaneviews.BackupConfigSpecView) *BackupConfigSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupConfigSpecResponseBody{}
	if v.Repositories != nil {
		res.Repositories = make([]*BackupRepositorySpecResponseBody, len(v.Repositories))
		for i, val := range v.Repositories {
			if val == nil {
				res.Repositories[i] = nil
				continue
			}
			res.Repositories[i] = marshalControlplaneviewsBackupRepositorySpecViewToBackupRepositorySpecResponseBody(val)
		}
	} else {
		res.Repositories = []*BackupRepositorySpecResponseBody{}
	}
	if v.Schedules != nil {
		res.Schedules = make([]*BackupScheduleSpecResponseBody, len(v.Schedules))
		for i, val := range v.Schedules {
			if val == nil {
				res.Schedules[i] = nil
				continue
			}
			res.Schedules[i] = marshalControlplaneviewsBackupScheduleSpecViewToBackupScheduleSpecResponseBody(val)
		}
	}

	return res
}

// marshalControlplaneviewsBackupRepositorySpecViewToBackupRepositorySpecResponseBody
// builds a value of type *BackupRepositorySpecResponseBody from a value of
// type *controlplaneviews.BackupRepositorySpecView.
func marshalControlplaneviewsBackupRepositorySpecViewToBackupRepositorySpecResponseBody(v *controlplaneviews.BackupRepositorySpecView) *BackupRepositorySpecResponseBody {
	res := &BackupRepositorySpecResponseBody{
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.ID != nil {
		id := string(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneviewsBackupScheduleSpecViewToBackupScheduleSpecResponseBody
// builds a value of type *BackupScheduleSpecResponseBody from a value of type
// *controlplaneviews.BackupScheduleSpecView.
func marshalControlplaneviewsBackupScheduleSpecViewToBackupScheduleSpecResponseBody(v *controlplaneviews.BackupScheduleSpecView) *BackupScheduleSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupScheduleSpecResponseBody{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// marshalControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpecResponseBody
// builds a value of type *RestoreConfigSpecResponseBody from a value of type
// *controlplaneviews.RestoreConfigSpecView.
func marshalControlplaneviewsRestoreConfigSpecViewToRestoreConfigSpecResponseBody(v *controlplaneviews.RestoreConfigSpecView) *RestoreConfigSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &RestoreConfigSpecResponseBody{
		SourceDatabaseID:   string(*v.SourceDatabaseID),
		SourceNodeName:     *v.SourceNodeName,
		SourceDatabaseName: *v.SourceDatabaseName,
	}
	if v.Repository != nil {
		res.Repository = marshalControlplaneviewsRestoreRepositorySpecViewToRestoreRepositorySpecResponseBody(v.Repository)
	}
	if v.RestoreOptions != nil {
		res.RestoreOptions = make(map[string]string, len(v.RestoreOptions))
		for key, val := range v.RestoreOptions {
			tk := key
			tv := val
			res.RestoreOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneviewsRestoreRepositorySpecViewToRestoreRepositorySpecResponseBody
// builds a value of type *RestoreRepositorySpecResponseBody from a value of
// type *controlplaneviews.RestoreRepositorySpecView.
func marshalControlplaneviewsRestoreRepositorySpecViewToRestoreRepositorySpecResponseBody(v *controlplaneviews.RestoreRepositorySpecView) *RestoreRepositorySpecResponseBody {
	res := &RestoreRepositorySpecResponseBody{
		Type:           *v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.ID != nil {
		id := string(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// marshalControlplaneviewsOrchestratorOptsViewToOrchestratorOptsResponseBody
// builds a value of type *OrchestratorOptsResponseBody from a value of type
// *controlplaneviews.OrchestratorOptsView.
func marshalControlplaneviewsOrchestratorOptsViewToOrchestratorOptsResponseBody(v *controlplaneviews.OrchestratorOptsView) *OrchestratorOptsResponseBody {
	if v == nil {
		return nil
	}
	res := &OrchestratorOptsResponseBody{}
	if v.Swarm != nil {
		res.Swarm = marshalControlplaneviewsSwarmOptsViewToSwarmOptsResponseBody(v.Swarm)
	}

	return res
}

// marshalControlplaneviewsSwarmOptsViewToSwarmOptsResponseBody builds a value
// of type *SwarmOptsResponseBody from a value of type
// *controlplaneviews.SwarmOptsView.
func marshalControlplaneviewsSwarmOptsViewToSwarmOptsResponseBody(v *controlplaneviews.SwarmOptsView) *SwarmOptsResponseBody {
	if v == nil {
		return nil
	}
	res := &SwarmOptsResponseBody{}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*ExtraVolumesSpecResponseBody, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			if val == nil {
				res.ExtraVolumes[i] = nil
				continue
			}
			res.ExtraVolumes[i] = marshalControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpecResponseBody(val)
		}
	}
	if v.ExtraNetworks != nil {
		res.ExtraNetworks = make([]*ExtraNetworkSpecResponseBody, len(v.ExtraNetworks))
		for i, val := range v.ExtraNetworks {
			if val == nil {
				res.ExtraNetworks[i] = nil
				continue
			}
			res.ExtraNetworks[i] = marshalControlplaneviewsExtraNetworkSpecViewToExtraNetworkSpecResponseBody(val)
		}
	}
	if v.ExtraLabels != nil {
		res.ExtraLabels = make(map[string]string, len(v.ExtraLabels))
		for key, val := range v.ExtraLabels {
			tk := key
			tv := val
			res.ExtraLabels[tk] = tv
		}
	}

	return res
}

// marshalControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpecResponseBody
// builds a value of type *ExtraVolumesSpecResponseBody from a value of type
// *controlplaneviews.ExtraVolumesSpecView.
func marshalControlplaneviewsExtraVolumesSpecViewToExtraVolumesSpecResponseBody(v *controlplaneviews.ExtraVolumesSpecView) *ExtraVolumesSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &ExtraVolumesSpecResponseBody{
		HostPath:        *v.HostPath,
		DestinationPath: *v.DestinationPath,
	}

	return res
}

// marshalControlplaneviewsExtraNetworkSpecViewToExtraNetworkSpecResponseBody
// builds a value of type *ExtraNetworkSpecResponseBody from a value of type
// *controlplaneviews.ExtraNetworkSpecView.
func marshalControlplaneviewsExtraNetworkSpecViewToExtraNetworkSpecResponseBody(v *controlplaneviews.ExtraNetworkSpecView) *ExtraNetworkSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &ExtraNetworkSpecResponseBody{
		ID: *v.ID,
	}
	if v.Aliases != nil {
		res.Aliases = make([]string, len(v.Aliases))
		for i, val := range v.Aliases {
			res.Aliases[i] = val
		}
	}
	if v.DriverOpts != nil {
		res.DriverOpts = make(map[string]string, len(v.DriverOpts))
		for key, val := range v.DriverOpts {
			tk := key
			tv := val
			res.DriverOpts[tk] = tv
		}
	}

	return res
}

// marshalControlplaneviewsDatabaseUserSpecViewToDatabaseUserSpecResponseBody
// builds a value of type *DatabaseUserSpecResponseBody from a value of type
// *controlplaneviews.DatabaseUserSpecView.
func marshalControlplaneviewsDatabaseUserSpecViewToDatabaseUserSpecResponseBody(v *controlplaneviews.DatabaseUserSpecView) *DatabaseUserSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &DatabaseUserSpecResponseBody{
		Username: *v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// marshalControlplaneviewsServiceSpecViewToServiceSpecResponseBody builds a
// value of type *ServiceSpecResponseBody from a value of type
// *controlplaneviews.ServiceSpecView.
func marshalControlplaneviewsServiceSpecViewToServiceSpecResponseBody(v *controlplaneviews.ServiceSpecView) *ServiceSpecResponseBody {
	if v == nil {
		return nil
	}
	res := &ServiceSpecResponseBody{
		ServiceID:   string(*v.ServiceID),
		ServiceType: *v.ServiceType,
		Version:     *v.Version,
		Port:        v.Port,
		Cpus:        v.Cpus,
		Memory:      v.Memory,
	}
	if v.HostIds != nil {
		res.HostIds = make([]string, len(v.HostIds))
		for i, val := range v.HostIds {
			res.HostIds[i] = string(val)
		}
	} else {
		res.HostIds = []string{}
	}
	if v.Config != nil {
		res.Config = make(map[string]any, len(v.Config))
		for key, val := range v.Config {
			tk := key
			tv := val
			res.Config[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec builds
// a value of type *controlplane.DatabaseSpec from a value of type
// *DatabaseSpecRequestBodyRequestBody.
func unmarshalDatabaseSpecRequestBodyRequestBodyToControlplaneDatabaseSpec(v *DatabaseSpecRequestBodyRequestBody) *controlplane.DatabaseSpec {
	res := &controlplane.DatabaseSpec{
		DatabaseName:    *v.DatabaseName,
		PostgresVersion: v.PostgresVersion,
		SpockVersion:    v.SpockVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
	}
	res.Nodes = make([]*controlplane.DatabaseNodeSpec, len(v.Nodes))
	for i, val := range v.Nodes {
		if val == nil {
			res.Nodes[i] = nil
			continue
		}
		res.Nodes[i] = unmarshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(val)
	}
	if v.DatabaseUsers != nil {
		res.DatabaseUsers = make([]*controlplane.DatabaseUserSpec, len(v.DatabaseUsers))
		for i, val := range v.DatabaseUsers {
			if val == nil {
				res.DatabaseUsers[i] = nil
				continue
			}
			res.DatabaseUsers[i] = unmarshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(val)
		}
	}
	if v.Services != nil {
		res.Services = make([]*controlplane.ServiceSpec, len(v.Services))
		for i, val := range v.Services {
			if val == nil {
				res.Services[i] = nil
				continue
			}
			res.Services[i] = unmarshalServiceSpecRequestBodyRequestBodyToControlplaneServiceSpec(val)
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = unmarshalOrchestratorOptsRequestBodyRequestBodyToControlplaneOrchestratorOpts(v.OrchestratorOpts)
	}

	return res
}

// unmarshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec
// builds a value of type *controlplane.DatabaseNodeSpec from a value of type
// *DatabaseNodeSpecRequestBodyRequestBody.
func unmarshalDatabaseNodeSpecRequestBodyRequestBodyToControlplaneDatabaseNodeSpec(v *DatabaseNodeSpecRequestBodyRequestBody) *controlplane.DatabaseNodeSpec {
	res := &controlplane.DatabaseNodeSpec{
		Name:            *v.Name,
		PostgresVersion: v.PostgresVersion,
		Port:            v.Port,
		Cpus:            v.Cpus,
		Memory:          v.Memory,
		SourceNode:      v.SourceNode,
	}
	res.HostIds = make([]controlplane.Identifier, len(v.HostIds))
	for i, val := range v.HostIds {
		res.HostIds[i] = controlplane.Identifier(val)
	}
	if v.PostgresqlConf != nil {
		res.PostgresqlConf = make(map[string]any, len(v.PostgresqlConf))
		for key, val := range v.PostgresqlConf {
			tk := key
			tv := val
			res.PostgresqlConf[tk] = tv
		}
	}
	if v.BackupConfig != nil {
		res.BackupConfig = unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v.BackupConfig)
	}
	if v.RestoreConfig != nil {
		res.RestoreConfig = unmarshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec(v.RestoreConfig)
	}
	if v.OrchestratorOpts != nil {
		res.OrchestratorOpts = unmarshalOrchestratorOptsRequestBodyRequestBodyToControlplaneOrchestratorOpts(v.OrchestratorOpts)
	}

	return res
}

// unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec
// builds a value of type *controlplane.BackupConfigSpec from a value of type
// *BackupConfigSpecRequestBodyRequestBody.
func unmarshalBackupConfigSpecRequestBodyRequestBodyToControlplaneBackupConfigSpec(v *BackupConfigSpecRequestBodyRequestBody) *controlplane.BackupConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupConfigSpec{}
	res.Repositories = make([]*controlplane.BackupRepositorySpec, len(v.Repositories))
	for i, val := range v.Repositories {
		if val == nil {
			res.Repositories[i] = nil
			continue
		}
		res.Repositories[i] = unmarshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(val)
	}
	if v.Schedules != nil {
		res.Schedules = make([]*controlplane.BackupScheduleSpec, len(v.Schedules))
		for i, val := range v.Schedules {
			if val == nil {
				res.Schedules[i] = nil
				continue
			}
			res.Schedules[i] = unmarshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(val)
		}
	}

	return res
}

// unmarshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec
// builds a value of type *controlplane.BackupRepositorySpec from a value of
// type *BackupRepositorySpecRequestBodyRequestBody.
func unmarshalBackupRepositorySpecRequestBodyRequestBodyToControlplaneBackupRepositorySpec(v *BackupRepositorySpecRequestBodyRequestBody) *controlplane.BackupRepositorySpec {
	res := &controlplane.BackupRepositorySpec{
		Type:              *v.Type,
		S3Bucket:          v.S3Bucket,
		S3Region:          v.S3Region,
		S3Endpoint:        v.S3Endpoint,
		S3Key:             v.S3Key,
		S3KeySecret:       v.S3KeySecret,
		GcsBucket:         v.GcsBucket,
		GcsEndpoint:       v.GcsEndpoint,
		GcsKey:            v.GcsKey,
		AzureAccount:      v.AzureAccount,
		AzureContainer:    v.AzureContainer,
		AzureEndpoint:     v.AzureEndpoint,
		AzureKey:          v.AzureKey,
		RetentionFull:     v.RetentionFull,
		RetentionFullType: v.RetentionFullType,
		BasePath:          v.BasePath,
	}
	if v.ID != nil {
		id := controlplane.Identifier(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec
// builds a value of type *controlplane.BackupScheduleSpec from a value of type
// *BackupScheduleSpecRequestBodyRequestBody.
func unmarshalBackupScheduleSpecRequestBodyRequestBodyToControlplaneBackupScheduleSpec(v *BackupScheduleSpecRequestBodyRequestBody) *controlplane.BackupScheduleSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.BackupScheduleSpec{
		ID:             *v.ID,
		Type:           *v.Type,
		CronExpression: *v.CronExpression,
	}

	return res
}

// unmarshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec
// builds a value of type *controlplane.RestoreConfigSpec from a value of type
// *RestoreConfigSpecRequestBodyRequestBody.
func unmarshalRestoreConfigSpecRequestBodyRequestBodyToControlplaneRestoreConfigSpec(v *RestoreConfigSpecRequestBodyRequestBody) *controlplane.RestoreConfigSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.RestoreConfigSpec{
		SourceDatabaseID:   controlplane.Identifier(*v.SourceDatabaseID),
		SourceNodeName:     *v.SourceNodeName,
		SourceDatabaseName: *v.SourceDatabaseName,
	}
	res.Repository = unmarshalRestoreRepositorySpecRequestBodyRequestBodyToControlplaneRestoreRepositorySpec(v.Repository)
	if v.RestoreOptions != nil {
		res.RestoreOptions = make(map[string]string, len(v.RestoreOptions))
		for key, val := range v.RestoreOptions {
			tk := key
			tv := val
			res.RestoreOptions[tk] = tv
		}
	}

	return res
}

// unmarshalRestoreRepositorySpecRequestBodyRequestBodyToControlplaneRestoreRepositorySpec
// builds a value of type *controlplane.RestoreRepositorySpec from a value of
// type *RestoreRepositorySpecRequestBodyRequestBody.
func unmarshalRestoreRepositorySpecRequestBodyRequestBodyToControlplaneRestoreRepositorySpec(v *RestoreRepositorySpecRequestBodyRequestBody) *controlplane.RestoreRepositorySpec {
	res := &controlplane.RestoreRepositorySpec{
		Type:           *v.Type,
		S3Bucket:       v.S3Bucket,
		S3Region:       v.S3Region,
		S3Endpoint:     v.S3Endpoint,
		S3Key:          v.S3Key,
		S3KeySecret:    v.S3KeySecret,
		GcsBucket:      v.GcsBucket,
		GcsEndpoint:    v.GcsEndpoint,
		GcsKey:         v.GcsKey,
		AzureAccount:   v.AzureAccount,
		AzureContainer: v.AzureContainer,
		AzureEndpoint:  v.AzureEndpoint,
		AzureKey:       v.AzureKey,
		BasePath:       v.BasePath,
	}
	if v.ID != nil {
		id := controlplane.Identifier(*v.ID)
		res.ID = &id
	}
	if v.CustomOptions != nil {
		res.CustomOptions = make(map[string]string, len(v.CustomOptions))
		for key, val := range v.CustomOptions {
			tk := key
			tv := val
			res.CustomOptions[tk] = tv
		}
	}

	return res
}

// unmarshalOrchestratorOptsRequestBodyRequestBodyToControlplaneOrchestratorOpts
// builds a value of type *controlplane.OrchestratorOpts from a value of type
// *OrchestratorOptsRequestBodyRequestBody.
func unmarshalOrchestratorOptsRequestBodyRequestBodyToControlplaneOrchestratorOpts(v *OrchestratorOptsRequestBodyRequestBody) *controlplane.OrchestratorOpts {
	if v == nil {
		return nil
	}
	res := &controlplane.OrchestratorOpts{}
	if v.Swarm != nil {
		res.Swarm = unmarshalSwarmOptsRequestBodyRequestBodyToControlplaneSwarmOpts(v.Swarm)
	}

	return res
}

// unmarshalSwarmOptsRequestBodyRequestBodyToControlplaneSwarmOpts builds a
// value of type *controlplane.SwarmOpts from a value of type
// *SwarmOptsRequestBodyRequestBody.
func unmarshalSwarmOptsRequestBodyRequestBodyToControlplaneSwarmOpts(v *SwarmOptsRequestBodyRequestBody) *controlplane.SwarmOpts {
	if v == nil {
		return nil
	}
	res := &controlplane.SwarmOpts{}
	if v.ExtraVolumes != nil {
		res.ExtraVolumes = make([]*controlplane.ExtraVolumesSpec, len(v.ExtraVolumes))
		for i, val := range v.ExtraVolumes {
			if val == nil {
				res.ExtraVolumes[i] = nil
				continue
			}
			res.ExtraVolumes[i] = unmarshalExtraVolumesSpecRequestBodyRequestBodyToControlplaneExtraVolumesSpec(val)
		}
	}
	if v.ExtraNetworks != nil {
		res.ExtraNetworks = make([]*controlplane.ExtraNetworkSpec, len(v.ExtraNetworks))
		for i, val := range v.ExtraNetworks {
			if val == nil {
				res.ExtraNetworks[i] = nil
				continue
			}
			res.ExtraNetworks[i] = unmarshalExtraNetworkSpecRequestBodyRequestBodyToControlplaneExtraNetworkSpec(val)
		}
	}
	if v.ExtraLabels != nil {
		res.ExtraLabels = make(map[string]string, len(v.ExtraLabels))
		for key, val := range v.ExtraLabels {
			tk := key
			tv := val
			res.ExtraLabels[tk] = tv
		}
	}

	return res
}

// unmarshalExtraVolumesSpecRequestBodyRequestBodyToControlplaneExtraVolumesSpec
// builds a value of type *controlplane.ExtraVolumesSpec from a value of type
// *ExtraVolumesSpecRequestBodyRequestBody.
func unmarshalExtraVolumesSpecRequestBodyRequestBodyToControlplaneExtraVolumesSpec(v *ExtraVolumesSpecRequestBodyRequestBody) *controlplane.ExtraVolumesSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.ExtraVolumesSpec{
		HostPath:        *v.HostPath,
		DestinationPath: *v.DestinationPath,
	}

	return res
}

// unmarshalExtraNetworkSpecRequestBodyRequestBodyToControlplaneExtraNetworkSpec
// builds a value of type *controlplane.ExtraNetworkSpec from a value of type
// *ExtraNetworkSpecRequestBodyRequestBody.
func unmarshalExtraNetworkSpecRequestBodyRequestBodyToControlplaneExtraNetworkSpec(v *ExtraNetworkSpecRequestBodyRequestBody) *controlplane.ExtraNetworkSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.ExtraNetworkSpec{
		ID: *v.ID,
	}
	if v.Aliases != nil {
		res.Aliases = make([]string, len(v.Aliases))
		for i, val := range v.Aliases {
			res.Aliases[i] = val
		}
	}
	if v.DriverOpts != nil {
		res.DriverOpts = make(map[string]string, len(v.DriverOpts))
		for key, val := range v.DriverOpts {
			tk := key
			tv := val
			res.DriverOpts[tk] = tv
		}
	}

	return res
}

// unmarshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec
// builds a value of type *controlplane.DatabaseUserSpec from a value of type
// *DatabaseUserSpecRequestBodyRequestBody.
func unmarshalDatabaseUserSpecRequestBodyRequestBodyToControlplaneDatabaseUserSpec(v *DatabaseUserSpecRequestBodyRequestBody) *controlplane.DatabaseUserSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.DatabaseUserSpec{
		Username: *v.Username,
		Password: v.Password,
		DbOwner:  v.DbOwner,
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	if v.Roles != nil {
		res.Roles = make([]string, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = val
		}
	}

	return res
}

// unmarshalServiceSpecRequestBodyRequestBodyToControlplaneServiceSpec builds a
// value of type *controlplane.ServiceSpec from a value of type
// *ServiceSpecRequestBodyRequestBody.
func unmarshalServiceSpecRequestBodyRequestBodyToControlplaneServiceSpec(v *ServiceSpecRequestBodyRequestBody) *controlplane.ServiceSpec {
	if v == nil {
		return nil
	}
	res := &controlplane.ServiceSpec{
		ServiceID:   controlplane.Identifier(*v.ServiceID),
		ServiceType: *v.ServiceType,
		Version:     *v.Version,
		Port:        v.Port,
		Cpus:        v.Cpus,
		Memory:      v.Memory,
	}
	res.HostIds = make([]controlplane.Identifier, len(v.HostIds))
	for i, val := range v.HostIds {
		res.HostIds[i] = controlplane.Identifier(val)
	}
	res.Config = make(map[string]any, len(v.Config))
	for key, val := range v.Config {
		tk := key
		tv := val
		res.Config[tk] = tv
	}

	return res
}

// marshalControlplaneTaskLogEntryToTaskLogEntryResponseBody builds a value of
// type *TaskLogEntryResponseBody from a value of type
// *controlplane.TaskLogEntry.
func marshalControlplaneTaskLogEntryToTaskLogEntryResponseBody(v *controlplane.TaskLogEntry) *TaskLogEntryResponseBody {
	res := &TaskLogEntryResponseBody{
		Timestamp: v.Timestamp,
		Message:   v.Message,
	}
	if v.Fields != nil {
		res.Fields = make(map[string]any, len(v.Fields))
		for key, val := range v.Fields {
			tk := key
			tv := val
			res.Fields[tk] = tv
		}
	}

	return res
}
